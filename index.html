<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Poker - Advanced Pro</title>
    <style>
        :root {
            --bg: #020105;
            --text: #ffebcc;
            --panel-bg: rgba(25, 12, 5, 0.7);
            --panel-border: rgba(212, 175, 55, 0.3);
            --btn-bg: rgba(45, 25, 15, 0.6);
            --btn-border: rgba(212, 175, 55, 0.4);
            --btn-text: #d4af37;
            --accent: #d4af37;
            --rules-bg: rgba(10, 5, 2, 0.85);
            --btn-hover-bg: rgba(212, 175, 55, 0.2);
            --btn-hover-shadow: rgba(212, 175, 55, 0.3);
        }
        [data-theme="light"] {
            /* Light mode: premium metallic grey-blue */
            --bg: #6f7f92;
            --text: #0b1118;
            --panel-bg: rgba(245, 248, 252, 0.82);
            --panel-border: rgba(15, 25, 38, 0.18);
            --btn-bg: rgba(248, 251, 255, 0.92);
            --btn-border: rgba(15, 25, 38, 0.22);
            --btn-text: #0b1118;
            --accent: #3c6a9a;
            --rules-bg: rgba(246, 250, 255, 0.94);
            --btn-hover-bg: rgba(30, 70, 120, 0.10);
            --btn-hover-shadow: rgba(20, 35, 55, 0.14);
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: var(--text); }
        /* Classic clean background for light mode */
        [data-theme="light"] body {
            background-color: var(--bg);
            background-image:
                /* Strong metallic highlight band (works even without blend modes) */
                linear-gradient(115deg,
                    rgba(255,255,255,0.00) 0%,
                    rgba(255,255,255,0.00) 36%,
                    rgba(255,255,255,0.65) 46%,
                    rgba(255,255,255,0.10) 54%,
                    rgba(255,255,255,0.00) 66%,
                    rgba(255,255,255,0.00) 100%
                ),
                /* Soft sheen */
                radial-gradient(1100px 900px at 18% 16%, rgba(255,255,255,0.34), rgba(255,255,255,0.0) 60%),
                radial-gradient(950px 780px at 84% 20%, rgba(255,255,255,0.18), rgba(255,255,255,0.0) 62%),
                radial-gradient(900px 900px at 50% 95%, rgba(10, 25, 45, 0.22), rgba(0,0,0,0.0) 62%),
                /* Brushed metal streaks (matte texture) */
                repeating-linear-gradient(96deg, rgba(255,255,255,0.12) 0 1px, rgba(0,0,0,0.0) 1px 10px),
                repeating-linear-gradient(276deg, rgba(0,0,0,0.07) 0 1px, rgba(0,0,0,0.0) 1px 14px),
                /* Base gradient */
                linear-gradient(180deg, rgba(235,245,255,0.40), rgba(120,140,160,0.16) 45%, rgba(20,30,40,0.26));
            /* Use normal stacking so it looks metallic even on browsers that ignore blend modes */
            background-blend-mode: normal;
        }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Lobby UI */
        #lobby-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(15px); }
        .lobby-panel { background: rgba(30, 20, 10, 0.95); border: 1px solid #d4af37; padding: 30px; border-radius: 20px; box-shadow: 0 0 50px rgba(212, 175, 55, 0.3); text-align: center; width: 400px; max-height: 90vh; overflow-y: auto; }
        .lobby-input-group { text-align: left; margin-bottom: 15px; }
        .lobby-label { color: #d4af37; font-size: 0.9em; margin-bottom: 5px; display: block; }
        .lobby-input { width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #d4af37; color: gold; border-radius: 6px; box-sizing: border-box; }
        .lobby-btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #d4af37, #8c6b00); border: none; color: black; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; margin-top: 10px; }
        
        /* Seat Selection UI */
        #seat-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 900; backdrop-filter: blur(5px); }
        .seat-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; width: 900px; }
        .seat-box { background: rgba(40, 30, 20, 0.85); border: 2px solid #d4af37; border-radius: 12px; padding: 12px; transition: 0.3s; color: gold; text-align: center; }
        .seat-actions { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .seat-action-btn { padding: 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; border: 1px solid gold; background: rgba(212, 175, 55, 0.1); color: gold; }
        .seat-action-btn:hover { background: gold; color: black; }
        .seat-action-btn.active { background: gold; color: black; }
        .start-game-area { position: absolute; bottom: -80px; left: 0; width: 100%; text-align: center; }

        /* Summary UI */
        #summary-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 10, 5, 0.98); border: 2px solid gold; padding: 40px; border-radius: 20px; z-index: 2000; width: 450px; text-align: center; }
        .summary-list { margin: 20px 0; border-top: 1px solid rgba(212, 175, 55, 0.3); }
        .summary-item { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }

        #ui-overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; width: 100%; }
        .panel { background: var(--panel-bg); padding: 15px; border-radius: 12px; border: 1px solid var(--panel-border); margin-bottom: 10px; pointer-events: auto; backdrop-filter: blur(25px); box-shadow: 0 0 40px rgba(0,0,0,0.35); }

        /* Desktop resizable HUD panel (PRE-FLOP: YOU area) */
        #hud-panel {
            width: 260px;
            min-width: 210px;
            max-width: 520px;
            max-height: 80vh;
            overflow: auto;
            resize: both;
        }
        
        /* Rules Modal */
        #rules-btn { position: relative; z-index: 20; pointer-events: auto; }
        /* Rules panel: floating (outside HUD box), positioned by JS under the ? button */
        #rules-modal { display: none; position: fixed; top: 90px; left: 20px; margin: 0; transform: none; background: var(--rules-bg); border: 1px solid rgba(255, 215, 0, 0.30); padding: 12px 12px 8px; border-radius: 14px; z-index: 2000; width: 330px; max-height: calc(100vh - 170px); overflow-y: auto; backdrop-filter: blur(12px); color: var(--text); box-shadow: 0 0 28px rgba(0,0,0,0.16); scrollbar-width: thin; }
        #rules-modal::-webkit-scrollbar { width: 10px; }
        #rules-modal::-webkit-scrollbar-thumb { background: rgba(212,175,55,0.35); border-radius: 10px; border: 2px solid rgba(0,0,0,0.15); }
        #rules-modal::-webkit-scrollbar-track { background: rgba(0,0,0,0.08); border-radius: 10px; }
        #rules-modal h2 { color: var(--accent); margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid rgba(212, 175, 55, 0.18); padding-bottom: 8px; font-size: 1.05em; }
        #rules-modal ul { list-style: none; padding: 0; }
        #rules-modal li { margin-bottom: 10px; display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 5px; }
        
        .rule-item { margin-bottom: 12px; border-bottom: 1px solid rgba(212, 175, 55, 0.10); padding-bottom: 8px; font-size: 0.82em; }
        .card-icons { display: flex; gap: 5px; margin-top: 5px; }
        .card-icons span { background: #fff; color: #000; padding: 2px 5px; border-radius: 3px; font-weight: bold; font-family: serif; min-width: 25px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .card-icons .card-red { color: #bb3333; }
        .card-icons .card-black { color: #1a1a1a; }

        #rules-modal .rank-name { font-weight: bold; color: var(--accent); font-size: 1.02em; }
        #close-rules { float: right; cursor: pointer; color: var(--accent); font-size: 20px; }

        #history-panel { position: absolute; right: 20px; top: 20px; width: 280px; max-height: 40vh; overflow-y: auto; z-index: 10; }
        /* Desktop: allow Activity panel to collapse (Hide/Show) */
        #history-panel.collapsed #history-list { display: none; }
        #history-panel.collapsed { width: 180px; max-height: none; }
        #controls { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; z-index: 10; align-items: center; }
        
        .touch-btn { 
            background: var(--btn-bg); border: 1px solid var(--btn-border); padding: 12px 20px; 
            color: var(--btn-text); font-weight: bold; border-radius: 6px; cursor: pointer; 
            transition: 0.3s; text-transform: uppercase; letter-spacing: 1px; min-width: 80px;
        }
        .touch-btn:hover:not(:disabled) { background: var(--btn-hover-bg); box-shadow: 0 0 20px var(--btn-hover-shadow); }
        .touch-btn:disabled { opacity: 0.1; cursor: not-allowed; }

        /* Icon-only buttons (desktop default sizing; mobile overrides below) */
        .icon-btn {
            width: 38px !important;
            height: 38px !important;
            min-width: 38px !important;
            padding: 0 !important;
            border-radius: 999px !important;
            display: inline-flex !important;
            align-items: center !important;
            justify-content: center !important;
            font-size: 0 !important; /* hide text */
            line-height: 1 !important;
            letter-spacing: 0 !important;
        }
        .icon-btn::before {
            content: attr(data-icon);
            font-size: 18px;
            line-height: 1;
        }

        /* HUD panel collapsed => compact: show game-msg + horizontal icon row */
        #hud-panel.collapsed {
            width: 270px;
            min-width: 220px;
            max-width: 320px;
            padding: 10px;
            resize: none;
            overflow: visible;
        }
        #hud-panel.collapsed #pot-row,
        #hud-panel.collapsed #voice-status {
            display: none !important;
        }
        #hud-panel.collapsed #hud-buttons {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            gap: 8px;
            justify-content: flex-start;
            align-items: center;
            margin-top: 10px;
        }
        #hud-panel.collapsed #hud-buttons .touch-btn { margin-top: 0 !important; }
        #hud-panel.collapsed #game-msg { font-size: 0.95em; letter-spacing: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .adjust-panel { display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.18); padding: 5px 10px; border-radius: 6px; border: 1px solid rgba(212, 175, 55, 0.12); }
        .adjust-btn { background: none; border: none; color: var(--accent); font-size: 20px; cursor: pointer; font-weight: bold; width: 30px; }
        #raise-amount-display { min-width: 40px; text-align: center; font-weight: bold; color: #00ff00; }

        #btn-next { display: none; background: linear-gradient(135deg, #d4af37, #8c6b00); color: black; padding: 15px 40px; font-size: 1.2em; }
        
        .player-hud { position: absolute; pointer-events: none; transform: translate(-50%, -100%); text-align: center; }
        .chip-display { color: var(--text); font-size: 13px; margin-top: 3px; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,0.25); }
        #game-msg { font-size: 1.1em; color: var(--text); text-align: left; letter-spacing: 2px; }

        #theme-toggle { pointer-events: auto; }

        /* -------- Mobile responsiveness -------- */
        @media (max-width: 600px) {
            /* HUD panel not resizable on mobile */
            #hud-panel { resize: none; max-width: none; }
            body { overflow: hidden; }
            .lobby-panel { width: calc(100vw - 24px); padding: 18px; border-radius: 16px; }
            .lobby-btn { padding: 12px; font-size: 0.95em; }

            /* Seat selection: make it scrollable, 2 columns */
            #seat-overlay { overflow-y: auto; }
            #seat-selection-title { margin-top: 18px !important; font-size: 1.15em; }
            .seat-container {
                position: relative;
                top: auto;
                left: auto;
                transform: none;
                width: calc(100vw - 20px);
                margin: 16px auto 120px;
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            .seat-box { padding: 10px; }
            .seat-action-btn { padding: 8px; font-size: 0.78em; }

            /* Start Game pinned to the bottom of seat selection (sticky) */
            .start-game-area {
                position: sticky;
                left: auto;
                transform: none;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 8px);
                width: calc(100vw - 20px);
                z-index: 980;
                margin: 8px auto 10px;
            }
            #start-game-btn { width: 100% !important; }

            /* Decor panel (seat selection): stick near the very bottom, just above Start Game */
            #decor-panel {
                position: sticky !important;
                left: auto !important;
                transform: none !important;
                width: calc(100vw - 20px) !important;
                bottom: calc(env(safe-area-inset-bottom, 0px) + 70px) !important;
                z-index: 970;
                max-height: 42vh;
                overflow-y: auto;
                margin: 8px auto 8px;
            }
            #decor-panel.collapsed #decor-body,
            #decor-panel.collapsed #decor-hint { display: none; }

            /* In-game panels */
            #ui-overlay { position: fixed; top: 10px; left: 10px; width: auto; z-index: 12; }
            #ui-overlay .panel { width: min(250px, calc(100vw - 20px)) !important; padding: 10px; }
            #game-msg { font-size: 0.92em; letter-spacing: 1px; }
            #rules-btn { padding: 7px 12px; border-radius: 16px; }
            #rules-modal { width: min(260px, calc(100vw - 40px)); max-height: 40vh; }

            #history-panel {
                position: fixed;
                top: 10px;
                right: 10px;
                left: auto;
                bottom: auto;
                width: min(210px, calc(100vw - 20px));
                max-height: 28vh;
                z-index: 12;
            }
            #history-panel #history-list { max-height: 20vh; overflow-y: auto; font-size: 0.72em; line-height: 1.35; }
            #history-panel.collapsed #history-list { display: none; }
            #controls {
                bottom: calc(env(safe-area-inset-bottom, 0px) + 10px);
                width: calc(100vw - 14px);
                gap: 8px;
                flex-wrap: wrap;
                justify-content: center;
            }
            .touch-btn { padding: 10px 12px; min-width: 0; font-size: 0.86em; }
            .adjust-panel { width: 100%; justify-content: center; }

            /* Icon-only buttons smaller on mobile */
            .icon-btn { width: 32px !important; height: 32px !important; min-width: 32px !important; }
            .icon-btn::before { font-size: 16px; }
            /* Make the small icon buttons a bit less visually heavy */
            #history-collapse.icon-btn {
                border-radius: 999px !important;
                padding: 0 !important;
            }
        }
    </style>
</head>
<body>
    <div id="lobby-overlay">
        <div class="lobby-panel">
            <h1 id="lobby-title" style="color: gold; margin-bottom: 20px; font-size: 1.8em;">NEBULA POKER</h1>
            <div class="lobby-input-group">
                <label class="lobby-label" id="lbl-your-name">YOUR NAME</label>
                <input type="text" id="username-input" class="lobby-input" placeholder="e.g. StarLord">
            </div>
            <div class="lobby-input-group">
                <label class="lobby-label" id="lbl-room-id">ROOM ID</label>
                <input type="text" id="room-id-input" class="lobby-input" placeholder="Room 101">
            </div>
            <div class="lobby-input-group">
                <label class="lobby-label" id="lbl-init-chips">INITIAL CHIPS (Min 1000, Multiples of 50)</label>
                <input type="number" id="init-chips-input" class="lobby-input" value="1000" step="50" min="1000">
            </div>
            <div class="lobby-input-group" id="rounds-group">
                <label class="lobby-label" id="lbl-total-rounds">TOTAL ROUNDS</label>
                <input type="number" id="total-rounds-input" class="lobby-input" value="5" min="1">
            </div>
            <button id="lobby-next-btn" class="lobby-btn">Continue to Select Seat</button>
            <button id="lang-toggle-lobby" class="lobby-btn" style="margin-top:10px;">Language: EN</button>
        </div>
    </div>

    <div id="seat-overlay">
        <h2 id="seat-selection-title" style="color: gold; text-align: center; margin-top: 50px;">SEAT SELECTION</h2>
        <div class="seat-container">
            <div id="seat-grid" style="display: contents;"></div>
            <div class="start-game-area">
                <button id="start-game-btn" class="lobby-btn" style="width: 300px;">Start Game</button>
            </div>
        </div>
        <div id="decor-panel" class="panel" style="position: absolute; left: 50%; transform: translateX(-50%); bottom: 22px; width: 520px; max-width: calc(100vw - 40px); pointer-events: auto;">
            <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
                <div id="decor-title" style="font-weight:800; letter-spacing:0.5px;">Table Decor</div>
                <div id="decor-body" style="display:flex; gap:10px; align-items:center;">
                    <select id="decor-select" class="lobby-input" style="width: 220px; padding: 8px 10px; margin:0;">
                        <option value="none">None</option>
                        <option value="cola">Cola</option>
                        <option value="coffee">Coffee</option>
                        <option value="wine">Red Wine</option>
                        <option value="cigar">Cigar</option>
                    </select>
                    <button id="decor-apply" class="lobby-btn" style="width: 160px; margin:0; padding: 12px 14px;">Apply</button>
                </div>
            </div>
            <div id="decor-hint" style="margin-top:8px; font-size: 0.78em; opacity: 0.8;">Your choice will appear on the table to the right of your hole cards (visible to everyone).</div>
        </div>
    </div>

    <div id="summary-modal">
        <h2 style="color: gold;">HAND OVER</h2>
        <p style="color: rgba(212, 175, 55, 0.6);">Final Chip Standings</p>
        <div class="summary-list" id="summary-list-content"></div>
        <button id="summary-confirm-btn" class="lobby-btn">Confirm Results & Back to Lobby</button>
    </div>

    <div id="container"></div>
    <div id="labels-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></div>
    
    <div id="rules-modal">
        <span id="close-rules">&times;</span>
        <h2 style="text-align: center;">Hand Rankings</h2>
        <div style="font-size: 0.85em;">
            <div class="rule-item">
                <span class="rank-name">Royal Flush</span>
                <div class="card-icons">
                    <span class="card-black">A‚ô†</span><span class="card-black">K‚ô†</span><span class="card-black">Q‚ô†</span><span class="card-black">J‚ô†</span><span class="card-black">10‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Straight Flush</span>
                <div class="card-icons">
                    <span class="card-red">9‚ô•</span><span class="card-red">8‚ô•</span><span class="card-red">7‚ô•</span><span class="card-red">6‚ô•</span><span class="card-red">5‚ô•</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Four of a Kind</span>
                <div class="card-icons">
                    <span class="card-black">A‚ô†</span><span class="card-red">A‚ô•</span><span class="card-black">A‚ô£</span><span class="card-red">A‚ô¶</span><span class="card-black">K‚ô£</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Full House</span>
                <div class="card-icons">
                    <span class="card-black">K‚ô†</span><span class="card-red">K‚ô•</span><span class="card-black">K‚ô£</span><span class="card-red">Q‚ô¶</span><span class="card-black">Q‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Flush</span>
                <div class="card-icons">
                    <span class="card-black">A‚ô£</span><span class="card-black">J‚ô£</span><span class="card-black">8‚ô£</span><span class="card-black">4‚ô£</span><span class="card-black">2‚ô£</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Straight</span>
                <div class="card-icons">
                    <span class="card-black">5‚ô†</span><span class="card-red">4‚ô•</span><span class="card-black">3‚ô£</span><span class="card-red">2‚ô¶</span><span class="card-black">A‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Three of a Kind</span>
                <div class="card-icons">
                    <span class="card-black">Q‚ô†</span><span class="card-red">Q‚ô•</span><span class="card-black">Q‚ô£</span><span class="card-red">8‚ô¶</span><span class="card-black">2‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Two Pair</span>
                <div class="card-icons">
                    <span class="card-black">J‚ô†</span><span class="card-red">J‚ô•</span><span class="card-black">9‚ô£</span><span class="card-red">9‚ô¶</span><span class="card-black">4‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">One Pair</span>
                <div class="card-icons">
                    <span class="card-black">10‚ô†</span><span class="card-red">10‚ô•</span><span class="card-black">A‚ô£</span><span class="card-red">8‚ô¶</span><span class="card-black">3‚ô†</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">High Card</span>
                <div class="card-icons">
                    <span class="card-black">A‚ô†</span><span class="card-red">Q‚ô•</span><span class="card-black">10‚ô£</span><span class="card-red">7‚ô¶</span><span class="card-black">2‚ô†</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="ui-overlay">
        <div id="hud-panel" class="panel" style="margin-left: 0;">
            <div id="hud-header" style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                <div id="game-msg">WAITING</div>
                <button id="hud-collapse" class="touch-btn" style="width:78px; padding: 8px 10px; margin:0; font-size:0.82em;">Hide</button>
            </div>
            <div id="pot-row" style="color: #ffcc99; font-size: 1em; margin-top: 5px; text-align: center;">Pot: <b id="pot-amount" style="color: #00ff00;">0</b></div>
            <div id="hud-buttons" style="margin-top: 10px; display:flex; flex-direction:column; gap:10px;">
                <button id="rules-btn" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Rules & Rankings</button>
                <button id="reset-view" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Reset View</button>
                <button id="theme-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Night Mode</button>
                <button id="bgm-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">BGM: Off</button>
                <button id="sfx-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">SFX: On</button>
                <button id="lang-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Language: EN</button>
                <button id="mic-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Mic: Off</button>
            </div>
            <div id="voice-status" style="font-size: 0.78em; opacity: 0.75; margin-top: 6px; text-align: left;">Voice: Not connected</div>
            <div id="rules-modal-anchor"></div>
        </div>
    </div>

    <audio id="bgm" src="Love_Me.mp3" loop preload="auto"></audio>

    <div id="history-panel" class="panel">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
            <h3 style="margin: 0; font-size: 0.9em; color: rgba(212, 175, 55, 0.6);">ACTIVITY</h3>
            <button id="history-collapse" class="touch-btn" style="width: 78px; padding: 8px 10px; margin:0; font-size:0.82em;">Hide</button>
        </div>
        <div id="history-list" style="font-size: 0.8em; line-height: 1.6;"></div>
    </div>

    <div id="controls">
        <button id="btn-fold" class="touch-btn">Fold</button>
        <button id="btn-check" class="touch-btn">Check</button>
        <div class="adjust-panel">
            <button id="btn-minus" class="adjust-btn">-</button>
            <span id="raise-amount-display">50</span>
            <button id="btn-plus" class="adjust-btn">+</button>
        </div>
        <button id="btn-raise" class="touch-btn">Raise</button>
        <button id="btn-allin" class="touch-btn" style="color:#ff4444;">All-in</button>
        <button id="btn-rebuy" class="touch-btn" style="display:none;">Rebuy</button>
        <button id="btn-next" class="touch-btn">Confirm & Next Round</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- socket.io client (served by our Node backend when deployed) -->
    <script src="/socket.io/socket.io.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = {
            numPlayers: 10,
            cardWidth: 0.7, cardHeight: 1.0,
            theme: { 
                orange: 0xff8c1a, 
                gold: 0xffd700, 
                pink: 0xff99cc, 
                warmYellow: 0xffe0b3,
                purple: 0x8a2be2,
                blue: 0x0000ff
            },
            chipValue: 50
        };

        let scene, camera, renderer, controls;
        let cardsGroup, chipsGroup, tableGroup, environmentGroup, playerStacksGroup;
        let whiteSpot = null;
        let rimLight = null;
        let nebulaParticles = null;
        let starField = null;
        let tableParticles = null;
        let hudData = [];
        let currentRaiseInput = 50;
        const DEFAULT_VIEW = {
            cameraPos: new THREE.Vector3(0, 11, 15),
            target: new THREE.Vector3(0, 0, 0),
            fov: 45
        };
        
        const BUILD_TAG = `build-${new Date().toISOString()}`;
        const IS_MULTIPLAYER = (location.protocol !== 'file:') && (typeof window.io === 'function');
        const socket = IS_MULTIPLAYER ? window.io() : null;
        const CLIENT_ID = (() => {
            try {
                const k = 'nebula_client_id';
                let v = localStorage.getItem(k);
                if (!v) {
                    v = (crypto?.randomUUID?.() || `cid-${Math.random().toString(16).slice(2)}-${Date.now()}`);
                    localStorage.setItem(k, v);
                }
                return v;
            } catch (_) {
                return `cid-${Math.random().toString(16).slice(2)}-${Date.now()}`;
            }
        })();
        let mpWired = false;
        let pendingJoin = false;
        let joinedRoomOnce = false;
        let mySeatIdx = -1;
        let isHost = false;
        let lastRoomState = null;
        const pendingPrivateHands = new Map(); // seatIdx -> hand
        const privateHandRenderToken = new Map(); // seatIdx -> number (cancel in-flight renders)
        let lastActionSeatIdx = null;
        let rebuyPromptedForHand = null;
        let lastHandOverNum = null;
        let potChipFX = []; // meshes for bet-to-pot animation
        let matchOverReceived = false;
        let matchOverAcked = false;
        let opponentPlaceholderToken = 0;
        let lastOpponentPlaceholderHandNum = null;
        let UI_LANG = localStorage.getItem('nebula_lang') || 'en';
        const activityRaw = [];
        const seatDecor = Array(CONFIG.numPlayers).fill('none'); // offline decor per seat
        function t(key) {
            const dict = {
                en: {
                    lang_label: 'Language: EN',
                    lang_label_lobby: 'Language: EN',
                    lobby_continue: 'Continue to Select Seat',
                    lobby_your_name: 'YOUR NAME',
                    lobby_room_id: 'ROOM ID',
                    lobby_init_chips: 'INITIAL CHIPS (Min 1000, Multiples of 50)',
                    lobby_total_rounds: 'TOTAL ROUNDS',
                    seat_selection: 'SEAT SELECTION',
                    start_game: 'Start Game',
                    waiting_host: 'Waiting for Host',
                    next_round: 'Next Round',
                    rules: 'Rules & Rankings',
                    reset_view: 'Reset View',
                    light_mode: 'Light Mode',
                    night_mode: 'Night Mode',
                    final_standings: 'Final Standings',
                    hand_results: 'Hand Results',
                    buy_in: 'Buy-in',
                    chips: 'Chips',
                    net: 'Net',
                    win: 'Win',
                    loss: 'Loss',
                    round_waiting: 'WAITING',
                    round_preflop: 'PRE-FLOP',
                    round_flop: 'FLOP',
                    round_turn: 'TURN',
                    round_river: 'RIVER',
                    round_showdown: 'SHOWDOWN',
                    round_hand_over: 'HAND OVER',
                    spectator: 'Spectator (pick a seat before start)',
                    btn_fold: 'Fold',
                    btn_check: 'Check',
                    btn_call: 'Call',
                    btn_bet: 'Bet',
                    btn_raise: 'Raise',
                    btn_allin: 'All-in',
                    btn_rebuy: 'Rebuy',
                    btn_confirm_next: 'Confirm & Next Round',
                    seat_empty: 'Empty',
                    seat_take: 'Take Seat',
                    seat_add_ai: 'Add AI',
                    seat_remove_ai: 'Remove AI',
                    seat_remove: 'Remove',
                    seat_label: 'Seat',
                    pot_label: 'Pot',
                    acting_label: 'acting',
                    decor_title: 'Table Decor',
                    decor_hint: 'Your choice will appear on the table to the right of your hole cards (visible to everyone).',
                    decor_apply: 'Apply',
                    decor_none: 'None',
                    decor_cola: 'Cola',
                    decor_coffee: 'Cappuccino',
                    decor_wine: 'Red Wine',
                    decor_cigar: 'Cigar',
                    decor_set: 'Decor set:',
                    decor_hide: 'Hide',
                    decor_show: 'Show'
                    ,
                    history_hide: 'Hide',
                    history_show: 'Show'
                    ,
                    hud_hide: 'Hide',
                    hud_show: 'Show'
                },
                zh: {
                    lang_label: 'Language: ‰∏≠Êñá',
                    lang_label_lobby: 'ËØ≠Ë®ÄÔºö‰∏≠Êñá',
                    lobby_continue: 'ÁªßÁª≠ËøõÂÖ•ÈÄâÂ∫ß',
                    lobby_your_name: '‰Ω†ÁöÑÊòµÁß∞',
                    lobby_room_id: 'ÊàøÈó¥Âè∑',
                    lobby_init_chips: 'ÂàùÂßãÁ≠πÁ†ÅÔºàËá≥Â∞ë1000Ôºå50ÁöÑÂÄçÊï∞Ôºâ',
                    lobby_total_rounds: 'ÊÄªÂ±ÄÊï∞',
                    seat_selection: 'ÈÄâÊã©Â∫ß‰Ωç',
                    start_game: 'ÂºÄÂßãÊ∏∏Êàè',
                    waiting_host: 'Á≠âÂæÖÊàø‰∏ªÂºÄÂßã',
                    next_round: '‰∏ã‰∏ÄÂ±Ä',
                    rules: 'ËßÑÂàô‰∏éÁâåÂûã',
                    reset_view: 'ÊÅ¢Â§çËßÜËßí',
                    light_mode: 'Êòé‰∫ÆÊ®°Âºè',
                    night_mode: 'Â§úÈó¥Ê®°Âºè',
                    final_standings: 'ÊúÄÁªàÁªìÁÆó',
                    hand_results: 'ÊØèÊâãÁªìÊûú',
                    buy_in: 'Êú¨Èáë',
                    chips: 'Ââ©‰Ωô',
                    net: 'ÂáÄËµ¢‰∫è',
                    win: 'Ëµö',
                    loss: '‰∫è',
                    round_waiting: 'Á≠âÂæÖ‰∏≠',
                    round_preflop: 'ÁøªÁâåÂâç',
                    round_flop: 'ÁøªÁâå',
                    round_turn: 'ËΩ¨Áâå',
                    round_river: 'Ê≤≥Áâå',
                    round_showdown: 'ÊëäÁâå',
                    round_hand_over: 'Êú¨Â±ÄÁªìÊùü',
                    spectator: 'ËßÇÊàòÔºàËØ∑ÂÖàÂÖ•Â∫ßÔºâ',
                    btn_fold: 'ÂºÉÁâå',
                    btn_check: 'ËøáÁâå',
                    btn_call: 'Ë∑üÊ≥®',
                    btn_bet: '‰∏ãÊ≥®',
                    btn_raise: 'Âä†Ê≥®',
                    btn_allin: 'ÂÖ®‰∏ã',
                    btn_rebuy: 'Ë°•Á†Å',
                    btn_confirm_next: 'Á°ÆËÆ§Âπ∂‰∏ã‰∏ÄÂ±Ä',
                    seat_empty: 'Á©∫‰Ωç',
                    seat_take: 'ÂÖ•Â∫ß',
                    seat_add_ai: 'Ê∑ªÂä†AI',
                    seat_remove_ai: 'ÁßªÈô§AI',
                    seat_remove: 'ÁßªÈô§',
                    seat_label: 'Â∫ß‰Ωç',
                    pot_label: 'ÁâåÊ±†',
                    acting_label: 'Ë°åÂä®‰∏≠',
                    decor_title: 'Ê°åÈù¢ÊëÜ‰ª∂',
                    decor_hint: '‰Ω†ÁöÑÈÄâÊã©‰ºöÂá∫Áé∞Âú®‰Ω†ÊâãÁâåÂè≥‰æßÁöÑÊ°åÈù¢‰∏äÔºàÊâÄÊúâ‰∫∫ÂèØËßÅÔºâ„ÄÇ',
                    decor_apply: 'Â∫îÁî®',
                    decor_none: 'Êó†',
                    decor_cola: 'ÂèØ‰πê',
                    decor_coffee: 'Âç°Â∏ÉÂ•áËØ∫',
                    decor_wine: 'Á∫¢ÈÖí',
                    decor_cigar: 'Èõ™ËåÑ',
                    decor_set: 'ÊëÜ‰ª∂Â∑≤ËÆæÁΩÆÔºö',
                    decor_hide: 'Êî∂Ëµ∑',
                    decor_show: 'Â±ïÂºÄ'
                    ,
                    history_hide: 'Êî∂Ëµ∑',
                    history_show: 'Â±ïÂºÄ'
                    ,
                    hud_hide: 'Êî∂Ëµ∑',
                    hud_show: 'Â±ïÂºÄ'
                }
            };
            return (dict[UI_LANG] && dict[UI_LANG][key]) || (dict.en[key] || key);
        }

        function trDecorChoice(v) {
            const s = String(v || 'none').toLowerCase();
            if (s === 'cola') return t('decor_cola');
            if (s === 'coffee') return t('decor_coffee');
            if (s === 'wine') return t('decor_wine');
            if (s === 'cigar') return t('decor_cigar');
            return t('decor_none');
        }

        function trRound(r) {
            const rr = String(r || '').toUpperCase();
            if (rr === 'WAITING') return t('round_waiting');
            if (rr === 'PRE-FLOP' || rr === 'PREFLOP') return t('round_preflop');
            if (rr === 'FLOP') return t('round_flop');
            if (rr === 'TURN') return t('round_turn');
            if (rr === 'RIVER') return t('round_river');
            if (rr === 'SHOWDOWN') return t('round_showdown');
            if (rr === 'HAND_OVER') return t('round_hand_over');
            return r;
        }

        function trHandDesc(desc) {
            const d = String(desc || '');
            const map = {
                'Royal Flush': 'ÁöáÂÆ∂ÂêåËä±È°∫',
                'Straight Flush': 'ÂêåËä±È°∫',
                'Four of a Kind': 'ÂõõÊù°',
                'Full House': 'Ëë´Ëä¶',
                'Flush': 'ÂêåËä±',
                'Straight': 'È°∫Â≠ê',
                'Three of a Kind': '‰∏âÊù°',
                'Two Pair': '‰∏§ÂØπ',
                'One Pair': '‰∏ÄÂØπ',
                'High Card': 'È´òÁâå',
                'All others folded': 'ÂÖ∂‰ΩôÈÉΩÂºÉÁâå',
                'No active players': 'Êó†‰∫∫ÂèØÁî®'
            };
            return UI_LANG === 'zh' ? (map[d] || d) : d;
        }

        function translateActivity(msg) {
            if (UI_LANG !== 'zh') return String(msg || '');
            let out = String(msg || '');
            if (out.startsWith('[DBG]')) return out;
            if (out.startsWith('ERROR:')) return out;

            out = out.replace(/---\s*HAND\s+(\d+)\s*\/\s*(\d+)\s*---/i, (_m, a, b) => `--- Á¨¨${a}Â±Ä / ${b} ---`);
            out = out.replace(/---\s*HAND OVER\s+(\d+)\s*\/\s*(\d+)\s*:\s*(.*?)\s*\((.*?)\)\s*---/i,
                (_m, a, b, name, desc) => `--- Êú¨Â±ÄÁªìÊùü ${a}/${b}: ${name}Ôºà${trHandDesc(desc)}Ôºâ ---`);

            out = out.replace(/(.+?) posts SB \$(\d+)/i, (_m, name, amt) => `${name} ‰∏ãÂ∞èÁõ≤ $${amt}`);
            out = out.replace(/(.+?) posts BB \$(\d+)/i, (_m, name, amt) => `${name} ‰∏ãÂ§ßÁõ≤ $${amt}`);

            out = out.replace(/(.+?) Folds\./i, (_m, name) => `${name} ÂºÉÁâå„ÄÇ`);
            out = out.replace(/(.+?) Checks\./i, (_m, name) => `${name} ËøáÁâå„ÄÇ`);
            out = out.replace(/(.+?) Calls\./i, (_m, name) => `${name} Ë∑üÊ≥®„ÄÇ`);
            out = out.replace(/(.+?) Raises to (\d+)\./i, (_m, name, amt) => `${name} Âä†Ê≥®Âà∞ $${amt}„ÄÇ`);
            out = out.replace(/(.+?) ALL-IN to (\d+)\./i, (_m, name, amt) => `${name} ÂÖ®‰∏ãÂà∞ $${amt}„ÄÇ`);
            out = out.replace(/(.+?) is ALL-IN!/i, (_m, name) => `${name} ÂÖ®‰∏ãÔºÅ`);

            out = out.replace(/You Folded\./i, '‰Ω†ÂºÉÁâå„ÄÇ');
            out = out.replace(/You Checked\./i, '‰Ω†ËøáÁâå„ÄÇ');
            out = out.replace(/You Called \$(\d+)\./i, (_m, amt) => `‰Ω†Ë∑üÊ≥® $${amt}„ÄÇ`);
            out = out.replace(/You Raised \$(\d+) \(Total \$(\d+)\)\./i, (_m, inc, tot) => `‰Ω†Âä†Ê≥® $${inc}ÔºàÊÄªËÆ° $${tot}Ôºâ„ÄÇ`);
            out = out.replace(/You Bet \$(\d+)\./i, (_m, amt) => `‰Ω†‰∏ãÊ≥® $${amt}„ÄÇ`);
            out = out.replace(/YOU ALL-IN!!!/i, '‰Ω†ÂÖ®‰∏ãÔºÅÔºÅÔºÅ');

            out = out.replace(/Match over\./i, 'ÊØîËµõÁªìÊùü„ÄÇ');
            out = out.replace(/Game Over\.\s*(.+?) wins \(all others folded\)!/i, (_m, name) => `Ê∏∏ÊàèÁªìÊùü„ÄÇ${name} Ëé∑ËÉúÔºàÂÖ∂‰ΩôÈÉΩÂºÉÁâåÔºâÔºÅ`);
            out = out.replace(/Game Over\.\s*(.+?) wins with (.+?)!/i, (_m, name, desc) => `Ê∏∏ÊàèÁªìÊùü„ÄÇ${name} Ëé∑ËÉúÔºà${trHandDesc(desc)}ÔºâÔºÅ`);
            out = out.replace(/Game Over\.\s*\(No active players\)/i, 'Ê∏∏ÊàèÁªìÊùü„ÄÇÔºàÊó†‰∫∫ÂèØÁî®Ôºâ');

            // Rebuy
            out = out.replace(/Rebuy: \$(\d+) \(applies next hand\)/i, (_m, amt) => `Ë°•Á†ÅÔºö$${amt}Ôºà‰∏ã‰∏ÄÂ±ÄÁîüÊïàÔºâ`);
            return out;
        }

        function rerenderHistory() {
            const list = document.getElementById('history-list');
            if (!list) return;
            list.innerHTML = '';
            for (const raw of activityRaw) {
                const div = document.createElement('div');
                div.innerHTML = `<span style="color:#d4af37;opacity:0.5">></span> ${translateActivity(raw)}`;
                list.appendChild(div);
            }
        }

        function setGameMsg(round, actorName, potValue, isSpectator) {
            const el = document.getElementById('game-msg');
            if (!el) return;
            if (isSpectator) {
                el.innerText = `${trRound(round)}: ${t('spectator')}`;
                return;
            }
            const r = trRound(round);
            const who = actorName ? `${actorName} ${t('acting_label')}` : '';
            const pot = Number.isFinite(Number(potValue)) ? `${t('pot_label')}: ${Number(potValue)}` : '';
            const joiner = UI_LANG === 'zh' ? '  ' : ' ‚Ä¢ ';
            el.innerText = `${r}${who ? `: ${who}` : ''}${pot ? `${joiner}${pot}` : ''}`.trim();
        }

        function applyLanguageToUI() {
            // Lobby
            const lblName = document.getElementById('lbl-your-name');
            const lblRoom = document.getElementById('lbl-room-id');
            const lblInit = document.getElementById('lbl-init-chips');
            const lblRounds = document.getElementById('lbl-total-rounds');
            const btnLobbyNext = document.getElementById('lobby-next-btn');
            const btnLangLobby = document.getElementById('lang-toggle-lobby');
            if (lblName) lblName.innerText = t('lobby_your_name');
            if (lblRoom) lblRoom.innerText = t('lobby_room_id');
            if (lblInit) lblInit.innerText = t('lobby_init_chips');
            if (lblRounds) lblRounds.innerText = t('lobby_total_rounds');
            if (btnLobbyNext) btnLobbyNext.innerText = t('lobby_continue');
            if (btnLangLobby) btnLangLobby.innerText = t('lang_label_lobby');

            // Seat selection header
            const seatTitle = document.getElementById('seat-selection-title');
            if (seatTitle) seatTitle.innerText = t('seat_selection');

            // Decor panel (seat selection)
            try {
                const decorTitle = document.getElementById('decor-title');
                const decorHint = document.getElementById('decor-hint');
                const decorBtn = document.getElementById('decor-apply');
                const decorSel = document.getElementById('decor-select');
                if (decorTitle) decorTitle.innerText = t('decor_title');
                if (decorHint) decorHint.innerText = t('decor_hint');
                if (decorBtn) decorBtn.innerText = t('decor_apply');
                if (decorSel) {
                    const setOpt = (val, label) => {
                        const opt = decorSel.querySelector(`option[value="${val}"]`);
                        if (opt) opt.textContent = label;
                    };
                    setOpt('none', t('decor_none'));
                    setOpt('cola', t('decor_cola'));
                    setOpt('coffee', t('decor_coffee'));
                    setOpt('wine', t('decor_wine'));
                    setOpt('cigar', t('decor_cigar'));
                }
            } catch (_) {}

            // Activity panel collapse button
            try {
                const histBtn = document.getElementById('history-collapse');
                const histPanel = document.getElementById('history-panel');
                if (histBtn && histPanel) {
                    const collapsed = histPanel.classList.contains('collapsed');
                    histBtn.innerText = collapsed ? t('history_show') : t('history_hide');
                }
            } catch (_) {}

            // HUD panel collapse button (desktop + mobile)
            try {
                const hudBtn = document.getElementById('hud-collapse');
                const hud = document.getElementById('hud-panel');
                if (hudBtn && hud) {
                    const collapsed = hud.classList.contains('collapsed');
                    hudBtn.innerText = collapsed ? t('hud_show') : t('hud_hide');
                }
            } catch (_) {}

            // Rules button
            const rulesBtn = document.getElementById('rules-btn');
            if (rulesBtn) rulesBtn.innerText = t('rules');

            const resetBtn = document.getElementById('reset-view');
            if (resetBtn) resetBtn.innerText = t('reset_view');

            // In-game language button label (keeps old id)
            const langBtn = document.getElementById('lang-toggle');
            if (langBtn) langBtn.innerText = t('lang_label');

            // Theme button label
            const themeBtn = document.getElementById('theme-toggle');
            if (themeBtn) {
                const mode = document.documentElement.getAttribute('data-theme') || 'night';
                themeBtn.innerText = (mode === 'light') ? t('night_mode') : t('light_mode');
            }

            // Start/Next buttons (host dependent text is set elsewhere, but we normalize base labels)
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn && isHost) startBtn.innerText = t('start_game');

            const nextBtn = document.getElementById('btn-next');
            if (nextBtn && isHost) nextBtn.innerText = t('next_round');

            // Action buttons
            const foldBtn = document.getElementById('btn-fold');
            const allinBtn = document.getElementById('btn-allin');
            const rebuyBtn = document.getElementById('btn-rebuy');
            if (foldBtn) foldBtn.innerText = t('btn_fold');
            if (allinBtn) allinBtn.innerText = t('btn_allin');
            if (rebuyBtn) rebuyBtn.innerText = t('btn_rebuy');
            if (nextBtn) nextBtn.innerText = t('btn_confirm_next');

            // Seat grid (already rendered): update labels for empty/AI buttons
            try {
                for (let i = 0; i < CONFIG.numPlayers; i++) {
                    const statusEl = document.getElementById(`seat-status-${i}`);
                    const joinBtn = document.getElementById(`join-btn-${i}`);
                    const aiBtn = document.getElementById(`ai-btn-${i}`);
                    const kickBtn = document.getElementById(`kick-btn-${i}`);
                    const box = document.getElementById(`seat-box-${i}`);
                    if (box) {
                        const titleDiv = box.querySelector('div');
                        if (titleDiv && titleDiv.innerHTML.includes('üîë')) {
                            // keep HOST icon span; only rewrite the leading text
                            titleDiv.childNodes[0].textContent = `${t('seat_label')} ${i + 1} `;
                        } else if (titleDiv) {
                            titleDiv.textContent = `${t('seat_label')} ${i + 1}`;
                        }
                    }
                    if (joinBtn) joinBtn.innerText = t('seat_take');
                    if (kickBtn) kickBtn.innerText = t('seat_remove');
                    if (aiBtn) {
                        aiBtn.innerText = aiBtn.classList.contains('active') ? t('seat_remove_ai') : t('seat_add_ai');
                    }
                    if (statusEl) {
                        const v = String(statusEl.innerText || '');
                        if (v === 'Empty' || v === 'Á©∫‰Ωç') statusEl.innerText = t('seat_empty');
                    }
                }
            } catch (_) {}

            // Refresh game message + history to reflect current language
            try { rerenderHistory(); } catch (_) {}
            try {
                // multiplayer: gameState.round is synced from server
                if (IS_MULTIPLAYER) {
                    const activeName = gameState.players?.find(p => p.id === gameState.activeSeatIdx)?.name || '';
                    setGameMsg(gameState.round, activeName, gameState.pot, (mySeatIdx === -1));
                } else {
                    const p = gameState.players?.[gameState.activeIdx];
                    setGameMsg(gameState.round, p?.name || '', gameState.pot, false);
                }
            } catch (_) {}

            // Mobile: iconify utility buttons (top-left panel + corner panels)
            try { applyMobileIconButtons(); } catch (_) {}
        }

        function applyMobileIconButtons() {
            const isMobile = () => window.innerWidth <= 600;
            const hud = document.getElementById('hud-panel');
            const hudCollapsed = !!hud && hud.classList.contains('collapsed');
            const mobile = isMobile() || hudCollapsed;
            const setIconBtn = (id, icon, label) => {
                const el = document.getElementById(id);
                if (!el) return;
                if (mobile) {
                    el.classList.add('icon-btn');
                    el.setAttribute('data-icon', String(icon || '‚Ä¢'));
                    if (label) {
                        el.setAttribute('title', String(label));
                        el.setAttribute('aria-label', String(label));
                    }
                } else {
                    el.classList.remove('icon-btn');
                    el.removeAttribute('data-icon');
                    if (label) {
                        el.setAttribute('title', String(label));
                        el.setAttribute('aria-label', String(label));
                    }
                }
            };

            const mode = document.documentElement.getAttribute('data-theme') || 'night';
            const themeLabel = (mode === 'light') ? t('night_mode') : t('light_mode');
            const themeIcon = (mode === 'light') ? '‚òæ' : '‚òÄ';

            // Left panel buttons
            setIconBtn('rules-btn', '?', t('rules'));
            setIconBtn('reset-view', '‚ü≤', t('reset_view'));
            setIconBtn('theme-toggle', themeIcon, themeLabel);
            // Swap icons: music box vs sfx (user preference)
            setIconBtn('bgm-toggle', 'üîä', 'BGM');
            setIconBtn('sfx-toggle', '‚ô´', 'SFX');
            // Use stable text icon for language (some phones render üåê poorly / blank)
            setIconBtn('lang-toggle', (UI_LANG === 'zh') ? '‰∏≠' : 'EN', t('lang_label'));
            setIconBtn('lang-toggle-lobby', (UI_LANG === 'zh') ? '‰∏≠' : 'EN', t('lang_label_lobby'));
            setIconBtn('mic-toggle', 'üéô', 'Mic');
            // HUD collapse control (arrow)
            setIconBtn('hud-collapse', hudCollapsed ? '‚ñ∏' : '‚ñæ', hudCollapsed ? t('hud_show') : t('hud_hide'));

            // When HUD is collapsed, keep the buttons truly "small" so the row stays horizontal.
            try {
                const hb = document.getElementById('hud-buttons');
                if (hb) hb.style.flexWrap = hudCollapsed ? 'nowrap' : 'wrap';
            } catch (_) {}

            // Activity panel collapse
            try {
                const hp = document.getElementById('history-panel');
                const collapsed = !!hp && hp.classList.contains('collapsed');
                setIconBtn('history-collapse', collapsed ? '‚ñ∏' : '‚ñæ', collapsed ? t('history_show') : t('history_hide'));
            } catch (_) {}
        }

        // --- SFX (WebAudio, no external assets required) ---
        const SFX = (() => {
            let ctx = null;
            let enabled = (localStorage.getItem('nebula_sfx') || 'on') === 'on';
            let lastDealAt = 0;
            let lastChipAt = 0;
            let lastTurnAt = 0;
            let lastFoldAt = 0;
            let lastRattleAt = 0;

            const ensureCtx = async () => {
                if (!enabled) return null;
                if (!ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return null;
                    ctx = new AC();
                }
                if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch (_) {}
                }
                return ctx;
            };

            const noiseBuffer = () => {
                const c = ctx;
                const buffer = c.createBuffer(1, c.sampleRate * 0.12, c.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
                return buffer;
            };

            const playDeal = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastDealAt < 55) return; // throttle
                lastDealAt = tnow;
                const c = await ensureCtx();
                if (!c) return;

                const t = c.currentTime;
                const n = c.createBufferSource();
                n.buffer = noiseBuffer();
                const bp = c.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(1800, t);
                bp.Q.setValueAtTime(1.2, t);
                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.12, t + 0.005);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
                n.connect(bp).connect(g).connect(c.destination);
                n.start(t);
                n.stop(t + 0.11);
            };

            const clinkRaw = (t) => {
                // Coin/chip clink: short noise burst + resonant peaks (less "synthy")
                const c = ctx;
                const n = c.createBufferSource();
                n.buffer = noiseBuffer();

                const hp = c.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.setValueAtTime(1800 + Math.random() * 400, t);
                hp.Q.setValueAtTime(0.7, t);

                const bp = c.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(3200 + Math.random() * 600, t);
                bp.Q.setValueAtTime(7.5, t);

                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.16, t + 0.004);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.13);

                // add a tiny resonant "ping" partial
                const o = c.createOscillator();
                o.type = 'sine';
                const og = c.createGain();
                og.gain.setValueAtTime(0.0001, t);
                og.gain.exponentialRampToValueAtTime(0.06, t + 0.004);
                og.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
                o.frequency.setValueAtTime(4200 + Math.random() * 900, t);

                n.connect(hp).connect(bp).connect(g).connect(c.destination);
                o.connect(og).connect(c.destination);

                n.start(t);
                n.stop(t + 0.14);
                o.start(t);
                o.stop(t + 0.11);
            };

            const playChip = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastChipAt < 85) return; // throttle
                lastChipAt = tnow;
                const c = await ensureCtx();
                if (!c) return;

                clinkRaw(c.currentTime);
            };

            const playFold = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastFoldAt < 220) return;
                lastFoldAt = tnow;
                const c = await ensureCtx();
                if (!c) return;
                const t = c.currentTime;

                // "burn/vanish" whoosh: noise with sweeping lowpass and quick decay
                const n = c.createBufferSource();
                n.buffer = noiseBuffer();
                const lp = c.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.setValueAtTime(5200, t);
                lp.frequency.exponentialRampToValueAtTime(900, t + 0.18);
                lp.Q.setValueAtTime(0.9, t);
                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.11, t + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);
                n.connect(lp).connect(g).connect(c.destination);
                n.start(t);
                n.stop(t + 0.24);
            };

            const playRattle = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastRattleAt < 500) return;
                lastRattleAt = tnow;
                const c = await ensureCtx();
                if (!c) return;
                const t = c.currentTime;
                // multiple clinks in a short burst (pot pushed to winner)
                const hits = 7;
                for (let i = 0; i < hits; i++) {
                    const dt = 0.02 + i * (0.03 + Math.random() * 0.02);
                    try { clinkRaw(t + dt); } catch (_) {}
                }
            };

            const playTurn = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastTurnAt < 500) return;
                lastTurnAt = tnow;
                const c = await ensureCtx();
                if (!c) return;
                const t = c.currentTime;

                const o = c.createOscillator();
                o.type = 'sine';
                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);
                o.frequency.setValueAtTime(880, t);
                o.frequency.setValueAtTime(1175, t + 0.10);
                o.connect(g).connect(c.destination);
                o.start(t);
                o.stop(t + 0.24);
            };

            const setEnabled = (on) => {
                enabled = !!on;
                localStorage.setItem('nebula_sfx', enabled ? 'on' : 'off');
            };

            // Unlock on first gesture
            const unlock = () => { ensureCtx(); };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });

            return {
                isEnabled: () => enabled,
                setEnabled,
                ensureCtx,
                deal: playDeal,
                chip: playChip,
                turn: playTurn,
                fold: playFold,
                rattle: playRattle
            };
        })();

        function dbg(msg) {
            // Âè™Âú®Ë∞ÉËØïÈò∂ÊÆµ‰ΩøÁî®ÔºöÊääÂÖ≥ÈîÆÊé®ËøõÂÜôÂà∞ ACTIVITYÔºåÊñπ‰æø‰Ω†Êà™ÂõæÂèëÊàë
            try { addToHistory(`[DBG] ${msg}`); } catch(_) {}
        }

        // ---- Voice (WebRTC audio) ----
        const voiceState = {
            connected: false,
            micOn: false,
            localStream: null,
            peers: new Map(), // peerSocketId -> { pc, audioEl }
            audioContainer: null
        };

        function setVoiceStatus(text) {
            const el = document.getElementById('voice-status');
            if (el) el.innerText = text;
        }

        function updateMicButton() {
            const btn = document.getElementById('mic-toggle');
            if (!btn) return;
            btn.innerText = `Mic: ${voiceState.micOn ? 'On' : 'Off'}`;
            btn.style.opacity = voiceState.connected ? '1' : '0.8';
        }

        async function ensureLocalAudioStream() {
            if (voiceState.localStream) return voiceState.localStream;
            if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia not supported');
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                },
                video: false
            });
            // Default: join voice but start muted until user enables mic
            const track = stream.getAudioTracks()[0];
            if (track) track.enabled = false;
            voiceState.localStream = stream;

            if (!voiceState.audioContainer) {
                const c = document.createElement('div');
                c.id = 'voice-audio-container';
                c.style.display = 'none';
                document.body.appendChild(c);
                voiceState.audioContainer = c;
            }
            return stream;
        }

        function closePeer(peerId) {
            const entry = voiceState.peers.get(peerId);
            if (!entry) return;
            try { entry.pc.ontrack = null; entry.pc.onicecandidate = null; } catch(_) {}
            try { entry.pc.close(); } catch(_) {}
            try { entry.audioEl?.remove?.(); } catch(_) {}
            voiceState.peers.delete(peerId);
        }

        function shouldInitiateWith(peerId) {
            // Deterministic initiator to avoid offer glare
            const myId = socket?.id || '';
            if (!myId || !peerId) return false;
            return String(myId) < String(peerId);
        }

        async function ensurePeerConnection(peerId) {
            if (!IS_MULTIPLAYER || !socket) return null;
            if (!peerId || peerId === socket.id) return null;
            if (!voiceState.localStream) return null;
            if (voiceState.peers.has(peerId)) return voiceState.peers.get(peerId).pc;

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
            });

            // add local audio
            for (const t of voiceState.localStream.getTracks()) {
                pc.addTrack(t, voiceState.localStream);
            }

            const audioEl = document.createElement('audio');
            audioEl.autoplay = true;
            audioEl.playsInline = true;
            audioEl.muted = false;
            voiceState.audioContainer?.appendChild(audioEl);

            pc.ontrack = (ev) => {
                const [stream] = ev.streams;
                if (!stream) return;
                audioEl.srcObject = stream;
                // Some browsers require a gesture; we still try.
                audioEl.play?.().catch(() => {});
            };

            pc.onicecandidate = (ev) => {
                if (!ev.candidate) return;
                socket.emit('voice_signal', { to: peerId, data: { type: 'ice', candidate: ev.candidate } });
            };

            voiceState.peers.set(peerId, { pc, audioEl });

            // initiator sends offer
            if (shouldInitiateWith(peerId)) {
                const offer = await pc.createOffer({ offerToReceiveAudio: true });
                await pc.setLocalDescription(offer);
                socket.emit('voice_signal', { to: peerId, data: { type: 'offer', sdp: pc.localDescription } });
            }

            return pc;
        }

        async function handleVoiceSignal(from, data) {
            try {
                if (!from || from === socket?.id) return;
                if (!data || typeof data.type !== 'string') return;
                const pc = await ensurePeerConnection(from);
                if (!pc) return;

                if (data.type === 'offer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    const ans = await pc.createAnswer();
                    await pc.setLocalDescription(ans);
                    socket.emit('voice_signal', { to: from, data: { type: 'answer', sdp: pc.localDescription } });
                } else if (data.type === 'answer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                } else if (data.type === 'ice') {
                    if (data.candidate) {
                        try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch(_) {}
                    }
                }
            } catch (e) {
                console.warn('[voice] signal error', e);
            }
        }

        async function voiceJoinIfPossible() {
            if (!IS_MULTIPLAYER || !socket) return;
            if (voiceState.connected) return;
            if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) return; // must be seated
            try {
                await ensureLocalAudioStream();
                socket.emit('voice_join');
                voiceState.connected = true;
                setVoiceStatus('Voice: Connected (muted)');
                updateMicButton();
            } catch (e) {
                setVoiceStatus('Voice: Mic permission denied');
                console.warn('[voice] join failed', e);
            }
        }

        function voiceLeaveAndCleanup(stopTracks) {
            if (IS_MULTIPLAYER && socket && voiceState.connected) {
                try { socket.emit('voice_leave'); } catch(_) {}
            }
            for (const peerId of [...voiceState.peers.keys()]) closePeer(peerId);
            voiceState.connected = false;
            voiceState.micOn = false;
            if (stopTracks && voiceState.localStream) {
                try { voiceState.localStream.getTracks().forEach(t => t.stop()); } catch(_) {}
                voiceState.localStream = null;
            } else if (voiceState.localStream) {
                const tr = voiceState.localStream.getAudioTracks()[0];
                if (tr) tr.enabled = false;
            }
            setVoiceStatus('Voice: Not connected');
            updateMicButton();
        }
        
        const gameState = {
            players: [], pot: 0, dealerIdx: 0, deck: [],
            communityCards: [], round: 'WAITING', activeIdx: 0,
            currentMaxBet: 100, isGameOver: false,
            smallBlind: 50, bigBlind: 100,
            minRaise: 100,
            numActionThisRound: 0,
            currentRoundNum: 0,
            totalRounds: 5,
            initialChips: 1000,
            myPlayerIdx: -1,
            seatConfig: Array(10).fill(null), // null: Empty, 'player': YOU, 'ai': AI
            seatMeta: {}, // seatIdx -> { type, name } (multiplayer)
            isProcessing: false, // Âä®‰ΩúÈîÅÔºåÈò≤Ê≠¢Âø´ÈÄüÈáçÂ§çËß¶Âèë
            processingSince: 0,  // ËÆ∞ÂΩïÂä®‰ΩúÈîÅÂºÄÂßãÊó∂Èó¥ÔºåÁî®‰∫éwatchdogÂÖúÂ∫ï
            mpInitialized: false,
            mpHandNum: 0
        };

        // ËøîÂõû‰ªé startSeatIdx ÂºÄÂßãÔºåÂêëÂâçÊï∞ offset ‰∏™‚ÄúÊúâÊïàÁé©ÂÆ∂Â∫ß‰Ωç‚ÄùÁöÑ seatIdxÔºàÁî®‰∫é SB/BB/UTG Á≠âÔºâ
        // ÊúâÊïàÔºöseatConfig Êúâ‰∫∫ + ÂØπÂ∫î player Â≠òÂú® + Êú™Á†¥‰∫ß/‰ªçÊúâÁ≠πÁ†Å
        function getActiveOffset(startSeatIdx, offset) {
            const getSeatPlayer = (seatIdx) => gameState.players.find(p => p.id === seatIdx);
            const isSeatEligible = (seatIdx) => {
                if(!gameState.seatConfig[seatIdx]) return false;
                const p = getSeatPlayer(seatIdx);
                if(!p) return false;
                return !p.isBankrupt && p.chips > 0;
            };

            let count = 0;
            let idx = startSeatIdx;
            let loops = 0;
            const maxLoops = CONFIG.numPlayers * 3;
            while(count < offset && loops < maxLoops) {
                idx = (idx + 1) % CONFIG.numPlayers;
                if(isSeatEligible(idx)) count++;
                loops++;
            }
            return idx;
        }

        // ÂÖ®Â±ÄÈîôËØØÊçïËé∑ÔºöÂ¶ÇÊûúÊüê‰∏™ AI Âä®‰ΩúÊäõÂºÇÂ∏∏ÂØºËá¥ÈÄªËæë‰∏≠Êñ≠ÔºåËøôÈáå‰ºöÊääÂéüÂõ†ÊâìÂà∞ÊéßÂà∂Âè∞ + ACTIVITY
        window.addEventListener('error', (e) => {
            try {
                console.error('[GLOBAL ERROR]', e?.error || e);
                addToHistory(`ERROR: ${e?.message || 'Unknown error'}`);
                gameState.isProcessing = false;
            } catch(_) {}
        });
        window.addEventListener('unhandledrejection', (e) => {
            try {
                console.error('[UNHANDLED REJECTION]', e?.reason || e);
                addToHistory(`ERROR: ${e?.reason?.message || e?.reason || 'Unhandled rejection'}`);
                gameState.isProcessing = false;
            } catch(_) {}
        });

        function init() {
            setupBase();
            setupLights();
            setupAtmosphere();
            createTable();
            // ‰∏çÂÜçÁõ¥Êé•Ë∞ÉÁî® createPlayersÔºåÁî±ÈÄâÂ∫ßÊµÅÁ®ãÊéßÂà∂
            setupEvents();
            try { applyLanguageToUI(); } catch (_) {}
            // È°µÈù¢Âè≥‰∏ãËßíÊòæÁ§∫ build tagÔºåÁ°ÆËÆ§‰Ω†Âä†ËΩΩÁöÑÊòØÊúÄÊñ∞Êñá‰ª∂
            const buildEl = document.createElement('div');
            buildEl.id = 'build-tag';
            buildEl.style.cssText = 'position:fixed;right:10px;bottom:10px;z-index:9999;font:12px/1.2 monospace;color:rgba(255,215,0,0.7);pointer-events:none;';
            buildEl.textContent = BUILD_TAG;
            document.body.appendChild(buildEl);

            // ÂÖ®Â±Ä watchdogÔºö‰∏ç‰æùËµñ checkTurn Ë¢´Ë∞ÉÁî®„ÄÇÂè™Ë¶ÅÈîÅ‰ΩèÂ§™‰πÖÔºåËá™Âä®Ëß£ÈîÅÂπ∂Êé®Ëøõ‰∏ÄÊ¨°„ÄÇ
            setInterval(() => {
                if (gameState.isGameOver) return;
                if (gameState.round === 'WAITING') return;
                if (gameState.isProcessing && (Date.now() - (gameState.processingSince || 0) > 3000)) {
                    console.warn('[WATCHDOG_INTERVAL] Force unlock + nextStep');
                    dbg('watchdog unlock');
                    gameState.isProcessing = false;
                    gameState.processingSince = 0;
                    try { nextStep(); } catch(e) { console.error('[WATCHDOG nextStep error]', e); }
                }
            }, 500);
            animate();
        }

        function wireMultiplayer() {
            if(!IS_MULTIPLAYER) return;
            if (mpWired) return;
            mpWired = true;

            // voice: handle reconnects cleanly
            socket.on('connect', () => {
                // on reconnect, socket.id changes; drop old peer state and rejoin
                try { voiceLeaveAndCleanup(false); } catch(_) {}
                voiceJoinIfPossible();
            });
            socket.on('disconnect', () => {
                try { voiceLeaveAndCleanup(false); } catch(_) {}
                setVoiceStatus('Voice: Disconnected');
            });

            socket.on('you_state', ({ seatIdx, isHost: hostFlag }) => {
                if (Number.isInteger(seatIdx) && seatIdx >= 0) {
                    mySeatIdx = seatIdx;
                    gameState.myPlayerIdx = seatIdx;
                    voiceJoinIfPossible();
                }
                if (hostFlag !== null && hostFlag !== undefined) {
                    isHost = !!hostFlag;
                }
            });

            socket.on('seat_taken', ({ seatIdx }) => {
                mySeatIdx = seatIdx;
                gameState.myPlayerIdx = seatIdx;
                voiceJoinIfPossible();
            });

            socket.on('room_state', (state) => {
                lastRoomState = state;
                joinedRoomOnce = true;
                pendingJoin = false;
                // ÊúçÂä°Âô®ÂπøÊí≠Êó∂ isHost ÂèØËÉΩ‰∏∫ nullÔºõËøôÈáåÁî® hostSocketId vs ÂΩìÂâç socket.id Ëá™Ë°åËÆ°ÁÆó
                isHost = (state.isHost !== null && state.isHost !== undefined)
                    ? !!state.isHost
                    : (!!state.hostSocketId && !!socket?.id && state.hostSocketId === socket.id);

                // seat meta (names/types) from server
                gameState.seatMeta = {};
                (state.seats || []).forEach(s => {
                    if(!s) return;
                    gameState.seatMeta[s.seatIdx] = { type: s.type, name: s.name, decor: s.decor || 'none' };
                });
            // If already at table, update decor meshes live
            try {
                if (gameState.mpInitialized && Array.isArray(gameState.players)) {
                    gameState.players.forEach(p => {
                        const meta = gameState.seatMeta?.[p.id];
                        const nextDecor = meta?.decor || 'none';
                        if (p.decorType !== nextDecor) {
                            p.decorType = nextDecor;
                            updatePlayerDecorMesh(p);
                        }
                    });
                }
            } catch (_) {}

                // ÂêåÊ≠•ËÅîÊú∫ËÆæÁΩÆÔºàinitial chips / total handsÔºâ
                if (state.settings) {
                    if (Number.isFinite(state.settings.initialChips)) gameState.initialChips = state.settings.initialChips;
                    if (Number.isFinite(state.settings.totalHands)) gameState.totalRounds = state.settings.totalHands;
                }
                // ÂêåÊ≠• seats Âà∞Êú¨Âú∞ seatConfigÔºöplayer/ai/null
                gameState.seatConfig = Array(CONFIG.numPlayers).fill(null);
                (state.seats || []).forEach(s => {
                    if(!s) return;
                    gameState.seatConfig[s.seatIdx] = (s.type === 'ai') ? 'ai' : 'player';
                });
                updateSeatOverlayFromServer(state);

                // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂè™Ë¶ÅÊúçÂä°Âô®ËØ¥ started=trueÔºåÊâÄÊúâÂÆ¢Êà∑Á´ØÈÉΩË¶ÅËøõÂÖ•ÁâåÊ°åÔºà‰∏çÂè™ÊòØ hostÔºâ
                if (state.started) {
                    enterMultiplayerGame();
                }
                try { window.__updateDecorPanel?.(); } catch (_) {}
            });

            socket.on('activity', (msg) => addToHistory(msg));
            socket.on('activity_sync', ({ items }) => {
                try {
                    const arr = Array.isArray(items) ? items : [];
                    // keep newest-first like addToHistory()
                    activityRaw.length = 0;
                    for (let i = 0; i < arr.length; i++) activityRaw.unshift(String(arr[i]));
                    rerenderHistory();
                } catch (_) {}
            });
            socket.on('error_msg', ({msg}) => {
                alert(msg);
                // If we failed to join (e.g. room already started), return to lobby instead of getting stuck on seat screen.
                if (pendingJoin && !joinedRoomOnce) {
                    pendingJoin = false;
                    const lobby = document.getElementById('lobby-overlay');
                    const seat = document.getElementById('seat-overlay');
                    if (seat) seat.style.display = 'none';
                    if (lobby) lobby.style.display = 'flex';
                }
            });
            socket.on('room_closed', ({ roomId, reason }) => {
                // Room released after match over: return everyone to a clean lobby state.
                try { voiceLeaveAndCleanup(true); } catch(_) {}
                try { addToHistory(`Room ${roomId} closed (${reason}). Returning to lobby...`); } catch(_) {}
                setTimeout(() => location.reload(), 300);
            });
            socket.on('kicked', ({ seatIdx }) => {
                addToHistory(`You were removed from Seat ${Number(seatIdx) + 1} by host.`);
                if (mySeatIdx === seatIdx) {
                    mySeatIdx = -1;
                    gameState.myPlayerIdx = -1;
                    try { voiceLeaveAndCleanup(false); } catch(_) {}
                }
                // ËÆ© UI Á´ãÂàªÂõûÂà∞ÂèØÈÄâÂ∫ßÁä∂ÊÄÅÔºàserver ‰ºöÈöèÂêéÂπøÊí≠ room_stateÔºâ
                document.getElementById('seat-overlay').style.display = 'block';
                document.getElementById('seat-overlay').style.opacity = '1';
            });
            socket.on('kicked_in_hand', ({ seatIdx, msg }) => {
                addToHistory(msg || `You were removed from this hand by host (Seat ${Number(seatIdx) + 1}).`);
                // You stay in room; you can play again next hand.
            });

            // Rebuy flow (host approves)
            socket.on('rebuy_requested', ({ seatIdx, name, amount }) => {
                addToHistory(`${name || 'Player'} requests REBUY $${Number(amount || 0)} (Seat ${Number(seatIdx) + 1}).`);
                if (!isHost) return;
                const ok = confirm(`Rebuy request:\n\n${name || 'Player'} (Seat ${Number(seatIdx) + 1}) wants to rebuy $${Number(amount || 0)}.\n\nApprove?`);
                if (ok) {
                    try { socket.emit('rebuy_approve', { seatIdx, amount }); } catch(_) {}
                } else {
                    try { socket.emit('rebuy_deny', { seatIdx, amount }); } catch(_) {}
                }
            });
            socket.on('rebuy_denied', ({ msg }) => {
                alert(msg || 'Rebuy denied by host.');
            });

            // voice wiring
            socket.on('voice_peers', async ({ peers }) => {
                try {
                    if (!Array.isArray(peers)) return;
                    setVoiceStatus(`Voice: Connected (${peers.length} peer${peers.length === 1 ? '' : 's'})${voiceState.micOn ? '' : ' (muted)'}`);
                    for (const p of peers) {
                        if (!p?.socketId) continue;
                        await ensurePeerConnection(p.socketId);
                    }
                } catch (e) {
                    console.warn('[voice] peers error', e);
                }
            });
            socket.on('voice_peer_joined', async ({ peer }) => {
                try {
                    if (!peer?.socketId) return;
                    await ensurePeerConnection(peer.socketId);
                } catch (e) {
                    console.warn('[voice] peer joined error', e);
                }
            });
            socket.on('voice_peer_left', ({ socketId }) => {
                if (!socketId) return;
                closePeer(socketId);
            });
            socket.on('voice_signal', ({ from, data }) => {
                handleVoiceSignal(from, data);
            });

            socket.on('player_action', ({ seatIdx, text }) => {
                showPlayerActionBadge(seatIdx, text);
                // Multiplayer fold effect: disintegrate the folded player's cards
                if (String(text || '').toUpperCase().startsWith('FOLD')) {
                    const p = gameState.players.find(pp => pp.id === seatIdx);
                    if (p && !p._foldFxPlayed && (p.meshCards?.length || 0) > 0) {
                        p._foldFxPlayed = true;
                        createFoldParticles(p);
                    }
                }
                // Multiplayer chips "give" FX: when someone CALL/RAISE/ALL-IN, fly gold chips to pot
                animateBetToPot(seatIdx, text);
            });

            socket.on('hand_over', ({ handNum, totalHands, winners, desc, showdownHands }) => {
                // show a next-hand prompt
                const winNames = (winners || []).map(w => w.name).join(' & ');
                addToHistory(`--- HAND OVER ${handNum}/${totalHands}: ${winNames || 'N/A'} (${desc || ''}) ---`);

                // Pot -> winner chip push animation (multiplayer FX)
                try { animatePotToWinners(winners || []); } catch(_) {}

                // Reveal showdown hands (players who stayed to the end)
                try {
                    if (Array.isArray(showdownHands)) {
                        showdownHands.forEach(s => {
                            const seatIdx = s?.seatIdx;
                            const hand = Array.isArray(s?.hand) ? s.hand.slice(0, 2) : [];
                            if (!Number.isInteger(seatIdx) || hand.length < 2) return;
                            const p = gameState.players.find(pp => pp.id === seatIdx);
                            if (!p) return;
                            // Update stored hand
                            p.hand = hand.slice(0, 2);
                            // Reveal existing placeholder cards if present
                            if (Array.isArray(p.meshCards) && p.meshCards.length >= 2) {
                                revealCardOnMesh(p.meshCards[0], hand[0]);
                                revealCardOnMesh(p.meshCards[1], hand[1]);
                            }
                        });
                    }
                } catch (_) {}

                const btn = document.getElementById('btn-next');
                document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
                btn.style.display = 'block';
                btn.innerText = isHost ? 'Next Round' : 'Waiting for Host';
                btn.disabled = !isHost;
                lastHandOverNum = handNum;
            });

            socket.on('match_over', ({ totalHands, scheduledHands, playedHands, standings, hands }) => {
                matchOverReceived = true;

                // Show final results (all hands + final chip standings)
                const modal = document.getElementById('summary-modal');
                const title = modal?.querySelector?.('h2');
                if (title) title.innerText = 'MATCH OVER';

                const list = document.getElementById('summary-list-content');
                if (list) {
                    const safeStandings = Array.isArray(standings) ? standings : [];
                    const safeHands = Array.isArray(hands) ? hands : [];
                    list.innerHTML = "";

                    const sec1 = document.createElement('div');
                    sec1.style.cssText = 'text-align:left;margin-bottom:14px;color:rgba(212,175,55,0.8);font-weight:bold;';
                    sec1.innerText = t('final_standings');
                    list.appendChild(sec1);

                    safeStandings.forEach((p, idx) => {
                        const div = document.createElement('div');
                        div.className = 'summary-item';
                        const buyIn = Number.isFinite(Number(p.buyInTotal)) ? Number(p.buyInTotal)
                                    : (Number.isFinite(Number(p.buyIn)) ? Number(p.buyIn)
                                    : (Number.isFinite(Number(p.totalBuyIn)) ? Number(p.totalBuyIn) : 0));
                        const net = Number.isFinite(Number(p.net)) ? Number(p.net) : (Number(p.chips || 0) - buyIn);
                        const netColor = net >= 0 ? '#00ff88' : '#ff6677';
                        const netWord = net >= 0 ? t('win') : t('loss');
                        div.innerHTML = `
                            <span style="color:#fff;flex:1;">${idx + 1}. ${p.name || 'Player'} (ID:${p.seatIdx})</span>
                            <span style="min-width:140px; text-align:right; opacity:0.9;">${t('buy_in')} $${buyIn}</span>
                            <span style="min-width:140px; text-align:right;"><b>${t('chips')} $${Number(p.chips || 0)}</b></span>
                            <span style="min-width:140px; text-align:right; color:${netColor}; font-weight:bold;">${netWord} $${Math.abs(net)}</span>
                        `;
                        list.appendChild(div);
                    });

                    const spacer = document.createElement('div');
                    spacer.style.height = '14px';
                    list.appendChild(spacer);

                    const sec2 = document.createElement('div');
                    sec2.style.cssText = 'text-align:left;margin-bottom:10px;color:rgba(212,175,55,0.8);font-weight:bold;';
                    const sched = Number.isFinite(Number(scheduledHands)) ? Number(scheduledHands) : Number(totalHands || safeHands.length);
                    const played = Number.isFinite(Number(playedHands)) ? Number(playedHands) : safeHands.length;
                    sec2.innerText = `${t('hand_results')} (${played}/${sched})`;
                    list.appendChild(sec2);

                    safeHands.sort((a,b) => (a.handNum||0)-(b.handNum||0)).forEach(h => {
                        const winners = Array.isArray(h.winners) ? h.winners : [];
                        const winNames = winners.map(w => w.name).join(' & ') || 'N/A';
                        const row = document.createElement('div');
                        row.style.cssText = 'text-align:left; font-size: 0.9em; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.06);';
                        const handLabel = (UI_LANG === 'zh') ? `Á¨¨${h.handNum || ''}Â±Ä:` : `Hand ${h.handNum || ''}:`;
                        const desc = (UI_LANG === 'zh') ? trHandDesc(h.desc || '') : (h.desc || '');
                        row.innerHTML = `<span style="color:#fff;opacity:0.9;">${handLabel}</span> <span style="color:gold;">${winNames}</span> <span style="opacity:0.75;">(${desc})</span>`;
                        list.appendChild(row);
                    });
                }

                // Disable game controls and show summary
                document.querySelectorAll('#controls button').forEach(b => b.disabled = true);
                if (modal) modal.style.display = 'block';
                setVoiceStatus('Voice: Connected'); // keep voice; users can still talk during summary

                // Manual confirm: only when user clicks do we ACK + leave (disconnect counts as offline)
                const confirmBtn = document.getElementById('summary-confirm-btn');
                if (confirmBtn) {
                    confirmBtn.onclick = () => {
                        if (IS_MULTIPLAYER && socket && !matchOverAcked) {
                            matchOverAcked = true;
                            try { socket.emit('ack_match_over'); } catch(_) {}
                            try { voiceLeaveAndCleanup(true); } catch(_) {}
                            try { socket.disconnect(); } catch(_) {}
                        }
                        // Return to main/lobby
                        try { location.reload(); } catch(_) {}
                    };
                }
            });

            socket.on('private_hand', ({ seatIdx, hand }) => {
                // Âè™‰ºöÂèëÁªôËá™Â∑±Ôºõ‰ΩÜÂèØËÉΩÊØî createPlayers Êõ¥Êó©Âà∞ËææÔºåÂÖàÁºìÂ≠ò
                const safeHand = Array.isArray(hand) ? hand.slice(0, 2) : [];
                pendingPrivateHands.set(seatIdx, safeHand);
                applyPrivateHandIfReady(seatIdx);
            });

            socket.on('game_state', (s) => {
                // Your-turn beep: detect transition into "my turn" (avoid repeat beeps)
                const wasMyTurn = !!gameState._myTurn;
                // ÊúçÂä°Âô®ÂºÄÂêØÂêéÔºåÁ°Æ‰øùÊâÄÊúâ‰∫∫ÈÉΩËøõÂÖ•ÁâåÊ°å
                if (s.started) {
                    enterMultiplayerGame();
                }
                if (s.settings) {
                    if (Number.isFinite(s.settings.initialChips)) gameState.initialChips = s.settings.initialChips;
                    if (Number.isFinite(s.settings.totalHands)) gameState.totalRounds = s.settings.totalHands;
                }
                // Âè™ÂÅö UI/Ê∏≤ÊüìÂêåÊ≠•ÔºàÈÄªËæë‰ª•ÊúçÂä°Á´Ø‰∏∫ÂáÜÔºâ
                gameState.round = s.round;
                gameState.pot = s.pot;
                gameState.currentMaxBet = s.currentMaxBet;
                if (Number.isFinite(s.minRaise)) {
                    gameState.minRaise = s.minRaise;
                    if (currentRaiseInput < gameState.minRaise) currentRaiseInput = gameState.minRaise;
                }
                const activeName = (s.activeSeatIdx !== null && s.activeSeatIdx !== undefined)
                    ? (s.players.find(p=>p.seatIdx===s.activeSeatIdx)?.name || '...')
                    : '';
                setGameMsg(s.round, activeName, s.pot, (IS_MULTIPLAYER && mySeatIdx === -1));
                // ÊéßÂà∂Âå∫ÊòæÁ§∫ÈÄªËæëÔºàËÅîÊú∫ÔºâÔºöHAND_OVER ÊâçÊòæÁ§∫ Next RoundÔºõÂê¶ÂàôÊòæÁ§∫Â∏∏ËßÑÊåâÈíÆÂπ∂Ê†πÊçÆ activeSeatIdx ÂºÄÂÖ≥
                const btnNext = document.getElementById('btn-next');
                const btnCheck = document.getElementById('btn-check');
                const btnRebuy = document.getElementById('btn-rebuy');
                if (s.round === 'HAND_OVER') {
                    document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
                    btnNext.style.display = 'block';
                    btnNext.innerText = isHost ? t('next_round') : t('waiting_host');
                    btnNext.disabled = !isHost;
                    toggleButtons(false);
                } else {
                    btnNext.style.display = 'none';
                    document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'block');
                    if (s.activeSeatIdx !== null && s.activeSeatIdx !== undefined) {
                        toggleButtons(s.activeSeatIdx === mySeatIdx);
                    } else {
                        toggleButtons(false);
                    }
                }
                try {
                    const nowMyTurn = (s.activeSeatIdx === mySeatIdx) && (s.round !== 'HAND_OVER') && (s.round !== 'WAITING');
                    gameState._myTurn = nowMyTurn;
                    if (!wasMyTurn && nowMyTurn) {
                        SFX.turn();
                    }
                } catch (_) {}

                // PokerNow-like: show exact Check/Call amount
                try {
                    const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                    const maxBet = Number(s.currentMaxBet || 0);
                    const myBet = meS ? Number(meS.currentBet || 0) : 0;
                    const myChips = meS ? Number(meS.chips || 0) : 0;
                    const toCall = meS ? Math.max(0, maxBet - myBet) : 0;
                    const callPay = Math.max(0, Math.min(toCall, myChips));
                    if (btnCheck) {
                        btnCheck.innerText = (toCall > 0)
                            ? `Call $${callPay}${(myChips > 0 && myChips < toCall) ? ' (All-in)' : ''}`
                            : 'Check';
                        btnCheck.style.display = 'block';
                    }
                    const btnRaise = document.getElementById('btn-raise');
                    if (btnRaise) {
                        if (toCall > 0) {
                            btnRaise.innerText = `Raise +$${Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0))}`;
                        } else {
                            const betAmt = Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0) || 0);
                            btnRaise.innerText = `Bet $${betAmt}`;
                        }
                    }
                } catch (_) {}

                // Rebuy button: only for seated players who are busted, between hands
                try {
                    if (btnRebuy) {
                        const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                        const busted = !!meS && Number(meS.chips || 0) <= 0;
                        const betweenHands = (s.round === 'HAND_OVER' || s.round === 'WAITING');
                        btnRebuy.style.display = (IS_MULTIPLAYER && busted && betweenHands && !matchOverReceived) ? 'block' : 'none';
                        btnRebuy.disabled = !(IS_MULTIPLAYER && busted && betweenHands);
                    }
                } catch (_) {}

                // Auto prompt: if you are busted between hands, ask whether to rebuy and rejoin next hand
                try {
                    if (IS_MULTIPLAYER && !matchOverReceived) {
                        const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                        const busted = !!meS && Number(meS.chips || 0) <= 0;
                        const betweenHands = (s.round === 'HAND_OVER' || s.round === 'WAITING');
                        const handKey = `${s.handNum || 0}:${s.round || ''}`;
                        if (busted && betweenHands && rebuyPromptedForHand !== handKey) {
                            rebuyPromptedForHand = handKey;
                            setTimeout(() => {
                                const ok = confirm('You are out of chips.\n\nRebuy to re-enter next hand?');
                                if (!ok) return;
                                const def = Number.isFinite(Number(gameState.initialChips)) ? Number(gameState.initialChips) : 1000;
                                const raw = prompt('Rebuy amount (>=1000 and multiple of 50):', String(def));
                                if (raw === null) return;
                                const amt = Number(raw);
                                if (!Number.isFinite(amt) || amt < 1000 || (amt % 50) !== 0) {
                                    alert('Rebuy amount must be >=1000 and a multiple of 50.');
                                    return;
                                }
                                try { socket.emit('rebuy', { amount: amt }); } catch(_) {}
                                addToHistory(`Rebuy: $${amt} (applies next hand)`);
                            }, 50);
                        }
                    }
                } catch (_) {}
                // ÂêåÊ≠•Áé©ÂÆ∂Á≠πÁ†Å/ÂºÉÁâå
                (s.players || []).forEach(sp => {
                    const p = gameState.players.find(pp => pp.id === sp.seatIdx);
                    if(!p) return;
                    p.chips = sp.chips;
                    p.currentBet = sp.currentBet;
                    p.isFolded = sp.isFolded;
                    p.isBankrupt = sp.isBankrupt;
                });
                updateUI();

                // SB/BB badges
                try {
                    const sb = s.sbSeatIdx;
                    const bb = s.bbSeatIdx;
                    gameState.players.forEach(pp => {
                        const el = document.getElementById(`blind-${pp.id}`);
                        if (!el) return;
                        if (Number.isInteger(sb) && pp.id === sb) {
                            el.innerText = 'SB';
                            el.style.display = 'inline-block';
                        } else if (Number.isInteger(bb) && pp.id === bb) {
                            el.innerText = 'BB';
                            el.style.display = 'inline-block';
                        } else {
                            el.style.display = 'none';
                        }
                    });
                } catch (_) {}

                // Êñ∞ÁöÑ‰∏ÄÊâãÔºöÂÖàÊ∏ÖÁêÜÊóßÊ°åÈù¢ÔºåÂÜçÊ∏≤ÊüìÊú¨ÊâãÁöÑÂÖ¨ÂÖ±Áâå/ÊâãÁâåÂç†‰Ωç
                if (gameState.mpHandNum !== s.handNum) {
                    gameState.mpHandNum = s.handNum;
                    lastHandOverNum = null;
                    // Ê∏ÖÁ©∫Ê°åÈù¢Áâå‰∏é‰∏ãÊ≥®Á≠πÁ†Å
                    while(cardsGroup.children.length > 0) cardsGroup.remove(cardsGroup.children[0]);
                    while(chipsGroup.children.length > 0) chipsGroup.remove(chipsGroup.children[0]);
                    potChipFX = [];
                    gameState.communityCards = [];
                    // Ê∏ÖÊéâÊØè‰ΩçÁé©ÂÆ∂ÊâãÁâå meshÔºàËá™Â∑±ÁöÑÁâå‰ºöÈÄöËøá private_hand ÈáçÂèëÔºâ
                    gameState.players.forEach(p => {
                        (p.meshCards || []).forEach(m => cardsGroup.remove(m));
                        p.meshCards = [];
                        p.hand = [];
                        p.currentBet = 0;
                        p._foldFxPlayed = false;
                    });

                    // ÁªôÂÖ∂‰ªñÁé©ÂÆ∂Âèë‰∏§Âº†ËÉåÈù¢Âç†‰ΩçÁâåÔºà‰ªÖÂú®ÊàëÂ∑≤Á°ÆÂÆöÂ∫ß‰ΩçÂêéÔºâ
                    if (mySeatIdx !== -1) dealOpponentPlaceholders(s.handNum);

                    // Â¶ÇÊûúÊàëÁöÑÁßÅÁâåÂ∑≤ÁªèÁºìÂ≠òÂà∞‰∫ÜÔºåÁé∞Âú®Â∫îÁî®
                    if (mySeatIdx !== -1) applyPrivateHandIfReady(mySeatIdx);
                }

                // ÂêåÊ≠•ÂÖ¨ÂÖ±ÁâåÔºöÂè™Ë°•Â∑ÆÈáèÔºàÊúÄÂ§ö 5 Âº†ÔºâÔºåÈÄêÂº†‚ÄúÁøªÂá∫‚ÄùÂä®ÁîªÔºàÂÖàËÉåÈù¢ËêΩ‰∏ã -> ÁøªÊ≠£Èù¢Ôºâ
                const target = Array.isArray(s.communityCards) ? s.communityCards.slice(0, 5) : [];
                while(gameState.communityCards.length < target.length) {
                    const card = target[gameState.communityCards.length];
                    gameState.communityCards.push(card);
                    const finalX = (gameState.communityCards.length-3)*0.9;
                    // start facedown, then flip reveal
                    const mesh = createCardMesh(card, false);
                    mesh.position.set(finalX, 5, 0);
                    cardsGroup.add(mesh);
                    // community cards: keep flat (no tilt toward player)
                    mesh.rotation.order = 'YXZ';
                    mesh.rotation.set(0, 0, 0);
                    try { SFX.deal(); } catch (_) {}
                    // float above felt (no "on felt" placement)
                    gsap.to(mesh.position, { y: 0.18, duration: 0.55, ease: "power2.out" });
                    // flip after landing
                    setTimeout(() => {
                        try {
                            revealCardOnMesh(mesh, card);
                            mesh.rotation.order = 'YXZ';
                            mesh.rotation.set(0, 0, 0);
                        } catch (_) {}
                    }, 420);
                }
            });

            socket.on('turn', ({ activeSeatIdx }) => {
                // ËΩÆÂà∞ÊàëÂàôÂºÄÊåâÈíÆÔºåÂê¶ÂàôÂÖ≥
                toggleButtons(activeSeatIdx === mySeatIdx);
            });
        }

        function enterMultiplayerGame() {
            // Âè™ÂàùÂßãÂåñ‰∏ÄÊ¨°
            if (gameState.mpInitialized) {
                // ÈöêËóèÈÄâÂ∫ßÂ±ÇÔºåÈÅøÂÖçÊå°‰ΩèÁâåÊ°å
                const seatOverlay = document.getElementById('seat-overlay');
                if (seatOverlay) seatOverlay.style.display = 'none';
                return;
            }
            // ËøõÂÖ•ÁâåÊ°åÔºöÈöêËóèÈÄâÂ∫ßÂ±Ç + ÂàõÂª∫Áé©ÂÆ∂
            const seatOverlay = document.getElementById('seat-overlay');
            if (seatOverlay) seatOverlay.style.display = 'none';

            // Â¶ÇÊûúËøòÊ≤°ÂàõÂª∫ËøáÁé©ÂÆ∂ÔºåÂÖàÂàõÂª∫
            createPlayers();
            gameState.mpInitialized = true;

            // ËøõÂÖ•ÂêéÂ¶ÇÊûúÊàëÁöÑÁßÅÁâåÂ∑≤ÁºìÂ≠òÔºåÁ´ãÂàªÊ∏≤Êüì
            if (mySeatIdx !== -1) applyPrivateHandIfReady(mySeatIdx);
        }

        function applyPrivateHandIfReady(seatIdx) {
            const hand = pendingPrivateHands.get(seatIdx);
            if (!hand) return;
            const me = gameState.players.find(p => p.id === seatIdx);
            if(!me) return;

            // cancel any in-flight render for this seat
            const token = (privateHandRenderToken.get(seatIdx) || 0) + 1;
            privateHandRenderToken.set(seatIdx, token);

            // Ê∏ÖÊéâËÉåÈù¢Âç†‰ΩçÁâå
            (me.meshCards || []).forEach(m => cardsGroup.remove(m));
            me.meshCards = [];
            me.hand = [];

            // È°∫Â∫èÂèë‰∏§Âº†Ê≠£Èù¢ÁâåÔºàÁ°Æ‰øù hand.length Áî®‰∫éÊâáÂΩ¢ÂÅèÁßªÔºâ
            const safeHand = Array.isArray(hand) ? hand.slice(0, 2) : [];
            (async () => {
                for (const card of safeHand) {
                    // if a newer render started, stop this one
                    if (privateHandRenderToken.get(seatIdx) !== token) return;
                    me.hand.push(card);
                    // eslint-disable-next-line no-await-in-loop
                    await dealCardAnim(card, me, true);
                    // slow down slightly for premium feel (multiplayer)
                    if (IS_MULTIPLAYER) await new Promise(r => setTimeout(r, 140));
                }
            })();
        }

        async function dealOpponentPlaceholders(handNum) {
            // cancel any in-flight placeholder dealing
            const token = (opponentPlaceholderToken || 0) + 1;
            opponentPlaceholderToken = token;

            // avoid re-dealing placeholders multiple times for the same hand
            if (Number.isFinite(Number(handNum)) && lastOpponentPlaceholderHandNum === handNum) return;
            lastOpponentPlaceholderHandNum = Number.isFinite(Number(handNum)) ? handNum : lastOpponentPlaceholderHandNum;

            gameState.players.forEach((p) => {
                if (p.id === mySeatIdx) return;
                // Á°Æ‰øùÊØè‰∏™ÂØπÊâãÂè™Êúâ‰∏§Âº†ËÉåÈù¢Âç†‰ΩçÁâå
                p.hand = [];
                (p.meshCards || []).forEach(m => cardsGroup.remove(m));
                p.meshCards = [];
            });
            // È°∫Â∫èÂèëÁâåÔºàÈÅøÂÖç‚Äú‰∏ÄÁû¨Èó¥ÂÖ®ÂèëÂÆå‚ÄùÁöÑÊÑüËßâÔºâ
            for (const p of gameState.players) {
                if (p.id === mySeatIdx) continue;
                // ËæìÂÖâ/Á†¥‰∫ßÁöÑÁé©ÂÆ∂‰∏çÂèëÁâåÔºàÁ¨¶Âêà‚Äú‰∏ã‰∏ÄÊää‰∏çÁªô‰ªñÂèëÁâå‚ÄùÁöÑËßÇÊÑüÔºâ
                if (Number(p.chips || 0) <= 0 || p.isBankrupt) continue;
                for (let k = 0; k < 2; k++) {
                    if (opponentPlaceholderToken !== token) return;
                    const dummy = { s: 'spades', r: 'A', v: 12 }; // ÊØèÂº†ÈÉΩÁî®Áã¨Á´ãÂØπË±°
                    p.hand.push(dummy);
                    // eslint-disable-next-line no-await-in-loop
                    await dealCardAnim(dummy, p, false);
                    // if a newer placeholder render started, cleanup the last mesh we just added
                    if (opponentPlaceholderToken !== token) {
                        try {
                            const last = (p.meshCards || []).pop();
                            if (last) cardsGroup.remove(last);
                        } catch(_) {}
                        return;
                    }
                    // eslint-disable-next-line no-await-in-loop
                    if (IS_MULTIPLAYER) await new Promise(r => setTimeout(r, 120));
                }
            }
        }

        function showPlayerActionBadge(seatIdx, text) {
            // Âè™ÊòæÁ§∫‰∏ä‰∏ÄÂÆ∂Âä®‰ΩúÔºöÊñ∞Âä®‰ΩúÊù•Êó∂Ê∏ÖÊéâÊóßÁöÑ
            if (lastActionSeatIdx !== null && lastActionSeatIdx !== undefined) {
                const old = document.getElementById(`action-${lastActionSeatIdx}`);
                if (old) old.style.display = 'none';
            }
            lastActionSeatIdx = seatIdx;
            const el = document.getElementById(`action-${seatIdx}`);
            if (!el) return;
            el.innerText = text;
            el.style.display = 'block';
        }

        function animateBetToPot(seatIdx, text) {
            if (!IS_MULTIPLAYER) return;
            const upper = String(text || '').toUpperCase();
            if (!(upper.startsWith('CALL') || upper.startsWith('RAISE') || upper.startsWith('ALL-IN'))) return;

            const p = gameState.players.find(pp => pp.id === seatIdx);
            if (!p || !p.pos) return;

            try { SFX.chip(); } catch (_) {}

            // parse amount (optional)
            const m = String(text || '').match(/(\d+)/);
            const amt = m ? Number(m[1]) : 50;
            const chipCount = Math.max(1, Math.min(6, Math.floor((Number.isFinite(amt) ? amt : 50) / 50)));

            for (let i = 0; i < chipCount; i++) {
                const stackIndex = potChipFX.length;
                const perLayer = 14;
                const layer = Math.floor(stackIndex / perLayer);
                const within = stackIndex % perLayer;
                const stackY = 0.05 + layer * 0.006 + within * 0.00018; // physical-ish stacking; avoids z-fighting

                const chip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                    getChipMaterial().clone()
                );
                // During flight: allow slight translucency, but disable depthWrite to avoid sorting shimmer.
                chip.material.transparent = true;
                chip.material.opacity = 0.7;
                chip.material.depthWrite = false;
                chip.position.set(p.pos.x, 0.08, p.pos.z);
                // ËÆ©Á≠πÁ†Å‚ÄúÂπ≥Ë∫∫‚ÄùÂú®Ê°åÈù¢ÔºàÂíåÁ¶ªÁ∫ø‰∏ÄËá¥ÔºâÔºöCylinder ÈªòËÆ§Â∞±ÊòØÂπ≥Ë∫∫ÔºàÂúÜÈù¢Êúù‰∏äÔºâ
                // keep label oriented to that seat (+90deg correction for cap UV)
                chip.rotation.set(0, (p.angle || 0) + Math.PI / 2, 0);
                chipsGroup.add(chip);
                potChipFX.push(chip);

                const tx = (Math.random() - 0.5) * 0.8;
                const tz = (Math.random() - 0.5) * 0.8;
                gsap.to(chip.position, {
                    x: tx,
                    z: tz,
                    y: stackY,
                    duration: 0.65 + Math.random() * 0.15,
                    ease: "power2.out",
                    onComplete: () => {
                        // Once in pot: make it opaque & depthWrite=true to avoid heavy overlap flicker.
                        try {
                            chip.material.transparent = false;
                            chip.material.opacity = 1.0;
                            chip.material.depthWrite = true;
                            chip.material.needsUpdate = true;
                        } catch (_) {}
                    }
                });
                gsap.to(chip.material, {
                    opacity: 0.55,
                    duration: 0.65,
                    ease: "power1.out"
                });
            }
        }

        function animatePotToWinners(winners) {
            if (!IS_MULTIPLAYER) return;
            if (!Array.isArray(winners) || winners.length === 0) return;
            if (!potChipFX || potChipFX.length === 0) return;

            try { SFX.rattle(); } catch (_) {}

            const winnerSeats = winners.map(w => w.seatIdx).filter(s => Number.isInteger(s));
            if (winnerSeats.length === 0) return;

            // move existing pot FX chips to winners (split)
            potChipFX.forEach((chip, i) => {
                const seatIdx = winnerSeats[i % winnerSeats.length];
                const p = gameState.players.find(pp => pp.id === seatIdx);
                if (!p) return;
                const wx = p.pos.x + (Math.random() - 0.5) * 0.7;
                const wz = p.pos.z + (Math.random() - 0.5) * 0.7;
                // fading chips: use transparent + depthWrite=false (prevents shimmer while overlapping)
                try {
                    chip.material.transparent = true;
                    chip.material.depthWrite = false;
                } catch (_) {}
                gsap.to(chip.position, {
                    x: wx,
                    z: wz,
                    y: 0.05,
                    duration: 1.0,
                    ease: "power2.inOut"
                });
                gsap.to(chip.material, {
                    opacity: 0.0,
                    duration: 1.05,
                    ease: "power1.inOut",
                    onComplete: () => {
                        try { chipsGroup.remove(chip); } catch(_) {}
                    }
                });
            });

            // clear list after animation window
            setTimeout(() => { potChipFX = []; }, 1200);
        }

        function setupBase() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x080401);
            scene.fog = new THREE.FogExp2(0x080401, 0.02);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(DEFAULT_VIEW.cameraPos);
            camera.lookAt(0, 0, 0);
            // alpha:true so light-mode can show the CSS casino background behind the 3D scene
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            // Ensure correct color output for materials (glass especially)
            try {
                if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;
                else if ('outputEncoding' in renderer && THREE.sRGBEncoding) renderer.outputEncoding = THREE.sRGBEncoding;
            } catch (_) {}
            renderer.setClearColor(0x000000, 1);
            document.getElementById('container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            try { controls.target.copy(DEFAULT_VIEW.target); } catch (_) {}
            cardsGroup = new THREE.Group();
            chipsGroup = new THREE.Group();
            tableGroup = new THREE.Group();
            environmentGroup = new THREE.Group();
            playerStacksGroup = new THREE.Group();
            scene.add(cardsGroup, chipsGroup, tableGroup, environmentGroup, playerStacksGroup);

            // Add a subtle procedural environment for natural reflections (improves glass sheen).
            try {
                if (!scene.environment && THREE.PMREMGenerator) {
                    const envCanvas = document.createElement('canvas');
                    envCanvas.width = 512; envCanvas.height = 256;
                    const ec = envCanvas.getContext('2d');
                    // sky gradient
                    const g = ec.createLinearGradient(0, 0, 0, 256);
                    g.addColorStop(0, '#0a0b10');
                    g.addColorStop(0.35, '#1b1f2a');
                    g.addColorStop(0.7, '#2a2a2a');
                    g.addColorStop(1, '#6a5b3f');
                    ec.fillStyle = g;
                    ec.fillRect(0, 0, 512, 256);
                    // soft bright bands (studio lights)
                    ec.globalAlpha = 0.18;
                    ec.fillStyle = '#ffffff';
                    ec.fillRect(70, 30, 110, 20);
                    ec.fillRect(300, 55, 150, 28);
                    ec.fillRect(120, 110, 280, 18);
                    ec.globalAlpha = 0.10;
                    ec.fillRect(0, 170, 512, 36);
                    ec.globalAlpha = 1;

                    const envTex = new THREE.CanvasTexture(envCanvas);
                    try {
                        if ('colorSpace' in envTex && THREE.SRGBColorSpace) envTex.colorSpace = THREE.SRGBColorSpace;
                    } catch (_) {}
                    envTex.mapping = THREE.EquirectangularReflectionMapping;
                    envTex.needsUpdate = true;

                    const pmrem = new THREE.PMREMGenerator(renderer);
                    pmrem.compileEquirectangularShader();
                    const envRT = pmrem.fromEquirectangular(envTex);
                    scene.environment = envRT.texture;
                    try { envTex.dispose(); } catch (_) {}
                    try { pmrem.dispose(); } catch (_) {}
                }
            } catch (_) {}
        }

        function setupLights() {
            // Âü∫Á°ÄÊöóÂÖâ
            scene.add(new THREE.AmbientLight(0xffffff, 0.05));
            
            // Âº∫ÂäõÂûÇÁõ¥ÁôΩËâ≤ËÅöÂÖâÁÅØ - ‰∫ßÁîüÈ´òÁ∫ßÊÑüÂèçÂÖâ
            whiteSpot = new THREE.SpotLight(0xffffff, 100);
            whiteSpot.position.set(0, 12, 0);
            whiteSpot.angle = Math.PI / 6;
            whiteSpot.penumbra = 0.65;
            whiteSpot.decay = 1.35;
            whiteSpot.distance = 60;
            // Êõ¥ÊüîÂíå„ÄÅÂûÇÁõ¥ËêΩÂú®Ê°åÈù¢‰∏≠ÂøÉÔºàÈÅøÂÖç‚ÄúÊ≠™ÁöÑ/ÈªëÊñë‚ÄùËßÇÊÑüÔºâ
            whiteSpot.target.position.set(0, 0, 0);
            scene.add(whiteSpot.target);
            scene.add(whiteSpot);
            
            // ËæÖÂä©ÁÇπÂÖâÊ∫êÂ¢ûÂä†‰∏≠ÂøÉÈ´òÂÖâ
            rimLight = new THREE.PointLight(0xffffff, 10, 10);
            rimLight.position.set(0, 5, 0);
            scene.add(rimLight);

            // initial adapt for default table size
            updateTableLights(7.0);
        }

        function updateTableLights(tableRadius) {
            // Make spotlight cover the full table regardless of radius (3-10 players)
            if (!whiteSpot) return;
            const r = Math.max(3.5, Math.min(9.0, Number(tableRadius || 7.0)));

            // Choose a height that keeps the cone wide enough without blowing out the center
            const h = Math.max(9.5, r * 2.05);
            whiteSpot.position.set(0, h, 0);
            whiteSpot.target.position.set(0, 0, 0);

            // Cover slightly beyond table edge so rim stays lit
            const cover = r * 1.25;
            const ang = Math.atan2(cover, h); // half-angle needed
            whiteSpot.angle = Math.max(0.28, Math.min(1.05, ang));

            // Distance: far enough to include the full cone + a bit
            whiteSpot.distance = Math.max(30, h * 4.0);
            whiteSpot.penumbra = 0.7;

            // Intensity scaling: bigger tables need more light, but keep it stable
            const base = 75;
            const scale = (r / 7.0);
            whiteSpot.intensity = base * (0.85 + 0.35 * scale);

            // Gentle fill near center so cards/chips read well
            if (rimLight) {
                rimLight.position.set(0, Math.max(3.8, h * 0.42), 0);
                rimLight.distance = Math.max(10, r * 3.2);
                rimLight.intensity = 7.5 * (0.9 + 0.3 * scale);
            }
        }

        function setupAtmosphere() {
            // Â§úÈó¥Êõ¥Ê¢¶ÂπªÔºö‰∏§Â±ÇÊòüÊµ∑ÔºàË∂ÖÁªÜÂØÜ + ‰∫ÆÁÇπÁºÄÔºâ
            const group = new THREE.Group();

            const colorPaleGold = new THREE.Color(0xd4af37).convertSRGBToLinear();
            const colorSoftWhite = new THREE.Color(0xfffdf0).convertSRGBToLinear();

            // Layer A: very fine dense stars
            {
                const count = 26000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                    const r = 14 + Math.random() * 46;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i*3+2] = r * Math.cos(phi);

                    const c = colorPaleGold.clone().lerp(colorSoftWhite, Math.random() * 0.45);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.065,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.55,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                group.add(new THREE.Points(geo, mat));
            }

            // Layer B: brighter sparkle accents
            {
                const count = 4200;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                for(let i=0; i<count; i++) {
                    const r = 12 + Math.random() * 42;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i*3+2] = r * Math.cos(phi);

                    const c = colorSoftWhite.clone().lerp(colorPaleGold, Math.random() * 0.25);
                    colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.14,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.22,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                group.add(new THREE.Points(geo, mat));
            }

            starField = group;
            environmentGroup.add(starField);
        }

        function getDynamicTableRadius(numActive) {
            const n = Math.max(3, Math.min(10, Number(numActive || 10)));
            // 3‰∫∫Êõ¥Á¥ßÂáëÔºå10‰∫∫Êõ¥ÂÆΩÊùæÔºàÁ∫øÊÄßÊèíÂÄºÔºâ
            const t = (n - 3) / (10 - 3);
            return 5.6 + t * (7.0 - 5.6);
        }

        function rebuildTable(radius) {
            // clear old table geometry
            while (tableGroup.children.length > 0) tableGroup.remove(tableGroup.children[0]);
            tableParticles = null;
            createTable(radius);
            try { updateTableLights(radius); } catch (_) {}
        }

        function createTable(radiusOverride) {
            // ÂÖ∑ÊúâÂéöÂ∫¶ÁöÑÂÆû‰ΩìÈáëÂ±ûÁâåÊ°å + ÁªøËâ≤Â∫ïÈù¢
            const radius = Number.isFinite(Number(radiusOverride)) ? Number(radiusOverride) : 7.0;
            const thickness = 0.8;
            
            // 1. Ê°åÈù¢‰∏ª‰Ωì (ÈáëÂ±ûËæπÊ°Ü/‰æßÈù¢)
            const tableGeo = new THREE.CylinderGeometry(radius, radius, thickness, 64);
            const tableMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                metalness: 1.0,
                roughness: 0.1,
                envMapIntensity: 1.5
            });
            const tableMesh = new THREE.Mesh(tableGeo, tableMat);
            tableMesh.position.y = -thickness / 2;
            tableGroup.add(tableMesh);

            // 1.5 Ê°åËæπ‚ÄúÂµåÂÖ•ÂºèÁÅØÂ∏¶‚ÄùÔºöÁî®Ë¥¥ÂêàÊ°åÈù¢ÁöÑÂèëÂÖâ Ring Êù•Ê®°Êãü‚ÄúÂµåÂú®Ê°åÂ≠êÈáåÁöÑÁÅØÊßΩ‚ÄùÔºåÈÅøÂÖç‰∏éÁ≠πÁ†ÅÁ©øÊ®°
            const grooveOuter = radius * 0.965;
            const grooveInner = radius * 0.92;
            const groove = new THREE.Mesh(
                new THREE.RingGeometry(grooveInner, grooveOuter, 128),
                new THREE.MeshStandardMaterial({
                    color: 0x101010,
                    emissive: 0xffe0a6,
                    emissiveIntensity: 1.25,
                    roughness: 0.65,
                    metalness: 0.05,
                    transparent: true,
                    opacity: 0.62,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: -2,
                    polygonOffsetUnits: -2
                })
            );
            groove.rotation.x = -Math.PI / 2;
            groove.position.y = 0.002; // slightly recessed
            tableGroup.add(groove);

            // dark lip above the groove to sell "embedded" look
            const lip = new THREE.Mesh(
                new THREE.RingGeometry(radius * 0.90, grooveInner, 128),
                new THREE.MeshStandardMaterial({
                    color: 0x070707,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: -1
                })
            );
            lip.rotation.x = -Math.PI / 2;
            lip.position.y = 0.006;
            tableGroup.add(lip);

            // 2. Ê°åÈù¢‰∏≠ÂøÉÁöÑÁªøËâ≤‰∏ùÁªíÂ∫ï
            const feltGeo = new THREE.CircleGeometry(radius * 0.95, 64);
            const feltMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a2a0a, // Ê∑±ÁªøËâ≤
                roughness: 0.8,
                metalness: 0.2,
                emissive: 0x051505, // ÂæÆÂæÆÂèëÁªøÂÖâ
                emissiveIntensity: 0.5
            });
            const felt = new THREE.Mesh(feltGeo, feltMat);
            felt.rotation.x = -Math.PI/2;
            felt.position.y = 0.005; // Áï•È´ò‰∫éÈáëÂ±ûÊ°åÈù¢
            tableGroup.add(felt);

            // 3. Ë£ÖÈ•∞Á≤íÂ≠ê
            const particleCount = 8000;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount; i++) {
                const r = Math.sqrt(Math.random()) * radius;
                const angle = Math.random() * Math.PI * 2;
                pPos[i*3] = Math.cos(angle) * r;
                pPos[i*3+1] = 0.02;
                pPos[i*3+2] = Math.sin(angle) * r;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xd4af37, size: 0.015, transparent: true, opacity: 0.25 });
            tableParticles = new THREE.Points(pGeo, pMat);
            tableGroup.add(tableParticles);
        }

        function createPlayers() {
            const container = document.getElementById('labels-container');
            gameState.players = [];
            hudData = []; // Ê∏ÖÁ©∫ HUD
            while(container.firstChild) container.removeChild(container.firstChild);
            while(playerStacksGroup.children.length > 0) playerStacksGroup.remove(playerStacksGroup.children[0]);

            // 1. ËøáÊª§Âá∫Ë¢´Âç†Áî®ÁöÑÂ∫ß‰ΩçÔºå‰øùÊåÅÂéüÊú¨ÁöÑÁâ©ÁêÜÈ°∫Â∫è
            const occupied = [];
            for (let i = 0; i < CONFIG.numPlayers; i++) {
                if (gameState.seatConfig[i]) {
                    const meta = gameState.seatMeta?.[i];
                    const type = gameState.seatConfig[i];
                    const name = meta?.name || (type === 'ai' ? `AI-${i}` : `Player-${i}`);
                    occupied.push({ seatIdx: i, type, name });
                }
            }

            const totalActive = occupied.length;
            if (totalActive === 0) return;

            // Ê†πÊçÆ‰∫∫Êï∞Âä®ÊÄÅË∞ÉÊï¥Ê°åÂ≠ê/Âõ¥ÂùêÂçäÂæÑÔºå‰øùËØÅÂ∞ë‰∫∫Êó∂Êõ¥Á¥ßÂáë„ÄÅÊõ¥ÊòìÁúãÊ∏ÖÁâåÊ°å
            const tableRadius = getDynamicTableRadius(totalActive);
            const seatRadius = Math.max(4.4, tableRadius - 1.1);
            try { rebuildTable(tableRadius); } catch (_) {}

            // 2. ÊâæÂà∞‚ÄúÊàë‚ÄùÂú®Ë¢´Âç†Áî®Â∫ß‰Ωç‰∏≠ÁöÑÈ°∫Â∫èÁ¥¢Âºï
            let myOrderIdx = occupied.findIndex(s => s.seatIdx === gameState.myPlayerIdx);
            if (myOrderIdx < 0) myOrderIdx = 0;

            // 3. Ê†πÊçÆÊ¥ªË∑É‰∫∫Êï∞ÂùáÂåÄÂàÜÈÖçËßíÂ∫¶ÔºåÂπ∂‰ª•‚ÄúÊàë‚Äù‰∏∫‰∏≠ÂøÉ
            occupied.forEach((seat, orderIdx) => {
                const meta = gameState.seatMeta?.[seat.seatIdx];
                const relativeIdx = (orderIdx - myOrderIdx + totalActive) % totalActive;
                const visualAngle = (relativeIdx / totalActive) * Math.PI * 2;
                const pos = new THREE.Vector3(Math.sin(visualAngle) * seatRadius, 0.05, Math.cos(visualAngle) * seatRadius);
                
                const stackGroup = new THREE.Group();
                stackGroup.position.copy(pos);
                stackGroup.position.add(new THREE.Vector3(Math.sin(visualAngle)*0.85, 0, Math.cos(visualAngle)*0.85));
                playerStacksGroup.add(stackGroup);

                let pName = seat.name || (seat.type === 'ai' ? `AI-${seat.seatIdx}` : `Player-${seat.seatIdx}`);
                if (seat.type === 'player' && seat.seatIdx === gameState.myPlayerIdx) pName = "YOU";
                let pChips = gameState.initialChips;

                const decorType = (meta && meta.decor) ? meta.decor : (seatDecor[seat.seatIdx] || 'none');
                const playerObj = { 
                    id: seat.seatIdx, // ÈÄªËæë‰∏äÁöÑÂ∫ß‰ΩçID
                    name: pName, 
                    chips: pChips, currentBet: 0, pos: pos, 
                    angle: visualAngle, hand: [], isFolded: false, 
                    meshCards: [], stackGroup: stackGroup,
                    isBankrupt: false,
                    isAI: seat.type === 'ai',
                    decorType,
                    decorMesh: null
                };
                gameState.players.push(playerObj);
                
                const hud = document.createElement('div');
                hud.className = 'player-hud';
                // Âú® HUD ‰∏≠ÊòæÁ§∫Áé©ÂÆ∂ ID ÂíåÂêçÂ≠ó
                hud.innerHTML = `
                    <div style="font-size: 10px; opacity: 0.6; color: gold;">ID: ${seat.seatIdx}</div>
                    <div style="color: white; font-weight: bold; display:flex; align-items:center; justify-content:center; gap:6px;">
                        <span>${pName}</span>
                        <span id="blind-${seat.seatIdx}" style="display:none; font-size:10px; font-weight:900; padding:2px 6px; border-radius:10px; border:1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.35); color:#fff; letter-spacing:0.5px;">BB</span>
                    </div>
                    <div id="chips-${seat.seatIdx}" class="chip-display">$${pChips}</div>
                    <div id="action-${seat.seatIdx}" style="display:none; margin-top:6px; text-align:center; font-size:11px; color:#d4af37; letter-spacing:1px;">ACTION</div>
                `;
                container.appendChild(hud);
                hudData.push({ el: hud, pos: pos.clone().add(new THREE.Vector3(0, 1.5, 0)), seatIdx: seat.seatIdx });
                
                updatePlayerStackMesh(playerObj);
                updatePlayerDecorMesh(playerObj);
            });
        }

        function updatePlayerStackMesh(player) {
            const group = player.stackGroup;
            // Avoid flicker: only rebuild stack meshes when chip count actually changed
            if (player._lastStackChips === player.chips) return;
            player._lastStackChips = player.chips;
            while(group.children.length > 0) group.remove(group.children[0]);
            
            let totalChipCount = Math.floor(player.chips / CONFIG.chipValue);
            if (player.chips > 0 && totalChipCount === 0) totalChipCount = 1;
            
            const maxPerStack = 10;
            const numStacks = Math.ceil(totalChipCount / maxPerStack);
            
            let remaining = totalChipCount;
            for(let s=0; s<numStacks; s++) {
                const countInStack = Math.min(remaining, maxPerStack);
                remaining -= countInStack;

                const stackOffset = (s - (numStacks-1)/2) * 0.45;
                const ox = Math.cos(player.angle) * stackOffset;
                const oz = -Math.sin(player.angle) * stackOffset;
                
                for(let j=0; j<countInStack; j++) {
                    const chipGroup = new THREE.Group();
                    // slight physical jitter to avoid z-fighting shimmer while keeping stacked look
                    const jx = (Math.random() - 0.5) * 0.012;
                    const jz = (Math.random() - 0.5) * 0.012;
                    chipGroup.position.set(ox + jx, j * 0.055, oz + jz);
                    // Orient chip label ("50") to face the seat direction.
                    // Note: top-face UV on Cylinder caps is rotated vs world axes, so we add a +90deg correction.
                    chipGroup.rotation.y = player.angle + Math.PI / 2;
                    
                    // Bright solid chip with texture (PokerNow-like readability)
                    const chipBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                        getChipMaterial()
                    );
                    chipGroup.add(chipBody);
                    
                    group.add(chipGroup);
                }
            }
        }

        function createDecorMesh(type) {
            const t = String(type || 'none').toLowerCase();
            if (t === 'none') return null;
            const g = new THREE.Group();

            if (t === 'cola') {
                // Short, wide transparent glass filled with dark cola, bubbles, ice, condensation,
                // lemon slice + metal straw + red logo sticker.

                // Glass material
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    roughness: 0.08,
                    metalness: 0.0,
                    transmission: 1.0,
                    thickness: 0.14,
                    ior: 1.45,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false
                });

                // Glass body (tumbler)
                const cupOuter = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.14, 0.20, 32), glassMat);
                cupOuter.position.y = 0.10;
                g.add(cupOuter);
                const rim = new THREE.Mesh(new THREE.TorusGeometry(0.158, 0.008, 12, 32), glassMat);
                rim.rotation.x = Math.PI / 2;
                rim.position.y = 0.20;
                g.add(rim);

                // Cola liquid
                const colaMat = new THREE.MeshStandardMaterial({
                    color: 0x2a140a,
                    roughness: 0.35,
                    metalness: 0.05,
                    transparent: true,
                    opacity: 0.90
                });
                const cola = new THREE.Mesh(new THREE.CylinderGeometry(0.145, 0.13, 0.17, 28), colaMat);
                cola.position.y = 0.095;
                g.add(cola);

                // Bubbles (small spheres inside top)
                const bubbleMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.22, roughness: 0.1, metalness: 0.0, depthWrite: false });
                for (let i = 0; i < 18; i++) {
                    const br = 0.010 + Math.random() * 0.008;
                    const b = new THREE.Mesh(new THREE.SphereGeometry(br, 10, 8), bubbleMat);
                    // Keep bubbles INSIDE the LIQUID volume at their Y (and away from walls)
                    // cola mesh is CylinderGeometry(top=0.145, bottom=0.13, height=0.17) centered at y=0.095
                    const colaBottomY = 0.095 - 0.17 / 2; // 0.01
                    const y = 0.128 + Math.random() * 0.040; // a touch deeper to avoid wall intersection near rim
                    const tt = Math.min(1, Math.max(0, (y - colaBottomY) / 0.17));
                    const radiusAtY = (0.13 * (1 - tt)) + (0.145 * tt);
                    const margin = 0.028; // extra safety margin to prevent visible wall intersection
                    const maxR = Math.max(0.02, radiusAtY - br - margin);
                    const r = Math.random() * maxR;
                    const a = Math.random() * Math.PI * 2;
                    b.position.set(Math.cos(a) * r, y, Math.sin(a) * r);
                    g.add(b);
                }

                // Ice cubes
                const iceMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.35, roughness: 0.15, metalness: 0.0, depthWrite: false });
                for (let i = 0; i < 4; i++) {
                    const ice = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.06), iceMat);
                    ice.position.set((Math.random() - 0.5) * 0.12, 0.12 + Math.random() * 0.03, (Math.random() - 0.5) * 0.12);
                    ice.rotation.set(Math.random() * 0.6, Math.random() * 0.6, Math.random() * 0.6);
                    g.add(ice);
                }

                // Condensation droplets (tiny beads on outer wall)
                const dropMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.28, roughness: 0.12, metalness: 0.0, depthWrite: false });
                for (let i = 0; i < 26; i++) {
                    const d = new THREE.Mesh(new THREE.SphereGeometry(0.008 + Math.random() * 0.006, 10, 8), dropMat);
                    const a = Math.random() * Math.PI * 2;
                    const rr = 0.158 + (Math.random() * 0.006);
                    d.position.set(Math.cos(a) * rr, 0.06 + Math.random() * 0.12, Math.sin(a) * rr);
                    g.add(d);
                }

                // Lemon slice (ring + disc w/ segment texture)
                const lemonOuter = new THREE.MeshStandardMaterial({ color: 0xffe06a, roughness: 0.55, metalness: 0.0 });
                const lemonCanvas = document.createElement('canvas');
                lemonCanvas.width = 256; lemonCanvas.height = 256;
                const lx = lemonCanvas.getContext('2d');
                lx.clearRect(0, 0, 256, 256);
                // base
                const lgrad = lx.createRadialGradient(128, 128, 10, 128, 128, 120);
                lgrad.addColorStop(0, '#fff9cf');
                lgrad.addColorStop(0.65, '#fff1a6');
                lgrad.addColorStop(1, '#ffd86a');
                lx.fillStyle = lgrad;
                lx.beginPath(); lx.arc(128, 128, 120, 0, Math.PI * 2); lx.fill();
                // segment lines
                lx.strokeStyle = 'rgba(255, 220, 120, 0.9)';
                lx.lineWidth = 4;
                for (let i = 0; i < 10; i++) {
                    const ang = (i / 10) * Math.PI * 2;
                    lx.beginPath();
                    lx.moveTo(128, 128);
                    lx.lineTo(128 + Math.cos(ang) * 118, 128 + Math.sin(ang) * 118);
                    lx.stroke();
                }
                // center pith
                lx.fillStyle = 'rgba(255,255,255,0.65)';
                lx.beginPath(); lx.arc(128, 128, 18, 0, Math.PI * 2); lx.fill();
                const lemonTex = new THREE.CanvasTexture(lemonCanvas);
                const lemonInner = new THREE.MeshStandardMaterial({ map: lemonTex, roughness: 0.75, metalness: 0.0, transparent: true, opacity: 0.98 });
                const lemon = new THREE.Group();
                // Thinner peel ring
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.006, 10, 20), lemonOuter);
                ring.rotation.x = Math.PI / 2;
                lemon.add(ring);
                // Larger inner flesh so the slice doesn't look hollow
                const disc = new THREE.Mesh(new THREE.CircleGeometry(0.046, 22), lemonInner);
                disc.rotation.x = -Math.PI / 2;
                disc.position.y = 0.001;
                lemon.add(disc);
                lemon.position.set(0.10, 0.205, 0.02);
                lemon.rotation.z = -Math.PI / 7;
                g.add(lemon);

                // Metal straw
                const metal = new THREE.MeshStandardMaterial({ color: 0xb8c4cf, roughness: 0.22, metalness: 0.95 });
                const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.012, 0.26, 16), metal);
                straw.position.set(0.03, 0.27, 0.02);
                straw.rotation.z = Math.PI / 14;
                g.add(straw);

                // Red logo sticker on the side (simple texture)
                const logoCanvas = document.createElement('canvas');
                logoCanvas.width = 256; logoCanvas.height = 128;
                const lc = logoCanvas.getContext('2d');
                lc.fillStyle = '#d40018';
                lc.fillRect(0, 0, logoCanvas.width, logoCanvas.height);
                lc.strokeStyle = 'rgba(255,255,255,0.55)';
                lc.lineWidth = 6;
                lc.strokeRect(6, 6, logoCanvas.width - 12, logoCanvas.height - 12);
                lc.fillStyle = '#ffffff';
                lc.font = 'bold 44px Arial';
                lc.textAlign = 'center';
                lc.textBaseline = 'middle';
                lc.fillText('CocaCola', 128, 66);
                const logoTex = new THREE.CanvasTexture(logoCanvas);
                const sticker = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.16, 0.08),
                    new THREE.MeshBasicMaterial({ map: logoTex, transparent: true })
                );
                sticker.name = 'colaSticker';
                // Initial position; will be re-positioned to the seat-facing side in updatePlayerDecorMesh()
                sticker.position.set(-0.155, 0.11, 0.0);
                g.add(sticker);
            } else if (t === 'coffee') {
                // Takeaway cappuccino cup (Starbucks-like): no handle, no saucer; add paper heat sleeve.
                const paperCup = new THREE.MeshStandardMaterial({
                    color: 0xf3f0ea,
                    roughness: 0.92,
                    metalness: 0.0
                });
                const paperInner = new THREE.MeshStandardMaterial({
                    color: 0xe9e2d8,
                    roughness: 0.95,
                    metalness: 0.0
                });
                // Cup walls (hollow) - taller takeaway cup
                const cupH = 0.22;
                const cupY = 0.14;
                const cupOuter = new THREE.Mesh(new THREE.CylinderGeometry(0.115, 0.09, cupH, 28, 1, true), paperCup);
                cupOuter.position.y = cupY;
                g.add(cupOuter);
                const cupInnerMat = paperInner.clone();
                cupInnerMat.side = THREE.BackSide;
                const cupInner = new THREE.Mesh(new THREE.CylinderGeometry(0.105, 0.082, cupH - 0.01, 28, 1, true), cupInnerMat);
                cupInner.position.y = cupY;
                g.add(cupInner);
                const cupBottom = new THREE.Mesh(new THREE.CircleGeometry(0.085, 26), paperInner);
                cupBottom.rotation.x = -Math.PI / 2;
                cupBottom.position.y = (cupY - cupH / 2) + 0.01;
                g.add(cupBottom);
                const cupLip = new THREE.Mesh(new THREE.TorusGeometry(0.112, 0.006, 10, 30), paperInner);
                cupLip.rotation.x = Math.PI / 2;
                cupLip.position.y = cupY + cupH / 2;
                g.add(cupLip);

                // Paper heat sleeve (kraft w/ ribbing + subtle logo)
                const sleeveCanvas = document.createElement('canvas');
                sleeveCanvas.width = 512; sleeveCanvas.height = 256;
                const sc = sleeveCanvas.getContext('2d');
                sc.fillStyle = '#b98a55';
                sc.fillRect(0, 0, 512, 256);
                // ribbing
                sc.globalAlpha = 0.18;
                for (let x = 0; x < 512; x += 10) {
                    sc.fillStyle = (x % 20 === 0) ? '#9f7346' : '#c79a66';
                    sc.fillRect(x, 0, 6, 256);
                }
                sc.globalAlpha = 1;
                // logo circle
                sc.globalAlpha = 0.22;
                sc.strokeStyle = '#2c2c2c';
                sc.lineWidth = 10;
                sc.beginPath(); sc.arc(256, 128, 70, 0, Math.PI * 2); sc.stroke();
                sc.globalAlpha = 0.18;
                sc.fillStyle = '#2c2c2c';
                sc.font = 'bold 34px Arial';
                sc.textAlign = 'center';
                sc.textBaseline = 'middle';
                sc.fillText('COFFEE', 256, 128);
                sc.globalAlpha = 1;

                const sleeveTex = new THREE.CanvasTexture(sleeveCanvas);
                try { if ('colorSpace' in sleeveTex && THREE.SRGBColorSpace) sleeveTex.colorSpace = THREE.SRGBColorSpace; } catch (_) {}
                sleeveTex.wrapS = THREE.RepeatWrapping;
                sleeveTex.repeat.set(1, 1);

                const sleeveMat = new THREE.MeshStandardMaterial({
                    map: sleeveTex,
                    roughness: 0.96,
                    metalness: 0.0
                });
                const sleeve = new THREE.Mesh(new THREE.CylinderGeometry(0.118, 0.104, 0.13, 32, 1, true), sleeveMat);
                sleeve.position.y = cupY - 0.005;
                g.add(sleeve);

                // cappuccino surface (warm brown + white heart latte art)
                const cremaCanvas = document.createElement('canvas');
                cremaCanvas.width = 256; cremaCanvas.height = 256;
                const cc = cremaCanvas.getContext('2d');
                // base warm brown gradient
                const bg = cc.createRadialGradient(128, 110, 12, 128, 128, 140);
                bg.addColorStop(0, '#b97a45');
                bg.addColorStop(0.55, '#8a4f2a');
                bg.addColorStop(1, '#5f331b');
                cc.fillStyle = bg;
                cc.fillRect(0, 0, 256, 256);

                // crema ring
                const rg = cc.createRadialGradient(128, 128, 24, 128, 128, 120);
                rg.addColorStop(0, 'rgba(255,255,255,0)');
                rg.addColorStop(0.6, 'rgba(255,255,255,0)');
                rg.addColorStop(0.78, 'rgba(240, 220, 180, 0.22)');
                rg.addColorStop(1, 'rgba(240, 220, 180, 0)');
                cc.fillStyle = rg;
                cc.beginPath(); cc.arc(128, 128, 120, 0, Math.PI * 2); cc.fill();

                // subtle foam specks (deterministic-ish pattern without animation)
                for (let i = 0; i < 90; i++) {
                    const x = 128 + (Math.random() - 0.5) * 160;
                    const y = 128 + (Math.random() - 0.5) * 160;
                    const r = 0.8 + Math.random() * 1.6;
                    cc.fillStyle = `rgba(250, 240, 225, ${0.05 + Math.random() * 0.07})`;
                    cc.beginPath(); cc.arc(x, y, r, 0, Math.PI * 2); cc.fill();
                }

                // Heart latte art (white) in center
                cc.save();
                cc.translate(128, 132);
                cc.rotate(-0.06);
                cc.scale(1.0, 1.0);
                cc.fillStyle = 'rgba(255,255,255,0.92)';
                cc.beginPath();
                // classic heart path
                cc.moveTo(0, 32);
                cc.bezierCurveTo(-48, 10, -44, -34, 0, -18);
                cc.bezierCurveTo(44, -34, 48, 10, 0, 32);
                cc.closePath();
                cc.fill();
                // small tail
                cc.fillStyle = 'rgba(255,255,255,0.82)';
                cc.beginPath();
                cc.moveTo(0, 30);
                cc.quadraticCurveTo(8, 42, 0, 54);
                cc.quadraticCurveTo(-8, 42, 0, 30);
                cc.closePath();
                cc.fill();
                cc.restore();

                const cremaTex = new THREE.CanvasTexture(cremaCanvas);
                // Make heart face the seat (outward). With decor yaw applied, default orientation faces inward.
                cremaTex.center.set(0.5, 0.5);
                cremaTex.rotation = Math.PI;
                const coffee = new THREE.Mesh(
                    // Fill the cup interior (avoid "hollow ring")
                    new THREE.CircleGeometry(0.102, 32),
                    new THREE.MeshStandardMaterial({ map: cremaTex, roughness: 0.55, metalness: 0.0, transparent: true, opacity: 0.95, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 })
                );
                coffee.name = 'coffeeSurface';
                coffee.rotation.x = -Math.PI / 2;
                // Slightly below the lip to avoid z-fighting flicker
                coffee.position.y = (cupY + cupH / 2) - 0.012;
                g.add(coffee);
            } else if (t === 'wine') {
                // Normal open wine glass: lathe profile for proper cup shape; wine has a FLAT surface.
                const glassMat = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    roughness: 0.035,
                    metalness: 0.0,
                    transmission: 1.0,
                    thickness: 0.16,
                    ior: 1.5,
                    reflectivity: 0.55,
                    clearcoat: 0.25,
                    clearcoatRoughness: 0.22,
                    transparent: true,
                    opacity: 1.0,
                    depthWrite: false
                });

                // Glass profile: build a smooth curve from key points, then sample many points for silky lines.
                const key = [
                    new THREE.Vector3(0.00, 0.00, 0),
                    new THREE.Vector3(0.13, 0.00, 0),  // base edge
                    new THREE.Vector3(0.12, 0.015, 0),
                    new THREE.Vector3(0.04, 0.02, 0),  // base center bump
                    new THREE.Vector3(0.02, 0.02, 0),
                    // stem (tall)
                    new THREE.Vector3(0.017, 0.18, 0),
                    new THREE.Vector3(0.018, 0.28, 0),
                    new THREE.Vector3(0.022, 0.32, 0),
                    // bowl
                    new THREE.Vector3(0.055, 0.35, 0),
                    new THREE.Vector3(0.11, 0.43, 0),
                    new THREE.Vector3(0.126, 0.52, 0),
                    new THREE.Vector3(0.115, 0.585, 0),
                    // rim flare
                    new THREE.Vector3(0.112, 0.64, 0)
                ];
                const curve = new THREE.CatmullRomCurve3(key, false, 'centripetal');
                const pts = curve.getPoints(60).map(p => new THREE.Vector2(Math.max(0, p.x), p.y));
                const glassGeo = new THREE.LatheGeometry(pts, 72);
                const glass = new THREE.Mesh(glassGeo, glassMat);
                g.add(glass);

                // Wine body: follow bowl shape (not a cone), filled to ~2/3 of bowl height, with a flat surface.
                const wineMat = new THREE.MeshStandardMaterial({
                    color: 0x7f0f1a,
                    roughness: 0.62,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.88,
                    depthWrite: false
                });
                // Bowl spans roughly y=0.34 .. y=0.64 (0.30 height). 2/3 fill => +0.20
                const wineBottomY = 0.355;
                const wineTopY = 0.555;
                const margin = 0.010; // keep inside glass wall
                const wineProfile = [
                    new THREE.Vector2(0.0, wineBottomY),
                    new THREE.Vector2(Math.max(0.04, 0.055 - margin), wineBottomY), // bottom of wine
                    new THREE.Vector2(Math.max(0.06, 0.085 - margin), 0.42),
                    new THREE.Vector2(Math.max(0.07, 0.100 - margin), 0.49),
                    new THREE.Vector2(Math.max(0.075, 0.110 - margin), wineTopY)
                ];
                const wineGeo = new THREE.LatheGeometry(wineProfile, 44);
                const wineBody = new THREE.Mesh(wineGeo, wineMat);
                g.add(wineBody);

                // Flat surface of wine
                const wineSurface = new THREE.Mesh(
                    new THREE.CircleGeometry((0.110 - margin) * 0.98, 32),
                    new THREE.MeshStandardMaterial({ color: 0x7f0f1a, roughness: 0.55, metalness: 0.0, transparent: true, opacity: 0.92, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: -1 })
                );
                wineSurface.rotation.x = -Math.PI / 2;
                // Slightly below the meniscus to avoid z-fighting with glass
                wineSurface.position.y = wineTopY + 0.0005;
                g.add(wineSurface);
            } else if (t === 'cigar') {
                // Cigar resting on a textured ashtray (no stray planes), with light smoke.
                const ashtray = new THREE.Group();
                const ashMat = new THREE.MeshStandardMaterial({ color: 0x2f3136, roughness: 0.55, metalness: 0.18 });
                const ashInner = new THREE.MeshStandardMaterial({ color: 0x1b1d22, roughness: 0.85, metalness: 0.06 });
                const trayOuter = new THREE.Mesh(new THREE.CylinderGeometry(0.20, 0.20, 0.045, 36), ashMat);
                trayOuter.position.y = 0.022;
                ashtray.add(trayOuter);
                const trayInner = new THREE.Mesh(new THREE.CylinderGeometry(0.155, 0.155, 0.03, 32), ashInner);
                trayInner.position.y = 0.018;
                ashtray.add(trayInner);
                // rim
                const trayRim = new THREE.Mesh(new THREE.TorusGeometry(0.20, 0.012, 12, 40), ashMat);
                trayRim.rotation.x = Math.PI / 2;
                trayRim.position.y = 0.045;
                ashtray.add(trayRim);
                // notches
                const notchMat = new THREE.MeshStandardMaterial({ color: 0x3a3d44, roughness: 0.6, metalness: 0.14 });
                for (let k = 0; k < 4; k++) {
                    const notch = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.022, 0.03), notchMat);
                    const a = (k / 4) * Math.PI * 2;
                    notch.position.set(Math.cos(a) * 0.18, 0.05, Math.sin(a) * 0.18);
                    notch.rotation.y = a;
                    ashtray.add(notch);
                }
                g.add(ashtray);

                const wrapCanvas = document.createElement('canvas');
                wrapCanvas.width = 512; wrapCanvas.height = 128;
                const wc = wrapCanvas.getContext('2d');
                wc.fillStyle = '#6f3f1f';
                wc.fillRect(0, 0, 512, 128);
                // wrapper fibers (subtle)
                for (let i = 0; i < 90; i++) {
                    wc.strokeStyle = `rgba(0,0,0,${0.06 + Math.random() * 0.06})`;
                    wc.lineWidth = 1 + Math.random() * 1.2;
                    const y = Math.random() * 128;
                    wc.beginPath();
                    wc.moveTo(0, y);
                    wc.bezierCurveTo(160, y + (Math.random() - 0.5) * 10, 320, y + (Math.random() - 0.5) * 10, 512, y);
                    wc.stroke();
                }
                const wrapTex = new THREE.CanvasTexture(wrapCanvas);
                wrapTex.wrapS = THREE.RepeatWrapping;
                wrapTex.repeat.set(2.2, 1);
                const wrapperMat = new THREE.MeshStandardMaterial({ map: wrapTex, roughness: 0.78, metalness: 0.08 });

                // Build cigar + band + ends + smoke as ONE grouped object to avoid misalignment.
                // We align cigar axis to local Z, where +Z points toward table center after decor placement.
                const cigarGroup = new THREE.Group();
                cigarGroup.position.set(0.0, 0.075, 0.0); // rests on ashtray
                cigarGroup.rotation.y = -Math.PI / 10; // slight diagonal on the tray
                cigarGroup.rotation.z = Math.PI / 22;  // slight roll
                g.add(cigarGroup);

                const len = 0.34;
                const half = len / 2;
                const r = 0.045;
                const rotX = Math.PI / 2; // cylinder Y -> Z

                const cigarBody = new THREE.Mesh(new THREE.CylinderGeometry(r, r, len, 24), wrapperMat);
                cigarBody.rotation.x = rotX;
                cigarBody.position.set(0.0, 0.0, 0.0);
                cigarGroup.add(cigarBody);

                // gold band ring (around body)
                const band = new THREE.Mesh(
                    new THREE.CylinderGeometry(r + 0.001, r + 0.001, 0.05, 24),
                    new THREE.MeshStandardMaterial({ color: 0xd6c27b, roughness: 0.26, metalness: 0.25 })
                );
                band.rotation.x = rotX;
                band.position.set(0.0, 0.0, -0.06);
                cigarGroup.add(band);

                // cut end (near seat/outside) at -Z
                const cut = new THREE.Mesh(
                    new THREE.CylinderGeometry(r + 0.001, r + 0.001, 0.012, 24),
                    new THREE.MeshStandardMaterial({ color: 0x4b2a15, roughness: 0.9, metalness: 0.02 })
                );
                cut.rotation.x = rotX;
                cut.position.set(0.0, 0.0, -half - 0.004);
                cigarGroup.add(cut);

                // burnt/ash tip (toward table center) at +Z
                const burnt = new THREE.Mesh(
                    new THREE.CylinderGeometry(r + 0.002, r + 0.002, 0.022, 24),
                    new THREE.MeshStandardMaterial({ color: 0x1a1411, roughness: 0.95, metalness: 0.0 })
                );
                burnt.rotation.x = rotX;
                burnt.position.set(0.0, 0.0, half + 0.004);
                cigarGroup.add(burnt);

                // ember "dots" (fire cores) on the lit end + ash specks
                const emberMat = new THREE.MeshStandardMaterial({ color: 0xff6a2a, emissive: 0xff3b12, emissiveIntensity: 0.9, roughness: 0.5, metalness: 0.0 });
                const ashMat2 = new THREE.MeshStandardMaterial({ color: 0x6c6b6d, roughness: 0.98, metalness: 0.02 });
                for (let i = 0; i < 10; i++) {
                    const e = new THREE.Mesh(new THREE.SphereGeometry(0.006 + Math.random() * 0.006, 10, 8), emberMat);
                    const ang = Math.random() * Math.PI * 2;
                    const rr = Math.random() * (r * 0.55);
                    e.position.set(Math.cos(ang) * rr, (Math.random() - 0.5) * 0.01, half + 0.02 + Math.random() * 0.01);
                    cigarGroup.add(e);
                }
                for (let i = 0; i < 10; i++) {
                    const a = new THREE.Mesh(new THREE.SphereGeometry(0.005 + Math.random() * 0.006, 10, 8), ashMat2);
                    const ang = Math.random() * Math.PI * 2;
                    const rr = (r * 0.65) + Math.random() * (r * 0.22);
                    a.position.set(Math.cos(ang) * rr, (Math.random() - 0.5) * 0.012, half + 0.012 + Math.random() * 0.012);
                    cigarGroup.add(a);
                }

                // smoke sprite attached to the lit end (prevents offset)
                const smokeCanvas = document.createElement('canvas');
                smokeCanvas.width = 128; smokeCanvas.height = 128;
                const sm = smokeCanvas.getContext('2d');
                sm.clearRect(0, 0, 128, 128);
                const sg = sm.createRadialGradient(64, 64, 10, 64, 64, 58);
                sg.addColorStop(0, 'rgba(220,220,220,0.22)');
                sg.addColorStop(0.45, 'rgba(220,220,220,0.12)');
                sg.addColorStop(1, 'rgba(220,220,220,0)');
                sm.fillStyle = sg;
                sm.beginPath(); sm.arc(64, 64, 58, 0, Math.PI * 2); sm.fill();
                const smokeTex = new THREE.CanvasTexture(smokeCanvas);
                const smokeMat = new THREE.SpriteMaterial({ map: smokeTex, transparent: true, opacity: 0.68, depthWrite: false });
                const smoke = new THREE.Sprite(smokeMat);
                smoke.scale.set(0.34, 0.48, 1);
                smoke.position.set(0.0, 0.14, half + 0.12);
                cigarGroup.add(smoke);
            }

            // User-requested: make all props bigger (previously 2.0x, now +1.5x => 3.0x total)
            try { g.scale.multiplyScalar(3.0); } catch (_) {}

            g.traverse((o) => {
                if (o && o.isMesh) {
                    o.castShadow = false;
                    o.receiveShadow = false;
                }
            });
            return g;
        }


        function updatePlayerDecorMesh(player) {
            if (!player) return;
            const desired = String(player.decorType || 'none').toLowerCase();
            if (player.decorMesh) {
                try { tableGroup.remove(player.decorMesh); } catch (_) {}
                player.decorMesh = null;
            }
            if (desired === 'none') return;

            const mesh = createDecorMesh(desired);
            if (!mesh) return;

            // Place to the RIGHT of the HOLE CARDS, but closer to the seat (farther from table center).
            // Hole cards are placed at: player.pos + inward * 0.8 (+/- fanOffset). We'll use the center point.
            const inward = new THREE.Vector3(-Math.sin(player.angle), 0, -Math.cos(player.angle)).normalize();
            const outward = inward.clone().multiplyScalar(-1);
            const right = new THREE.Vector3(inward.z, 0, -inward.x).normalize();
            const holeCenter = player.pos.clone().add(inward.clone().multiplyScalar(0.8));
            // Move outward (toward seat) and further right for clear separation from cards
            const base = holeCenter
                .clone()
                .add(outward.multiplyScalar(0.70))   // closer to seat / away from center
                .add(right.multiplyScalar(1.55));   // more to the right
            // Put props on the table surface (no floating)
            mesh.position.set(base.x, 0.03, base.z);
            mesh.rotation.y = player.angle + Math.PI; // roughly face player

            player.decorMesh = mesh;
            tableGroup.add(mesh);

            // Make cola label face the seat/player (not fixed to "outer side" direction).
            try {
                if (desired === 'cola') {
                    const sticker = mesh.getObjectByName('colaSticker');
                    if (sticker) {
                        // Move sticker to the side of the cup that faces the seat (outward from table center),
                        // and make its FRONT face point at the seat.
                        const worldStickerY = sticker.getWorldPosition(new THREE.Vector3()).y;
                        const outward = player.pos.clone().sub(mesh.position);
                        outward.y = 0;
                        if (outward.lengthSq() > 1e-6) outward.normalize();
                        // Convert outward direction into mesh-local XZ (mesh yaw only)
                        const localOut = outward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -mesh.rotation.y);
                        const rSticker = 0.158; // approx outer radius of the glass
                        sticker.position.set(localOut.x * rSticker, sticker.position.y, localOut.z * rSticker);
                        // Align sticker facing direction to match chip "50" facing direction.
                        // Chip stacks use rotation.y = player.angle + PI/2; decor mesh uses rotation.y = player.angle + PI.
                        // So in mesh-local space, sticker should be rotated by -PI/2.
                        sticker.rotation.set(0, -Math.PI / 2, 0);
                        // Keep it upright
                        sticker.rotation.z = 0;
                        // preserve y (avoid unused var lint in some bundlers)
                        void worldStickerY;
                    }
                }
            } catch (_) {}
        }

        let _chipMatCached = null;
        function getChipMaterial() {
            if (_chipMatCached) return _chipMatCached;
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;

            // base (blue chip)
            const g = ctx.createRadialGradient(W/2, H/2, 12, W/2, H/2, W/2);
            g.addColorStop(0, '#f2f8ff');
            g.addColorStop(0.28, '#bfe2ff');
            g.addColorStop(0.62, '#1b78d6');
            g.addColorStop(1, '#083a77');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,W,H);

            // rings
            ctx.strokeStyle = 'rgba(3, 20, 45, 0.45)';
            ctx.lineWidth = 10;
            ctx.beginPath(); ctx.arc(W/2, H/2, 104, 0, Math.PI*2); ctx.stroke();
            ctx.lineWidth = 6;
            ctx.beginPath(); ctx.arc(W/2, H/2, 70, 0, Math.PI*2); ctx.stroke();

            // edge ticks (chip stripes)
            ctx.save();
            ctx.translate(W/2, H/2);
            for (let i = 0; i < 24; i++) {
                ctx.rotate((Math.PI*2)/24);
                ctx.fillStyle = (i % 2 === 0) ? 'rgba(255,255,255,0.78)' : 'rgba(10, 35, 85, 0.22)';
                ctx.fillRect(88, -8, 24, 16);
            }
            ctx.restore();

            // center plate for value text (keeps "50" readable)
            ctx.fillStyle = 'rgba(255,255,255,0.28)';
            ctx.beginPath();
            ctx.arc(W/2, H/2, 50, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.22)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(W/2, H/2, 50, 0, Math.PI*2);
            ctx.stroke();

            // value text
            ctx.fillStyle = 'rgba(0,0,0,0.92)';
            ctx.font = '900 78px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('50', W/2, H/2 + 3);

            // micro speckles for texture
            for (let i = 0; i < 1200; i++) {
                const x = Math.random()*W, y = Math.random()*H;
                const a = Math.random() < 0.04 ? 0.35 : 0.08;
                ctx.fillStyle = Math.random() < 0.52 ? `rgba(255,255,255,${a})` : `rgba(0,15,40,${a})`;
                ctx.fillRect(x, y, 1, 1);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 8;
            tex.needsUpdate = true;

            _chipMatCached = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                map: tex,
                roughness: 0.46,
                metalness: 0.03,
                emissive: 0x7ec3ff,
                emissiveIntensity: 0.045
            });
            return _chipMatCached;
        }

        async function startNewHand() {
            if(gameState.currentRoundNum >= gameState.totalRounds) {
                showFinalSummary();
                return;
            }
            // Ê£ÄÊü•Ââ©‰ΩôÊúâÈí±ÁöÑÁé©ÂÆ∂
            const activeCount = gameState.players.filter(p => p.chips > 0).length;
            if (activeCount < 2) {
                alert("Game Over! Not enough players with chips.");
                showFinalSummary();
                return;
            }

            gameState.currentRoundNum++;
            
            // Áâ©ÁêÜÁ∫ßÈîÄÊØÅÊóßÁâ©‰Ωì
            while(cardsGroup.children.length > 0) cardsGroup.remove(cardsGroup.children[0]);
            while(chipsGroup.children.length > 0) chipsGroup.remove(chipsGroup.children[0]);
            
            gameState.deck = [];
            const rks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            const sts = ['hearts', 'diamonds', 'clubs', 'spades'];
            for(let s of sts) for(let r of rks) gameState.deck.push({s, r, v: rks.indexOf(r)});
            for(let i=gameState.deck.length-1; i>0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
            gameState.round = 'PRE-FLOP'; gameState.pot = 0; gameState.communityCards = [];
            
            // Ê£ÄÊü•Á†¥‰∫ß
            gameState.players.forEach(p => { 
                p.hand = []; 
                p.isFolded = p.chips <= 0; 
                if(p.chips <= 0) p.isBankrupt = true;
                p.currentBet = 0; 
                p.meshCards = []; 
            });

            gameState.isGameOver = false;
            gameState.currentMaxBet = gameState.bigBlind;
            gameState.numActionThisRound = 0;
            currentRaiseInput = gameState.minRaise;
            
            document.getElementById('btn-next').style.display = 'none';
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'block');
            
            updateUI();
            addToHistory(`--- HAND ${gameState.currentRoundNum} / ${gameState.totalRounds} ---`);
            
            // Âº∫Âà∂‰∏ãÁõ≤Ê≥®
            const sbSeatIdx = getActiveOffset(gameState.dealerIdx, 1);
            const bbSeatIdx = getActiveOffset(gameState.dealerIdx, 2);
            placeBet(sbSeatIdx, gameState.smallBlind);
            placeBet(bbSeatIdx, gameState.bigBlind);
            
            const sbP = gameState.players.find(p => p.id === sbSeatIdx);
            const bbP = gameState.players.find(p => p.id === bbSeatIdx);
            if(sbP) addToHistory(`${sbP.name} posts SB $${gameState.smallBlind}`);
            if(bbP) addToHistory(`${bbP.name} posts BB $${gameState.bigBlind}`);

            for(let j=0; j<2; j++) {
                for(let i=0; i<CONFIG.numPlayers; i++) {
                    const idx = (gameState.dealerIdx + 1 + i) % CONFIG.numPlayers;
                    const p = gameState.players.find(p => p.id === idx);
                    if(!p || p.isBankrupt) continue;
                    const card = gameState.deck.pop();
                    p.hand.push(card);
                    await dealCardAnim(card, p, idx === gameState.myPlayerIdx);
                }
            }
            
            // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÊ≠£Á°ÆËÆæÁΩÆ UTG Áé©ÂÆ∂ÁöÑÊï∞ÁªÑÁ¥¢Âºï
            const utgSeatIdx = getActiveOffset(gameState.dealerIdx, 3);
            gameState.activeIdx = gameState.players.findIndex(p => p.id === utgSeatIdx);
            checkTurn();
        }

        function showFinalSummary() {
            const list = document.getElementById('summary-list-content');
            list.innerHTML = "";
            [...gameState.players].sort((a, b) => b.chips - a.chips).forEach(p => {
                const div = document.createElement('div');
                div.className = 'summary-item';
                div.innerHTML = `<span style="color:${p.id === gameState.myPlayerIdx ? 'gold' : '#fff'}">${p.name} ${p.isBankrupt ? '(Bankrupt)' : ''}</span> <b>$${p.chips}</b>`;
                list.appendChild(div);
            });
            document.getElementById('summary-modal').style.display = 'block';
        }

        async function dealCardAnim(card, player, faceUp) {
            try { SFX.deal(); } catch (_) {}
            const mesh = createCardMesh(card, faceUp);
            mesh.position.set(0, 3, 0);
            cardsGroup.add(mesh);
            player.meshCards.push(mesh);
            
            const fanOffset = (player.hand.length - 1.5) * 0.8; 
            const yOffset = 0.3 + player.hand.length * 0.05; 
            
            // ÁõÆÊ†á‰ΩçÁΩÆÔºöÁ®çÂæÆÈù†ËøëÊ°åÂ≠êÂúÜÂøÉ‰∏ÄÁÇπÁÇπ (Áõ∏ÂØπ‰∫é player.pos)
            const target = player.pos.clone().add(new THREE.Vector3(
                -Math.sin(player.angle) * 0.8 + Math.cos(player.angle) * fanOffset, 
                yOffset, 
                -Math.cos(player.angle) * 0.8 - Math.sin(player.angle) * fanOffset
            ));

            return new Promise(r => {
                gsap.to(mesh.position, { x: target.x, y: target.y, z: target.z, duration: 0.6, onComplete: r });
                // Áªü‰∏ÄÊóãËΩ¨ÈÄªËæëÔºà‰øÆÂ§çÔºöÊâÄÊúâÁâåÈÉΩÊúù‚ÄúÊ°åÂ≠êËæπÁºò‚ÄùÊéÄËµ∑Ôºå‰∏ç‰æßÁùÄÊéÄÔºâ
                // ‰ΩøÁî® YXZÔºåËÆ©‚ÄúÂÖàYawÂà∞Èù¢ÂêëÁé©ÂÆ∂ÔºåÂÜçPitchÊéÄËµ∑‚ÄùÂú®ÊâÄÊúâÁé©ÂÆ∂‰∏äÊñπÂêë‰∏ÄËá¥
                mesh.rotation.order = 'YXZ';
                // ËÆ©ÊØè‰∏ÄÂº†ÁâåÈÉΩÊúù‚ÄúËØ•Â∫ß‰ΩçÊñπÂêë‚ÄùÊéÄËµ∑ÔºöÁî®‚ÄúÁâå -> Á≠πÁ†ÅÂ†Ü(ÊàñÁé©ÂÆ∂‰ΩçÁΩÆ)‚ÄùÁöÑÊñπÂêëÊù•Á°ÆÂÆö yaw
                const ref = (player.stackGroup && player.stackGroup.position) ? player.stackGroup.position : player.pos;
                const dx = ref.x - target.x;
                const dz = ref.z - target.z;
                const yawToSeat = Math.atan2(dx, dz);
                gsap.to(mesh.rotation, { 
                    y: yawToSeat,
                    // Ê≠£ÂÄºÔºöËÆ©Èù†Â∫ß‰Ωç/Áé©ÂÆ∂‰∏Ä‰æßÂéã‰ΩéÔºåÈù†Ê°åÂ≠ê‰∏≠ÂøÉ‰∏Ä‰æßÊä¨È´ò
                    x: 0.55,
                    z: 0,
                    duration: 0.6 
                });
            });
        }

        function createCardMesh(card, faceUp) {
            const group = new THREE.Group();
            // Âç°Áâå‰∏ª‰Ωì - ÁôΩÂ∫ïÔºàPokerNow È£éÊ†ºÔºâ
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.cardWidth, 0.02, CONFIG.cardHeight), 
                new THREE.MeshStandardMaterial({ color: 0xf7f7f7, metalness: 0.05, roughness: 0.85 })
            );
            group.add(body);
            group.userData = { card: card };

            if(faceUp) {
                // Ê≠£Èù¢ÔºöÁôΩÂ∫ï + Á∫¢ÈªëËä±Ëâ≤ÔºàPokerNow-likeÔºâ
                const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
                drawCardFaceCanvas(canvas, card);

                const label = new THREE.Mesh(
                    new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
                );
                label.rotation.x = -Math.PI/2; label.position.y = 0.011;
                group.add(label);
            } else {
                // ËÉåÈù¢ÔºöÈáëËâ≤Á≤íÂ≠ê/ÈáëÁÆîË¥®ÊÑüÁâåËÉå
                const backCanvas = document.createElement('canvas'); backCanvas.width=256; backCanvas.height=384;
                drawCardBackCanvas(backCanvas);
                const back = new THREE.Mesh(
                    new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(backCanvas) })
                );
                back.rotation.x = Math.PI/2; back.position.y = 0.011;
                group.add(back);
            }
            return group;
        }

        function flipCard(mesh) {
            const card = mesh.userData.card;
            while(mesh.children.length > 1) mesh.remove(mesh.children[1]); // ‰øùÁïôbody
            
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
            drawCardFaceCanvas(canvas, card);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
            );
            label.rotation.x = -Math.PI/2; label.position.y = 0.011;
            mesh.add(label);

            gsap.to(mesh.rotation, { x: 0, duration: 0.5 });
        }

        function revealCardOnMesh(mesh, card) {
            if (!mesh) return;
            mesh.userData.card = card;
            // remove old face/back
            while (mesh.children.length > 1) mesh.remove(mesh.children[1]);
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
            drawCardFaceCanvas(canvas, card);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
            );
            label.rotation.x = -Math.PI/2; label.position.y = 0.011;
            mesh.add(label);
            // keep existing tilt; only add a tiny "reveal" nudge
            gsap.to(mesh.rotation, { x: mesh.rotation.x * 0.98, duration: 0.25 });
        }

        function orientCardTowardViewer(mesh, viewerSeatIdx) {
            if (!mesh) return;
            let ref = null;
            const viewer = gameState.players?.find(p => p.id === viewerSeatIdx);
            if (viewer && viewer.stackGroup?.position) ref = viewer.stackGroup.position;
            else if (viewer && viewer.pos) ref = viewer.pos;
            else if (camera?.position) ref = camera.position;
            if (!ref) return;

            const dx = ref.x - mesh.position.x;
            const dz = ref.z - mesh.position.z;
            const yaw = Math.atan2(dx, dz);
            mesh.rotation.order = 'YXZ';
            mesh.rotation.y = yaw;
            mesh.rotation.x = 0.28; // tilt toward viewer for readability
            mesh.rotation.z = 0;
        }

        function drawCardFaceCanvas(canvas, card) {
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            const suitChar = ({hearts:'‚ô•',diamonds:'‚ô¶',clubs:'‚ô£',spades:'‚ô†'}[card.s]) || '?';
            const isRed = (card.s === 'hearts' || card.s === 'diamonds');
            const ink = isRed ? '#c21807' : '#111111';

            // background
            ctx.clearRect(0,0,W,H);
            ctx.fillStyle = '#fdfdfd';
            ctx.fillRect(0,0,W,H);

            // border (slight rounded rectangle)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 6;
            roundRect(ctx, 10, 10, W-20, H-20, 18);
            ctx.stroke();

            // corners
            ctx.fillStyle = ink;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.font = 'bold 54px Arial, sans-serif';
            ctx.fillText(String(card.r), 22, 18);
            ctx.font = 'bold 52px Arial, sans-serif';
            ctx.fillText(suitChar, 24, 76);

            // bottom-right (rotated)
            ctx.save();
            ctx.translate(W, H);
            ctx.rotate(Math.PI);
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = ink;
            ctx.font = 'bold 54px Arial, sans-serif';
            ctx.fillText(String(card.r), 22, 18);
            ctx.font = 'bold 52px Arial, sans-serif';
            ctx.fillText(suitChar, 24, 76);
            ctx.restore();

            // center suit
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = ink;
            ctx.font = 'bold 170px Arial, sans-serif';
            ctx.fillText(suitChar, W/2, H/2 + 10);
        }

        function drawCardBackCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            // Gold-foil base gradient
            const g = ctx.createLinearGradient(0, 0, W, H);
            g.addColorStop(0, '#6b4b12');
            g.addColorStop(0.35, '#ffd27a');
            g.addColorStop(0.65, '#b8831f');
            g.addColorStop(1, '#3a2506');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,W,H);
            ctx.strokeStyle = 'rgba(20, 12, 3, 0.85)';
            ctx.lineWidth = 6;
            roundRect(ctx, 10, 10, W-20, H-20, 18);
            ctx.stroke();

            // subtle diagonal micro-lines (foil brushing)
            ctx.globalAlpha = 0.22;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.55)';
            ctx.lineWidth = 1;
            for (let i = -H; i < W; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i + H, H);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // gold particle "sparkles"
            const rng = (a, b) => a + Math.random() * (b - a);
            for (let i = 0; i < 1800; i++) {
                const x = Math.random() * W;
                const y = Math.random() * H;
                const r = rng(0.4, 1.35);
                const bright = Math.random();
                const a = bright > 0.985 ? rng(0.65, 0.95) : rng(0.05, 0.18);
                ctx.fillStyle = bright > 0.985 ? `rgba(255, 245, 210, ${a})` : `rgba(255, 212, 120, ${a})`;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // center emblem (very subtle)
            ctx.save();
            ctx.translate(W / 2, H / 2);
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = 'rgba(25, 16, 4, 0.9)';
            ctx.beginPath();
            ctx.arc(0, 0, 92, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = 'rgba(255, 230, 150, 0.9)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 92, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            const rr = Math.min(r, w/2, h/2);
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.lineTo(x + w - rr, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
            ctx.lineTo(x + w, y + h - rr);
            ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
            ctx.lineTo(x + rr, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
            ctx.lineTo(x, y + rr);
            ctx.quadraticCurveTo(x, y, x + rr, y);
            ctx.closePath();
        }

        function createFoldParticles(player) {
            try { SFX.fold(); } catch (_) {}
            player.meshCards.forEach(mesh => {
                const pos = mesh.position.clone();
                const rot = mesh.rotation.clone();
                const pColor = 0xd4af37;
                
                // 1. ÂàõÂª∫ÂØÜÈõÜÁöÑÂéü‰ΩçÁ≤íÂ≠êÁæ§
                const count = 200;
                const geo = new THREE.BufferGeometry();
                const posArr = new Float32Array(count * 3);
                
                for(let i=0; i<count; i++) {
                    // Âú®Âç°ÁâåÁü©ÂΩ¢Âå∫ÂüüÂÜÖÈöèÊú∫ÂàÜÂ∏É
                    const ux = (Math.random()-0.5) * CONFIG.cardWidth;
                    const uz = (Math.random()-0.5) * CONFIG.cardHeight;
                    
                    // Â∫îÁî®Âç°ÁâåÁöÑÊóãËΩ¨
                    const p = new THREE.Vector3(ux, 0, uz).applyEuler(rot);
                    posArr[i*3] = pos.x + p.x;
                    posArr[i*3+1] = pos.y + p.y;
                    posArr[i*3+2] = pos.z + p.z;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                
                const pMaterial = new THREE.PointsMaterial({ 
                    color: pColor, 
                    size: 0.03, 
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending 
                });
                const points = new THREE.Points(geo, pMaterial);
                environmentGroup.add(points);
                
                // ÁßªÈô§ÂéüÂÆû‰Ωì
                cardsGroup.remove(mesh);
                
                // 2. ÊÖ¢ÊÖ¢ÂèòÊ∑°ÁöÑÊ∂àÊï£Âä®Áîª
                gsap.to(pMaterial, { 
                    opacity: 0, 
                    duration: 2.0, 
                    ease: "power1.inOut",
                    onComplete: () => environmentGroup.remove(points) 
                });
                // Á≤íÂ≠êÂæÆÂº±ÁöÑÂêë‰∏äÊºÇÁßªÊÑü
                gsap.to(points.position, { y: "+=0.3", duration: 2.0, ease: "none" });
            });
            player.meshCards = [];
        }

        function placeBet(seatIdx, amt) {
            const p = gameState.players.find(p => p.id === seatIdx);
            if (!p) return;
            const realAmt = Math.min(amt, p.chips);
            p.chips -= realAmt;
            p.currentBet += realAmt;
            gameState.pot += realAmt;
            try { SFX.chip(); } catch (_) {}
            
            if(p.currentBet > gameState.currentMaxBet) {
                gameState.currentMaxBet = p.currentBet;
                // Âè™Ë¶ÅÊúâ‰∫∫Âä†Ê≥®ÔºåÈô§‰∫ÜÂä†Ê≥®ËÄÖÂ§ñÔºåÂÖ∂‰ªñ‰∫∫ÈÉΩÂøÖÈ°ªÈáçÊñ∞Ë°®ÊÄÅ
                gameState.numActionThisRound = 0; 
            }
            
            // ‰∏ãÊ≥®Âä®ÁîªÔºöÊ†πÊçÆ‰∏ãÊ≥®ÈáëÈ¢ùÁîüÊàêÂØπÂ∫îÊï∞ÈáèÁ≠πÁ†ÅÔºàËÄå‰∏çÊòØÊ∞∏Ëøú 1 ‰∏™Ôºâ
            const chipCount = Math.max(1, Math.min(18, Math.floor((Number.isFinite(realAmt) ? realAmt : 50) / CONFIG.chipValue)));
            for (let i = 0; i < chipCount; i++) {
                const chip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                    getChipMaterial().clone()
                );
                // Opaque chips for stable stacking (avoids transparency sorting shimmer)
                chip.material.transparent = false;
                chip.material.opacity = 1.0;
                chip.position.copy(p.pos);
                chip.position.y = 0.06 + i * 0.006; // physically stacked
                // keep label oriented to that seat (+90deg correction for cap UV)
                chip.rotation.set(0, (p.angle || 0) + Math.PI / 2, 0);
                chipsGroup.add(chip);
                gsap.to(chip.position, {
                    x: (Math.random() - 0.5) * 2,
                    y: 0.05 + i * 0.006,
                    z: (Math.random() - 0.5) * 2,
                    duration: 0.65 + Math.random() * 0.12,
                    ease: "power2.out"
                });
            }
            updateUI();
        }

        function checkTurn() {
            if(gameState.isGameOver) return;
            // watchdogÔºöÂ¶ÇÊûúÈîÅ‰ΩèË∂ÖËøá3ÁßíÔºåËØ¥ÊòéÊüêÊ¨°AIÂä®‰ΩúÂºÇÂ∏∏/‰∏¢Â§±ÂõûË∞ÉÔºåÂº∫Âà∂Ëß£ÈîÅÁªßÁª≠
            if(gameState.isProcessing) {
                if(Date.now() - (gameState.processingSince || 0) > 3000) {
                    console.warn('[WATCHDOG] Force unlock isProcessing');
                    dbg('watchdog unlock (checkTurn)');
                    gameState.isProcessing = false;
                } else {
                    return;
                }
            }
            
            const p = gameState.players[gameState.activeIdx];
            if (!p) { 
                console.warn("No player at index", gameState.activeIdx);
                dbg(`no player at idx=${gameState.activeIdx}`);
                setTimeout(() => nextStep(), 50); 
                return; 
            }

            // Â¶ÇÊûúÂΩìÂâçÁé©ÂÆ∂Â∑≤ÂºÉÁâåÊàñÊ≤°Èí±‰∫ÜÔºåÁõ¥Êé•Ë∑≥ËøáÂà∞‰∏ã‰∏Ä‰∏™‰∫∫
            if(p.isFolded || p.chips <= 0) { 
                dbg(`skip ${p.name} (folded=${p.isFolded}, chips=${p.chips})`);
                setTimeout(() => nextStep(), 50); 
                return; 
            }

            dbg(`turn ${p.name} idx=${gameState.activeIdx}`);
            setGameMsg(gameState.round, p.name, gameState.pot, false);
            if(p.id === gameState.myPlayerIdx) {
                toggleButtons(true);
            } else {
                toggleButtons(false);
                gameState.isProcessing = true; // AIÂä®‰ΩúÂä†ÈîÅ
                gameState.processingSince = Date.now();
                setTimeout(() => {
                    try {
                        // AI ÂÜ≥Á≠ñ
                    const callAmt = gameState.currentMaxBet - p.currentBet;
                    const rand = Math.random();
                    if(rand > 0.85 && callAmt > 0) {
                            p.isFolded = true; 
                            addToHistory(`${p.name} Folds.`); 
                            createFoldParticles(p);
                        } else if (rand > 0.7 && p.chips > (callAmt + gameState.minRaise)) {
                            // AI Âä†Ê≥®
                        const raiseAmt = gameState.minRaise;
                            placeBet(p.id, callAmt + raiseAmt);
                        addToHistory(`${p.name} Raises to ${p.currentBet}.`);
                    } else {
                            // AI Ë∑üÊ≥®ÊàñËøáÁâå
                        if (callAmt > 0) {
                                placeBet(p.id, Math.min(callAmt, p.chips));
                                if (p.chips === 0) addToHistory(`${p.name} is ALL-IN!`);
                                else addToHistory(`${p.name} Calls.`);
                        } else {
                            addToHistory(`${p.name} Checks.`);
                        }
                    }
                    } catch (err) {
                        console.error('[AI ACTION ERROR]', err);
                        addToHistory(`ERROR: AI action failed (${p.name})`);
                    } finally {
                        gameState.isProcessing = false;
                        gameState.processingSince = 0;
                        // Êó†ËÆ∫Â¶Ç‰ΩïÈÉΩË¶ÅÁªßÁª≠Êé®ËøõÔºåÂê¶ÂàôÂ∞±‰ºöÂç°Ê≠ªÂú®‚ÄúÊüêÊüêÁöÑÂõûÂêà‚Äù
                        try { nextStep(); } catch(e2) { console.error('[NEXTSTEP ERROR]', e2); }
                    }
                }, 1000);
            }
        }

        function nextStep() {
            if (gameState.isGameOver) return;

            const activePlayers = gameState.players.filter(p => !p.isFolded);
            if (activePlayers.length <= 1) {
                dbg(`nextStep -> winner (activePlayers=${activePlayers.length})`);
                determineWinner();
                return;
            }

            // 1. Êú¨ËΩÆÂä®‰ΩúËÆ°Êï∞
            gameState.numActionThisRound++;

            // 2. Âà§ÂÆö‰∏ÄËΩÆÊòØÂê¶ÁªìÊùü
            const allMatched = gameState.players.every(p => 
                p.isFolded || p.chips === 0 || p.currentBet === gameState.currentMaxBet
            );
            
            // Âà§ÂÆö Pre-flop Â§ßÁõ≤‰ΩçÊúÄÂêéÂä†Ê≥®ÊùÉÂà©
            const bbSeatIdx = getActiveOffset(gameState.dealerIdx, 2);
            const bbPlayer = gameState.players.find(p => p.id === bbSeatIdx);
            const isBBTurn = gameState.players[gameState.activeIdx] === bbPlayer;
            const isPreFlopUnraised = (gameState.round === 'PRE-FLOP' && gameState.currentMaxBet === gameState.bigBlind);

            if (allMatched && gameState.numActionThisRound >= activePlayers.length) {
                // ÁâπÊÆäÔºöPre-flop ‰∏îËøòÊ≤°‰∫∫Âä†Ê≥®Êó∂ÔºåÂ§ßÁõ≤‰Ωç(BB)Êã•ÊúâÊúÄÂêéËØ¥ËØùÊùÉÔºà‰ªÖÊ≠§‰∏ÄÊ¨°Ôºâ
                if (isPreFlopUnraised && isBBTurn && gameState.numActionThisRound === activePlayers.length) {
                    dbg('preflop BB option');
                    checkTurn();
                    return;
                }
                dbg(`advanceRound (round=${gameState.round})`);
                    advanceRound();
                return;
            }

            // 3. ÂØªÊâæ‰∏ã‰∏Ä‰∏™ÈúÄË¶ÅËØ¥ËØùÁöÑ‰∫∫
            let found = false;
            let checkIdx = gameState.activeIdx;
            for(let i=0; i<gameState.players.length; i++) {
                checkIdx = (checkIdx + 1) % gameState.players.length;
                const nextP = gameState.players[checkIdx];
                if (!nextP.isFolded && nextP.chips > 0) {
                    gameState.activeIdx = checkIdx;
                    found = true;
                    dbg(`next -> ${nextP.name} idx=${checkIdx}`);
                    break;
                }
            }

            if (!found) {
                dbg('no next actor -> advanceRound');
                advanceRound();
            } else {
                checkTurn();
            }
        }

        async function advanceRound() {
            gameState.players.forEach(p => p.currentBet = 0);
            gameState.currentMaxBet = 0;
            gameState.numActionThisRound = 0;
            
            if(gameState.round === 'PRE-FLOP') { gameState.round = 'FLOP'; await dealCommunity(3); }
            else if(gameState.round === 'FLOP') { gameState.round = 'TURN'; await dealCommunity(1); }
            else if(gameState.round === 'TURN') { gameState.round = 'RIVER'; await dealCommunity(1); }
            else { 
                gameState.round = 'SHOWDOWN';
                determineWinner();
                return;
            }
            // Round starts with the player after dealer
            const startSeatIdx = getActiveOffset(gameState.dealerIdx, 1);
            let startArrIdx = gameState.players.findIndex(p => p.id === startSeatIdx);
            
            if (startArrIdx === -1) startArrIdx = 0; // ÂÆâÂÖ®ÂõûÈÄÄ
            gameState.activeIdx = startArrIdx;

            // Â¶ÇÊûúËµ∑ÂßãÁé©ÂÆ∂Â∑≤ÁªèÂºÉÁâåÊàñÊ≤°Èí±‰∫ÜÔºåÂØªÊâæ‰∏ã‰∏Ä‰∏™
            let loops = 0;
            while((gameState.players[gameState.activeIdx].isFolded || gameState.players[gameState.activeIdx].chips <= 0) && loops < gameState.players.length) {
                gameState.activeIdx = (gameState.activeIdx + 1) % gameState.players.length;
                loops++;
            }
            checkTurn();
        }

        async function dealCommunity(n) {
            for(let i=0; i<n; i++) {
                const card = gameState.deck.pop();
                gameState.communityCards.push(card);
                const mesh = createCardMesh(card, false);
                mesh.position.set(0, 5, 0);
                mesh.rotation.order = 'YXZ';
                mesh.rotation.set(0, 0, 0);
                cardsGroup.add(mesh);
                try { SFX.deal(); } catch (_) {}
                // Á§æÂå∫ÁâåÔºöÊÇ¨ÊµÆÂπ≥Ë∫∫Âú®Ê°åÈù¢‰∏äÊñπÔºà‰∏çÊúùÂΩìÂâçÁé©ÂÆ∂ÂÄæÊñúÔºâ
                const finalX = (gameState.communityCards.length-3)*0.9;
                gsap.to(mesh.position, { x: finalX, y: 0.18, z: 0, duration: 0.7, ease: "power2.out" });
                // reveal after landing
                await new Promise(r => setTimeout(r, 420));
                try {
                    revealCardOnMesh(mesh, card);
                    mesh.rotation.order = 'YXZ';
                    mesh.rotation.set(0, 0, 0);
                } catch (_) {}
                await new Promise(r => setTimeout(r, 200));
            }
        }

        // --- ‰∏ì‰∏öÂæ∑Â∑ûÊâëÂÖãÂà§ÂÆöÂºïÊìé ---
        function getBestHand(sevenCards) {
            // ÂÆâÂÖ®ÂÖúÂ∫ïÔºöÂ¶ÇÊûúÂõ†‰∏∫ÂºÉÁâåÊèêÂâçÁªìÊùüÔºåÂèØËÉΩ‰ºöÂú®ÁøªÁâåÂâç/ËΩ¨ÁâåÂâçÂ∞±ÁªìÁÆóÔºåÊ≠§Êó∂ÁâåÊï∞ < 5
            if (!sevenCards || sevenCards.length < 5) {
                return { rank: 0, value: [], desc: "No Showdown (Fold)" };
            }
            const combinations = (arr, k) => {
                const results = [];
                const combine = (start, combo) => {
                    if (combo.length === k) { results.push([...combo]); return; }
                    for (let i = start; i < arr.length; i++) {
                        combo.push(arr[i]);
                        combine(i + 1, combo);
                        combo.pop();
                    }
                };
                combine(0, []);
                return results;
            };

            const combos = combinations(sevenCards, 5);
            let best = null;

            combos.forEach(combo => {
                const evalResult = evaluate5(combo);
                if (!best || compareHands(evalResult, best) > 0) {
                    best = evalResult;
                }
            });
            return best;
        }

        function evaluate5(cards) {
            const sorted = [...cards].sort((a, b) => b.v - a.v);
            const ranks = sorted.map(c => c.v);
            const suits = sorted.map(c => c.s);
            
            const isFlush = suits.every(s => s === suits[0]);
            
            // È°∫Â≠êÂà§ÂÆö (ÂåÖÂê´ A-2-3-4-5 ÁâπÊÆäÊÉÖÂÜµ)
            let isStraight = false;
            let straightMax = 0;
            const uniqueRanks = [...new Set(ranks)];
            if (uniqueRanks.length === 5) {
                if (ranks[0] - ranks[4] === 4) {
                    isStraight = true;
                    straightMax = ranks[0];
                } else if (ranks[0] === 14 && ranks[1] === 5 && ranks[4] === 2) {
                    isStraight = true;
                    straightMax = 5; // A-2-3-4-5 È°∫Â≠êÔºåÊúÄÂ§ßÁÇπÊï∞‰∏∫ 5
                }
            }

            // È¢ëÁéáÁªüËÆ°
            const counts = {};
            ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
            const freq = Object.values(counts).sort((a, b) => b - a);
            const rankByFreq = Object.keys(counts).map(Number).sort((a, b) => {
                if (counts[b] !== counts[a]) return counts[b] - counts[a];
                return b - a;
            });

            // Âà§ÂÆöÈÄªËæë
            if (isFlush && isStraight) {
                if (straightMax === 14) return { rank: 10, value: [14], desc: "Royal Flush" };
                return { rank: 9, value: [straightMax], desc: "Straight Flush" };
            }
            if (freq[0] === 4) return { rank: 8, value: [rankByFreq[0], rankByFreq[1]], desc: "Four of a Kind" };
            if (freq[0] === 3 && freq[1] === 2) return { rank: 7, value: [rankByFreq[0], rankByFreq[1]], desc: "Full House" };
            if (isFlush) return { rank: 6, value: ranks, desc: "Flush" };
            if (isStraight) return { rank: 5, value: [straightMax], desc: "Straight" };
            if (freq[0] === 3) return { rank: 4, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2]], desc: "Three of a Kind" };
            if (freq[0] === 2 && freq[1] === 2) return { rank: 3, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2]], desc: "Two Pair" };
            if (freq[0] === 2) return { rank: 2, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2], rankByFreq[3]], desc: "One Pair" };
            return { rank: 1, value: ranks, desc: "High Card" };
        }

        function compareHands(h1, h2) {
            // ÂÆâÂÖ®ÂÖúÂ∫ïÔºöÈÅøÂÖç null/undefined ÂØºËá¥Â¥©Ê∫É
            if (!h1 && !h2) return 0;
            if (!h1) return -1;
            if (!h2) return 1;
            if (h1.rank !== h2.rank) return h1.rank - h2.rank;
            for (let i = 0; i < h1.value.length; i++) {
                if (h1.value[i] !== h2.value[i]) return h1.value[i] - h2.value[i];
            }
            return 0;
        }

        function determineWinner() {
            gameState.isGameOver = true;
            const activePlayers = gameState.players.filter(p => !p.isFolded);

            // 1) ÂºÉÁâåÊèêÂâçÁªìÊùüÔºöÂè™Ââ© 1 ‰∫∫ÔºåÁõ¥Êé•ËÉúÂá∫Ôºå‰∏çÂÅö Showdown ËØÑ‰º∞ÔºàÈÅøÂÖç <5 Âº†ÁâåÊó∂ÁªÑÂêàËØÑ‰º∞Âá∫ÈîôÔºâ
            if (activePlayers.length === 1) {
                const p = activePlayers[0];
                addToHistory(`Game Over. ${p.name} wins (all others folded)!`);
                try { SFX.rattle(); } catch (_) {}

                // Â∞ÜÊâÄÊúâÁ≠πÁ†ÅÁßªÂä®Âà∞Ëµ¢ÂÆ∂‰ΩçÁΩÆÔºå‰∏îË¥¥ËøëÊ°åÈù¢
                chipsGroup.children.forEach(chip => {
                    gsap.to(chip.position, { 
                        x: p.pos.x + (Math.random()-0.5)*0.5, 
                        z: p.pos.z + (Math.random()-0.5)*0.5, 
                        y: 0.05, 
                        duration: 1.2,
                        ease: "power2.inOut"
                    });
                });

                const winAmount = gameState.pot;
                setTimeout(() => {
                    p.chips += winAmount;
                    gameState.pot = 0;
                    updateUI();
                    showNextRoundButton();
                }, 1200);
                return;
            }
            // ÊûÅÁ´ØÂÖúÂ∫ïÔºöÂ¶ÇÊûúÊ≤°‰∫∫‰∫ÜÔºàÁêÜËÆ∫‰∏ä‰∏çÂ∫îÂèëÁîüÔºâ
            if (activePlayers.length === 0) {
                addToHistory(`Game Over. (No active players)`);
                gameState.pot = 0;
                updateUI();
                showNextRoundButton();
                return;
            }
            
            // ÂÖ®‰Ωì‰∫ÆÁâåÂπ∂ËØÑ‰º∞
            const evaluations = activePlayers.map(p => {
                p.meshCards.forEach(mesh => flipCard(mesh));
                return { player: p, result: getBestHand([...p.hand, ...gameState.communityCards]) };
            });

            // ÂØªÊâæÊúÄÂº∫ÁâåÂûã
            evaluations.sort((a, b) => compareHands(b.result, a.result));
            const bestResult = evaluations[0]?.result;
            const winners = bestResult ? evaluations.filter(e => compareHands(e.result, bestResult) === 0) : [evaluations[0]];

            const winnerNames = winners.map(w => w.player.name).join(" & ");
            addToHistory(`Game Over. ${winnerNames} wins with ${bestResult?.desc || 'Unknown'}!`);
            
            // ÂàÜÊ±†ÈÄªËæë
            const winAmount = Math.floor(gameState.pot / winners.length);
            
            winners.forEach((w, idx) => {
                const p = w.player;
                // Â∞ÜÊâÄÊúâÁ≠πÁ†ÅÁßªÂä®Âà∞Ëµ¢ÂÆ∂‰ΩçÁΩÆÔºå‰∏îË¥¥ËøëÊ°åÈù¢
                chipsGroup.children.forEach(chip => {
                    gsap.to(chip.position, { 
                        x: p.pos.x + (Math.random()-0.5)*0.5, 
                        z: p.pos.z + (Math.random()-0.5)*0.5, 
                        y: 0.05, 
                    duration: 1.2, 
                        ease: "power2.inOut"
                    });
                });
                if (idx === 0) { try { SFX.rattle(); } catch (_) {} }

                // Âª∂ËøüÊõ¥Êñ∞UIÔºåÁ≠âÂä®ÁîªÁªìÊùü
                setTimeout(() => {
                    if(idx === 0) { // Âè™Âú®Á¨¨‰∏Ä‰∏™Ëµ¢ÂÆ∂Êó∂Ê∏ÖÁ©∫Âπ∂Êõ¥Êñ∞‰∏ÄÊ¨°UIÔºàÁÆÄÂçïÂ§ÑÁêÜÔºâ
                        p.chips += winAmount;
                        gameState.pot = 0;
                        updateUI();
                        showNextRoundButton();
                    } else {
                        p.chips += winAmount;
                        updateUI();
                    }
                }, 1200);
            });
        }

        function showNextRoundButton() {
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
            document.getElementById('btn-next').style.display = 'block';
        }

        function updateUI() {
            document.getElementById('pot-amount').innerText = gameState.pot;
            gameState.players.forEach((p) => {
                const el = document.getElementById(`chips-${p.id}`);
                if(el) el.innerText = `$${p.chips}`;
                updatePlayerStackMesh(p);
            });
            document.getElementById('raise-amount-display').innerText = currentRaiseInput;

            // Update action button labels immediately (both offline + multiplayer)
            try {
                const btnCheck = document.getElementById('btn-check');
                const btnRaise = document.getElementById('btn-raise');
                const seatId = IS_MULTIPLAYER ? mySeatIdx : gameState.myPlayerIdx;
                const me = gameState.players.find(p => p.id === seatId);
                const maxBet = Number(gameState.currentMaxBet || 0);
                const myBet = me ? Number(me.currentBet || 0) : 0;
                const myChips = me ? Number(me.chips || 0) : 0;
                const toCall = me ? Math.max(0, maxBet - myBet) : 0;
                const callPay = Math.max(0, Math.min(toCall, myChips));
                if (btnCheck) {
                    btnCheck.innerText = (toCall > 0)
                        ? `${t('btn_call')} $${callPay}${(myChips > 0 && myChips < toCall) ? ` (${t('btn_allin')})` : ''}`
                        : t('btn_check');
                    btnCheck.style.display = 'block';
                }
                if (btnRaise) {
                    if (toCall > 0) {
                        btnRaise.innerText = `${t('btn_raise')} +$${Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0))}`;
                    } else {
                        const betAmt = Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0) || 0);
                        btnRaise.innerText = `${t('btn_bet')} $${betAmt}`;
                    }
                }
            } catch (_) {}
        }

        function addToHistory(msg) {
            const raw = String(msg || '');
            // store newest-first so rerender preserves visual order
            activityRaw.unshift(raw);
            if (activityRaw.length > 220) activityRaw.pop();
            const list = document.getElementById('history-list');
            if (!list) return;
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:#d4af37;opacity:0.5">></span> ${translateActivity(raw)}`;
            list.prepend(div);
        }

        function toggleButtons(on) {
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.disabled = !on);
        }

        function setupEvents() {
            window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
            try {
                const prev = window.onresize;
                window.onresize = () => {
                    try { prev && prev(); } catch (_) {}
                    try { applyMobileIconButtons(); } catch (_) {}
                };
            } catch (_) {}

            // Decor picker (seat selection)
            try {
                const panel = document.getElementById('decor-panel');
                const sel = document.getElementById('decor-select');
                const btn = document.getElementById('decor-apply');

                const updatePanel = () => {
                    if (!panel) return;
                    const seated = Number.isInteger(gameState.myPlayerIdx) && gameState.myPlayerIdx >= 0;
                    panel.style.display = seated ? 'block' : 'none';
                    if (!seated || !sel) return;
                    const seatIdx = IS_MULTIPLAYER ? mySeatIdx : gameState.myPlayerIdx;
                    const current = IS_MULTIPLAYER ? (gameState.seatMeta?.[seatIdx]?.decor || 'none') : (seatDecor[seatIdx] || 'none');
                    sel.value = current;
                };
                updatePanel();
                // called from multiple places
                window.__updateDecorPanel = updatePanel;

                if (btn && sel) {
                    btn.onclick = () => {
                        const seatIdx = IS_MULTIPLAYER ? mySeatIdx : gameState.myPlayerIdx;
                        if (!Number.isInteger(seatIdx) || seatIdx < 0) return;
                        const choice = String(sel.value || 'none');
                        if (IS_MULTIPLAYER) {
                            try { socket.emit('set_decor', { decor: choice }); } catch (_) {}
                        } else {
                            seatDecor[seatIdx] = choice;
                            // if already at table, update my mesh now
                            const me = gameState.players.find(p => p.id === seatIdx);
                            if (me) {
                                me.decorType = choice;
                                updatePlayerDecorMesh(me);
                            }
                        }
                        addToHistory(`${t('decor_set')} ${trDecorChoice(choice)}`);
                    };
                }
            } catch (_) {}

            // Activity panel collapse (mobile-friendly; keep it in the corner)
            try {
                const histPanel = document.getElementById('history-panel');
                const histBtn = document.getElementById('history-collapse');
                const isMobile = () => window.innerWidth <= 600;
                const applyHistCollapsed = (collapsed) => {
                    if (!histPanel) return;
                    histPanel.classList.toggle('collapsed', !!collapsed);
                    try { localStorage.setItem('nebula_history_collapsed', collapsed ? '1' : '0'); } catch (_) {}
                    try { applyLanguageToUI(); } catch (_) {}
                };
                // default collapsed on mobile, but remember preference
                try {
                    const saved = localStorage.getItem('nebula_history_collapsed');
                    if (saved === null && isMobile()) applyHistCollapsed(true);
                    else if (saved === '1') applyHistCollapsed(true);
                    else if (saved === '0') applyHistCollapsed(false);
                } catch (_) {}
                if (histBtn && histPanel) {
                    histBtn.onclick = (e) => {
                        try { e.preventDefault(); e.stopPropagation(); } catch (_) {}
                        applyHistCollapsed(!histPanel.classList.contains('collapsed'));
                    };
                }
            } catch (_) {}

            // HUD panel collapse (desktop "icon column" like mobile)
            try {
                const hud = document.getElementById('hud-panel');
                const hudBtn = document.getElementById('hud-collapse');
                const applyHudCollapsed = (collapsed) => {
                    if (!hud) return;
                    hud.classList.toggle('collapsed', !!collapsed);
                    try { localStorage.setItem('nebula_hud_collapsed', collapsed ? '1' : '0'); } catch (_) {}
                    try { applyLanguageToUI(); } catch (_) {}
                    try { applyMobileIconButtons(); } catch (_) {}
                };
                try {
                    const saved = localStorage.getItem('nebula_hud_collapsed');
                    if (saved === '1') applyHudCollapsed(true);
                    else if (saved === '0') applyHudCollapsed(false);
                } catch (_) {}
                if (hudBtn && hud) {
                    hudBtn.onclick = (e) => {
                        try { e.preventDefault(); e.stopPropagation(); } catch (_) {}
                        applyHudCollapsed(!hud.classList.contains('collapsed'));
                    };
                }
            } catch (_) {}

            // BGM UI (user gesture required for autoplay policies)
            try {
                const bgm = document.getElementById('bgm');
                const bgmBtn = document.getElementById('bgm-toggle');
                // Default ON (Áî®Êà∑ÂèØÊâãÂä®ÂÖ≥Èó≠). Browsers may block audible autoplay, so we:
                // 1) try normal play; 2) fallback to muted autoplay; 3) unmute on first user gesture.
                const saved = localStorage.getItem('nebula_bgm') || 'on';
                const setLabel = (on) => { if (bgmBtn) bgmBtn.innerText = on ? 'BGM: On' : 'BGM: Off'; };
                setLabel(saved === 'on');
                if (bgm) {
                    bgm.volume = 0.35;
                    bgm.muted = false;
                }
                const tryAutoPlay = async () => {
                    if (!bgm) return;
                    if (!(localStorage.getItem('nebula_bgm') === 'on' || !localStorage.getItem('nebula_bgm'))) return;
                    try {
                        bgm.muted = false;
                        await bgm.play();
                        return;
                    } catch (_) {
                        // Audible autoplay likely blocked. Try muted autoplay.
                        try {
                            bgm.muted = true;
                            await bgm.play();
                            return;
                        } catch (e2) {
                            console.warn('[bgm] autoplay failed', e2);
                        }
                    }
                };
                // Always: on first user gesture, ensure audio is playing (no need to toggle Off->On).
                const ensurePlayingOnGesture = async () => {
                    try {
                        if (!bgm) return;
                        if (!(localStorage.getItem('nebula_bgm') === 'on' || !localStorage.getItem('nebula_bgm'))) return;
                        if (bgm.paused) {
                            bgm.muted = false;
                            await bgm.play();
                        } else if (bgm.muted) {
                            bgm.muted = false;
                        }
                    } catch (_) {}
                };
                window.addEventListener('pointerdown', ensurePlayingOnGesture, { once: true });
                window.addEventListener('keydown', ensurePlayingOnGesture, { once: true });
                if (bgmBtn) {
                    bgmBtn.onclick = async () => {
                        if (!bgm) return;
                        const wantOn = !(localStorage.getItem('nebula_bgm') === 'on');
                        localStorage.setItem('nebula_bgm', wantOn ? 'on' : 'off');
                        setLabel(wantOn);
                        try {
                            if (wantOn) {
                                bgm.muted = false;
                                await bgm.play();
                            } else {
                                bgm.pause();
                                bgm.muted = false;
                            }
                        } catch (e) {
                            // Most common: autoplay blocked or codec unsupported
                            console.warn('[bgm] play failed', e);
                            alert('BGM failed to play. If autoplay is blocked, tap once and try again.');
                            localStorage.setItem('nebula_bgm', 'off');
                            setLabel(false);
                        }
                    };
                }
                // attempt autoplay on load (default ON)
                if (saved === 'on') {
                    setTimeout(() => { tryAutoPlay(); }, 0);
                }
            } catch (_) {}

            // Reset view (camera + orbit target)
            try {
                const resetBtn = document.getElementById('reset-view');
                if (resetBtn) {
                    resetBtn.onclick = () => {
                        try {
                            if (!camera) return;
                            camera.fov = DEFAULT_VIEW.fov;
                            camera.updateProjectionMatrix();
                            camera.position.copy(DEFAULT_VIEW.cameraPos);
                            camera.lookAt(DEFAULT_VIEW.target);
                            if (controls) {
                                controls.target.copy(DEFAULT_VIEW.target);
                                controls.update();
                            }
                        } catch (_) {}
                    };
                }
            } catch (_) {}

            // Desktop: persist HUD panel size (so resizing "sticks")
            try {
                const hud = document.getElementById('hud-panel');
                if (hud) {
                    const kW = 'nebula_hud_w';
                    const kH = 'nebula_hud_h';
                    const savedW = Number(localStorage.getItem(kW) || '');
                    const savedH = Number(localStorage.getItem(kH) || '');
                    if (Number.isFinite(savedW) && savedW > 180) hud.style.width = `${savedW}px`;
                    if (Number.isFinite(savedH) && savedH > 120) hud.style.height = `${savedH}px`;

                    let t = null;
                    const save = () => {
                        try {
                            const r = hud.getBoundingClientRect();
                            localStorage.setItem(kW, String(Math.round(r.width)));
                            localStorage.setItem(kH, String(Math.round(r.height)));
                        } catch (_) {}
                    };
                    // ResizeObserver gives best results; fallback to mouseup
                    if (window.ResizeObserver) {
                        const ro = new ResizeObserver(() => {
                            clearTimeout(t);
                            t = setTimeout(save, 120);
                        });
                        ro.observe(hud);
                    } else {
                        hud.addEventListener('mouseup', save);
                        hud.addEventListener('touchend', save);
                    }
                }
            } catch (_) {}

            // SFX toggle
            try {
                const sfxBtn = document.getElementById('sfx-toggle');
                if (sfxBtn) {
                    const apply = () => { sfxBtn.innerText = SFX.isEnabled() ? 'SFX: On' : 'SFX: Off'; };
                    apply();
                    sfxBtn.onclick = async () => {
                        const next = !SFX.isEnabled();
                        SFX.setEnabled(next);
                        apply();
                        if (next) {
                            try { await SFX.ensureCtx(); } catch (_) {}
                            // small confirmation blip
                            try { SFX.turn(); } catch (_) {}
                        }
                    };
                }
            } catch (_) {}

            // Language toggle (EN / ‰∏≠Êñá)
            try {
                const langBtn = document.getElementById('lang-toggle');
                const applyLang = () => { if (langBtn) langBtn.innerText = t('lang_label'); };
                applyLang();
                if (langBtn) {
                    langBtn.onclick = () => {
                        UI_LANG = (UI_LANG === 'en') ? 'zh' : 'en';
                        localStorage.setItem('nebula_lang', UI_LANG);
                        applyLang();
                        applyLanguageToUI();
                    };
                }
            } catch (_) {}

            // Lobby language toggle
            try {
                const lobbyLangBtn = document.getElementById('lang-toggle-lobby');
                if (lobbyLangBtn) {
                    lobbyLangBtn.onclick = () => {
                        UI_LANG = (UI_LANG === 'en') ? 'zh' : 'en';
                        localStorage.setItem('nebula_lang', UI_LANG);
                        applyLanguageToUI();
                    };
                }
            } catch (_) {}

            // Voice UI
            updateMicButton();
            if (!IS_MULTIPLAYER) {
                setVoiceStatus('Voice: Online only');
                const micBtn = document.getElementById('mic-toggle');
                if (micBtn) micBtn.disabled = true;
            } else {
                const micBtn = document.getElementById('mic-toggle');
                if (micBtn) {
                    micBtn.onclick = async () => {
                        // Must be seated to join voice (server enforces this)
                        if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) {
                            alert('Take a seat before joining voice.');
                            return;
                        }
                        await voiceJoinIfPossible();
                        if (!voiceState.localStream) return;
                        const track = voiceState.localStream.getAudioTracks()[0];
                        const nextOn = !voiceState.micOn;
                        voiceState.micOn = nextOn;
                        if (track) track.enabled = nextOn;
                        setVoiceStatus(voiceState.connected ? `Voice: Connected${nextOn ? '' : ' (muted)'}` : 'Voice: Not connected');
                        updateMicButton();
                    };
                }
            }
            
            // Lobby Interaction
            document.getElementById('lobby-next-btn').onclick = () => {
                const user = document.getElementById('username-input').value;
                const room = document.getElementById('room-id-input').value;
                const initChips = parseInt(document.getElementById('init-chips-input').value);
                const totalRounds = parseInt(document.getElementById('total-rounds-input').value);

                if(!user || !room) { alert("Please enter Username and Room ID"); return; }
                if(initChips < 1000 || initChips % 50 !== 0) { alert("Initial Chips must be >= 1000 and multiple of 50"); return; }

                gameState.initialChips = initChips;
                gameState.totalRounds = totalRounds;

                if (IS_MULTIPLAYER) {
                    wireMultiplayer();
                    pendingJoin = true;
                    joinedRoomOnce = false;
                    socket.emit('join_room', { roomId: room, name: user, clientId: CLIENT_ID });
                    document.getElementById('lobby-overlay').style.display = 'none';
                    showSeatSelection(); // UI‰ªçÊòæÁ§∫Ôºå‰ΩÜÊï∞ÊçÆÊù•Ëá™ÊúçÂä°Âô®
                } else {
                    document.getElementById('lobby-overlay').style.display = 'none';
                    showSeatSelection();
                }
            };

            function showSeatSelection() {
                const seatOverlay = document.getElementById('seat-overlay');
                const seatGrid = document.getElementById('seat-grid');
                seatGrid.innerHTML = "";
                seatOverlay.style.display = 'block';

                for(let i=0; i<CONFIG.numPlayers; i++) {
                    const box = document.createElement('div');
                    box.className = 'seat-box';
                    box.id = `seat-box-${i}`;
                    box.innerHTML = `
                        <div style="position: relative; font-weight: bold; margin-bottom: 10px;">
                            ${t('seat_label')} ${i+1}
                            <span id="seat-host-${i}" style="display:none; position:absolute; right:0; top:0; font-size:12px; color:gold; opacity:0.95;">üîë HOST</span>
                        </div>
                        <div id="seat-status-${i}" style="font-size: 0.8em; margin-bottom: 15px; color: #aaa;">${t('seat_empty')}</div>
                        <div class="seat-actions">
                            <button class="seat-action-btn" id="join-btn-${i}">${t('seat_take')}</button>
                            <button class="seat-action-btn" id="ai-btn-${i}">${t('seat_add_ai')}</button>
                            <button class="seat-action-btn" id="kick-btn-${i}" style="display:none;">${t('seat_remove')}</button>
                        </div>
                    `;
                    seatGrid.appendChild(box);

                    // ÈÄâÂ∫ßÈÄªËæë
                    document.getElementById(`join-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (IS_MULTIPLAYER) {
                            socket.emit('take_seat', { seatIdx: i });
                            mySeatIdx = i;
                            gameState.myPlayerIdx = i;
                            try { window.__updateDecorPanel?.(); } catch (_) {}
                        } else {
                            // ÂèñÊ∂à‰πãÂâçÁöÑÁé©ÂÆ∂ÈÄâÂ∫ß
                            if(gameState.myPlayerIdx !== -1) {
                                gameState.seatConfig[gameState.myPlayerIdx] = null;
                            }
                            gameState.myPlayerIdx = i;
                            gameState.seatConfig[i] = 'player';
                            updateSeatUI();
                            try { window.__updateDecorPanel?.(); } catch (_) {}
                        }
                    };

                    document.getElementById(`ai-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (IS_MULTIPLAYER) {
                            // ‰ªÖ host ÁîüÊïàÔºåÊúçÂä°Á´Ø‰ºöÊãíÁªùÈùû host
                            socket.emit('toggle_ai', { seatIdx: i });
                        } else {
                            if(gameState.seatConfig[i] === 'player') return; // ‰∏çËÉΩË¶ÜÁõñÁé©ÂÆ∂
                            gameState.seatConfig[i] = (gameState.seatConfig[i] === 'ai') ? null : 'ai';
                            updateSeatUI();
                        }
                    };

                    // host remove player (multiplayer only)
                    document.getElementById(`kick-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (!IS_MULTIPLAYER) return;
                        socket.emit('kick_seat', { seatIdx: i });
                    };
                }

                function updateSeatUI() {
                    for(let i=0; i<CONFIG.numPlayers; i++) {
                        const statusEl = document.getElementById(`seat-status-${i}`);
                        const joinBtn = document.getElementById(`join-btn-${i}`);
                        const aiBtn = document.getElementById(`ai-btn-${i}`);
                        const box = document.getElementById(`seat-box-${i}`);

                        if(gameState.seatConfig[i] === 'player') {
                            statusEl.innerText = "YOU";
                            statusEl.style.color = "gold";
                            joinBtn.classList.add('active');
                            aiBtn.style.display = "none";
                        } else if(gameState.seatConfig[i] === 'ai') {
                            statusEl.innerText = "AI BOT";
                            statusEl.style.color = "#00ff00";
                            joinBtn.style.display = "none";
                            aiBtn.classList.add('active');
                            aiBtn.innerText = t('seat_remove_ai');
                        } else {
                            statusEl.innerText = t('seat_empty');
                            statusEl.style.color = "#aaa";
                            joinBtn.style.display = "block";
                            joinBtn.classList.remove('active');
                            aiBtn.style.display = "block";
                            aiBtn.classList.remove('active');
                            aiBtn.innerText = t('seat_add_ai');
                        }
                    }
                }
                updateSeatUI();
            }

            document.getElementById('start-game-btn').onclick = () => {
                if(gameState.myPlayerIdx === -1) {
                    alert("You must select a seat first!");
                    return;
                }
                const occupiedCount = gameState.seatConfig.filter(s => s !== null).length;
                if(occupiedCount < 3) {
                    alert("At least 3 players (including AI) are needed to start!");
                    return;
                }

                gsap.to('#seat-overlay', { opacity: 0, duration: 0.5, onComplete: () => {
                    document.getElementById('seat-overlay').style.display = 'none';
                    createPlayers();
                    if (IS_MULTIPLAYER) {
                        if (!isHost) { alert("Waiting for host to start..."); return; }
                        socket.emit('start_game', { totalHands: gameState.totalRounds, initialChips: gameState.initialChips });
                    } else {
                        startNewHand();
                    }
                }});
            };

            // Rules Modal Events
            const rulesBtn = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const positionRulesModal = () => {
                if (!rulesBtn || !rulesModal) return;
                const r = rulesBtn.getBoundingClientRect();
                const margin = 8;
                const vw = window.innerWidth || document.documentElement.clientWidth || 800;
                const vh = window.innerHeight || document.documentElement.clientHeight || 600;
                const w = Math.min(330, vw - 20);
                rulesModal.style.width = `${w}px`;
                let left = Math.max(10, Math.min(vw - w - 10, r.left));
                let top = r.bottom + margin;
                // if too low, flip above
                const estH = Math.min(420, vh * 0.55);
                if (top + estH > vh - 10) top = Math.max(10, r.top - margin - estH);
                rulesModal.style.left = `${left}px`;
                rulesModal.style.top = `${top}px`;
            };

            rulesBtn.onclick = () => {
                const next = (rulesModal.style.display === 'block') ? 'none' : 'block';
                rulesModal.style.display = next;
                if (next === 'block') positionRulesModal();
            };
            document.getElementById('close-rules').onclick = () => { rulesModal.style.display = 'none'; };
            // ÁÇπÂáªÂÖ∂ÂÆÉÂå∫ÂüüÂÖ≥Èó≠Ôºà‰ΩÜÂú®Èù¢ÊùøÂÜÖÈÉ®ÁÇπÂáª‰∏çÂÖ≥Ôºâ
            window.addEventListener('click', (event) => {
                if (!rulesModal || !rulesBtn) return;
                const target = event.target;
                if (rulesModal.style.display !== 'block') return;
                if (rulesModal.contains(target) || rulesBtn.contains(target)) return;
                rulesModal.style.display = 'none';
            });
            window.addEventListener('resize', () => { if (rulesModal?.style?.display === 'block') positionRulesModal(); });

            // Theme toggle (Night / Light)
            const themeBtn = document.getElementById('theme-toggle');
            const applyTheme = (mode) => {
                document.documentElement.setAttribute('data-theme', mode);
                localStorage.setItem('nebula_theme', mode);
                themeBtn.innerText = (mode === 'light') ? (UI_LANG === 'zh' ? 'Â§úÈó¥Ê®°Âºè' : 'Night Mode') : (UI_LANG === 'zh' ? 'Êòé‰∫ÆÊ®°Âºè' : 'Light Mode');

                // also adjust 3D background/fog a bit
                if (scene) {
                    if (mode === 'light') {
                        // warm daylight, soft orange glow
                        // make 3D clear transparent so CSS casino background is visible
                        scene.background = null;
                        scene.fog = new THREE.FogExp2(0xfff0db, 0.016);
                        if (renderer) renderer.setClearColor(0x000000, 0);
                        try { if (renderer?.domElement) renderer.domElement.style.background = 'transparent'; } catch (_) {}
                        if (starField) starField.visible = false;
                    } else {
                        scene.background = new THREE.Color(0x080401);
                        scene.fog = new THREE.FogExp2(0x080401, 0.02);
                        if (renderer) renderer.setClearColor(0x000000, 1);
                        try { if (renderer?.domElement) renderer.domElement.style.background = ''; } catch (_) {}
                        if (starField) starField.visible = true;
                    }
                }
            };
            const savedTheme = localStorage.getItem('nebula_theme') || 'night';
            applyTheme(savedTheme);
            themeBtn.onclick = () => {
                const current = document.documentElement.getAttribute('data-theme') || 'night';
                applyTheme(current === 'light' ? 'night' : 'light');
            };
            
            document.getElementById('btn-plus').onclick = () => { currentRaiseInput += gameState.minRaise; updateUI(); };
            document.getElementById('btn-minus').onclick = () => {
                if (currentRaiseInput > gameState.minRaise) currentRaiseInput = Math.max(gameState.minRaise, currentRaiseInput - gameState.minRaise);
                updateUI();
            };
            
            document.getElementById('btn-fold').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    socket.emit('action', { type: 'fold' });
                } else {
                    me.isFolded = true;
                    createFoldParticles(me);
                addToHistory("You Folded.");
                nextStep();
                }
            };
            document.getElementById('btn-check').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    socket.emit('action', { type: 'call' }); // server decides call vs check
                } else {
                    const callAmt = gameState.currentMaxBet - me.currentBet;
                if (callAmt > 0) {
                        placeBet(me.id, callAmt);
                    addToHistory(`You Called $${callAmt}.`);
                } else {
                    addToHistory("You Checked.");
                }
                nextStep();
                }
            };
            document.getElementById('btn-raise').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    // Bet/Raise unified:
                    // - if no bet yet => BET (raiseBy)
                    // - if facing a bet => RAISE more (raiseBy)
                    const min = Number(gameState.minRaise || 50);
                    const raiseBy = Math.max(min, Number(currentRaiseInput || 0));
                    socket.emit('action', { type: 'raise', raiseBy });
                } else {
                    const callAmt = gameState.currentMaxBet - me.currentBet;
                    const min = Number(gameState.minRaise || 50);
                    const raiseBy = Math.max(min, Number(currentRaiseInput || 0));
                    const totalRaise = callAmt + raiseBy;
                    placeBet(me.id, totalRaise);
                    addToHistory(callAmt > 0 ? `You Raised $${raiseBy} (Total $${me.currentBet}).` : `You Bet $${raiseBy}.`);
                    nextStep();
                }
            };
            document.getElementById('btn-allin').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    socket.emit('action', { type: 'allin' });
                } else {
                    const allInAmt = me.chips;
                    placeBet(me.id, allInAmt);
                addToHistory("YOU ALL-IN!!!");
                nextStep();
                }
            };
            document.getElementById('btn-rebuy').onclick = () => {
                if (!IS_MULTIPLAYER) return;
                if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) return;
                const def = Number.isFinite(Number(gameState.initialChips)) ? Number(gameState.initialChips) : 1000;
                const raw = prompt('Rebuy amount (>=1000 and multiple of 50):', String(def));
                if (raw === null) return;
                const amt = Number(raw);
                if (!Number.isFinite(amt) || amt < 1000 || (amt % 50) !== 0) {
                    alert('Rebuy amount must be >=1000 and a multiple of 50.');
                    return;
                }
                try { socket.emit('rebuy', { amount: amt }); } catch(_) {}
                addToHistory(`Rebuy: $${amt} (applies next hand)`);
            };
            document.getElementById('btn-next').onclick = () => {
                if (IS_MULTIPLAYER) {
                    socket.emit('next_hand');
                } else {
                gameState.dealerIdx = (gameState.dealerIdx + 1) % CONFIG.numPlayers;
                startNewHand();
                }
            };
        }

        function updateSeatOverlayFromServer(state) {
            // ÂêåÊ≠•‚ÄúStart Game‚ÄùÊåâÈíÆÊòØÂê¶ÂèØÁÇπ
            const startBtn = document.getElementById('start-game-btn');
            if (!startBtn) return;
            startBtn.innerText = isHost ? t('start_game') : t('waiting_host');
            startBtn.disabled = !isHost;

            // ÂêåÊ≠•ÊØè‰∏™Â∫ß‰ΩçÁöÑÊòæÁ§∫ÔºàEmpty / YOU / AI BOT / PlayerNameÔºâ
            for (let i = 0; i < CONFIG.numPlayers; i++) {
                const statusEl = document.getElementById(`seat-status-${i}`);
                const joinBtn = document.getElementById(`join-btn-${i}`);
                const aiBtn = document.getElementById(`ai-btn-${i}`);
                const hostEl = document.getElementById(`seat-host-${i}`);
                const kickBtn = document.getElementById(`kick-btn-${i}`);
                if (!statusEl || !joinBtn || !aiBtn) continue;

                if (hostEl) {
                    hostEl.style.display = (state.hostSeatIdx === i) ? 'inline' : 'none';
                }

                const s = state.seats?.[i] || null;
                if (!s) {
                    statusEl.innerText = t('seat_empty');
                    statusEl.style.color = "#aaa";
                    joinBtn.style.display = "block";
                    joinBtn.classList.remove('active');
                    aiBtn.style.display = isHost ? "block" : "none";
                    aiBtn.classList.remove('active');
                    aiBtn.innerText = t('seat_add_ai');
                    joinBtn.innerText = t('seat_take');
                    if (kickBtn) kickBtn.style.display = "none";
                    continue;
                }

                if (s.type === 'ai') {
                    statusEl.innerText = s.name || "AI BOT";
                    statusEl.style.color = "#00ff00";
                    joinBtn.style.display = "none";
                    aiBtn.style.display = isHost ? "block" : "none";
                    aiBtn.classList.add('active');
                    aiBtn.innerText = t('seat_remove_ai');
                    if (kickBtn) kickBtn.style.display = "none";
                    continue;
                }

                // player
                const isMe = (mySeatIdx === i);
                statusEl.innerText = isMe ? "YOU" : (s.name || "PLAYER");
                // Áªü‰∏Ä‰∏∫ÁôΩËâ≤
                statusEl.style.color = "#fff";
                joinBtn.style.display = isMe ? "block" : "none";
                joinBtn.classList.toggle('active', isMe);
                aiBtn.style.display = "none";

                // Host-only kick button for players (not for self)
                if (kickBtn) {
                    if (isHost && !isMe) {
                        kickBtn.style.display = "block";
                    } else {
                        kickBtn.style.display = "none";
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if(starField) {
                starField.rotation.y += 0.0005;
                starField.rotation.x += 0.0002;
            }
            if(tableParticles) {
                tableParticles.rotation.y += 0.001;
            }

            hudData.forEach(hud => {
                const v = hud.pos.clone().project(camera);
                hud.el.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
                hud.el.style.top = `${(-(v.y * 0.5 - 0.5)) * window.innerHeight}px`;
                hud.el.style.display = v.z < 1 ? 'block' : 'none';
            });
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Poker - Advanced Pro</title>
    <style>
        :root {
            --bg: #020105;
            --text: #ffebcc;
            --panel-bg: rgba(25, 12, 5, 0.7);
            --panel-border: rgba(212, 175, 55, 0.3);
            --btn-bg: rgba(45, 25, 15, 0.6);
            --btn-border: rgba(212, 175, 55, 0.4);
            --btn-text: #d4af37;
            --accent: #d4af37;
            --rules-bg: rgba(10, 5, 2, 0.85);
            --btn-hover-bg: rgba(212, 175, 55, 0.2);
            --btn-hover-shadow: rgba(212, 175, 55, 0.3);
        }
        [data-theme="light"] {
            /* PokerNow-like "classic" UI: clean white/gray panels + red/black cards */
            --bg: #f4f6f8;
            --text: #101418;
            --panel-bg: rgba(255, 255, 255, 0.92);
            --panel-border: rgba(16, 20, 24, 0.12);
            --btn-bg: rgba(255, 255, 255, 0.96);
            --btn-border: rgba(16, 20, 24, 0.18);
            --btn-text: #101418;
            --accent: #1b8a3a;
            --rules-bg: rgba(255, 255, 255, 0.96);
            --btn-hover-bg: rgba(16, 20, 24, 0.06);
            --btn-hover-shadow: rgba(16, 20, 24, 0.10);
        }

        body { margin: 0; overflow: hidden; background: var(--bg); font-family: 'Segoe UI', sans-serif; color: var(--text); }
        /* Classic clean background for light mode */
        [data-theme="light"] body {
            background-color: var(--bg);
            background-image: radial-gradient(900px 600px at 30% 20%, rgba(255,255,255,0.9), rgba(255,255,255,0.0) 60%),
                              radial-gradient(900px 600px at 80% 60%, rgba(255,255,255,0.8), rgba(255,255,255,0.0) 60%);
        }
        #container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* Lobby UI */
        #lobby-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(15px); }
        .lobby-panel { background: rgba(30, 20, 10, 0.95); border: 1px solid #d4af37; padding: 30px; border-radius: 20px; box-shadow: 0 0 50px rgba(212, 175, 55, 0.3); text-align: center; width: 400px; max-height: 90vh; overflow-y: auto; }
        .lobby-input-group { text-align: left; margin-bottom: 15px; }
        .lobby-label { color: #d4af37; font-size: 0.9em; margin-bottom: 5px; display: block; }
        .lobby-input { width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #d4af37; color: gold; border-radius: 6px; box-sizing: border-box; }
        .lobby-btn { width: 100%; padding: 15px; background: linear-gradient(135deg, #d4af37, #8c6b00); border: none; color: black; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; margin-top: 10px; }
        
        /* Seat Selection UI */
        #seat-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 900; backdrop-filter: blur(5px); }
        .seat-container { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; width: 900px; }
        .seat-box { background: rgba(40, 30, 20, 0.85); border: 2px solid #d4af37; border-radius: 12px; padding: 12px; transition: 0.3s; color: gold; text-align: center; }
        .seat-actions { display: flex; flex-direction: column; gap: 8px; margin-top: 10px; }
        .seat-action-btn { padding: 8px; font-size: 0.8em; border-radius: 4px; cursor: pointer; border: 1px solid gold; background: rgba(212, 175, 55, 0.1); color: gold; }
        .seat-action-btn:hover { background: gold; color: black; }
        .seat-action-btn.active { background: gold; color: black; }
        .start-game-area { position: absolute; bottom: -80px; left: 0; width: 100%; text-align: center; }

        /* Summary UI */
        #summary-modal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(15, 10, 5, 0.98); border: 2px solid gold; padding: 40px; border-radius: 20px; z-index: 2000; width: 450px; text-align: center; }
        .summary-list { margin: 20px 0; border-top: 1px solid rgba(212, 175, 55, 0.3); }
        .summary-item { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }

        #ui-overlay { position: absolute; top: 20px; left: 20px; pointer-events: none; z-index: 10; width: 100%; }
        .panel { background: var(--panel-bg); padding: 15px; border-radius: 12px; border: 1px solid var(--panel-border); margin-bottom: 10px; pointer-events: auto; backdrop-filter: blur(25px); box-shadow: 0 0 40px rgba(0,0,0,0.35); }
        
        /* Rules Modal */
        #rules-btn { position: relative; z-index: 20; background: var(--btn-bg); border: 1px solid var(--btn-border); color: var(--btn-text); padding: 8px 15px; border-radius: 20px; cursor: pointer; backdrop-filter: blur(10px); transition: 0.3s; pointer-events: auto; }
        #rules-btn:hover { background: var(--btn-hover-bg); box-shadow: 0 0 15px var(--btn-hover-shadow); }
        /* Rules panel: appears directly under the Rules button (inside the ui panel) */
        #rules-modal { display: none; position: absolute; top: 100%; left: 0; margin-top: 10px; transform: none; background: var(--rules-bg); border: 1px solid rgba(255, 215, 0, 0.35); padding: 16px 16px 10px; border-radius: 15px; z-index: 100; width: 380px; max-height: calc(100vh - 240px); overflow-y: auto; backdrop-filter: blur(14px); color: var(--text); box-shadow: 0 0 35px rgba(0,0,0,0.18); }
        #rules-modal h2 { color: var(--accent); margin-top: 0; border-bottom: 1px solid rgba(212, 175, 55, 0.2); padding-bottom: 10px; }
        #rules-modal ul { list-style: none; padding: 0; }
        #rules-modal li { margin-bottom: 12px; display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.05); padding-bottom: 5px; }
        
        .rule-item { margin-bottom: 15px; border-bottom: 1px solid rgba(212, 175, 55, 0.1); padding-bottom: 10px; }
        .card-icons { display: flex; gap: 5px; margin-top: 5px; }
        .card-icons span { background: #fff; color: #000; padding: 2px 5px; border-radius: 3px; font-weight: bold; font-family: serif; min-width: 25px; text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .card-icons .card-red { color: #bb3333; }
        .card-icons .card-black { color: #1a1a1a; }

        #rules-modal .rank-name { font-weight: bold; color: var(--accent); font-size: 1.1em; }
        #close-rules { float: right; cursor: pointer; color: var(--accent); font-size: 20px; }

        #history-panel { position: absolute; right: 20px; top: 20px; width: 280px; max-height: 40vh; overflow-y: auto; z-index: 10; }
        #controls { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; pointer-events: auto; z-index: 10; align-items: center; }
        
        .touch-btn { 
            background: var(--btn-bg); border: 1px solid var(--btn-border); padding: 12px 20px; 
            color: var(--btn-text); font-weight: bold; border-radius: 6px; cursor: pointer; 
            transition: 0.3s; text-transform: uppercase; letter-spacing: 1px; min-width: 80px;
        }
        .touch-btn:hover:not(:disabled) { background: var(--btn-hover-bg); box-shadow: 0 0 20px var(--btn-hover-shadow); }
        .touch-btn:disabled { opacity: 0.1; cursor: not-allowed; }
        
        .adjust-panel { display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.18); padding: 5px 10px; border-radius: 6px; border: 1px solid rgba(212, 175, 55, 0.12); }
        .adjust-btn { background: none; border: none; color: var(--accent); font-size: 20px; cursor: pointer; font-weight: bold; width: 30px; }
        #raise-amount-display { min-width: 40px; text-align: center; font-weight: bold; color: #00ff00; }

        #btn-next { display: none; background: linear-gradient(135deg, #d4af37, #8c6b00); color: black; padding: 15px 40px; font-size: 1.2em; }
        
        .player-hud { position: absolute; pointer-events: none; transform: translate(-50%, -100%); text-align: center; }
        .chip-display { color: var(--text); font-size: 13px; margin-top: 3px; font-weight: bold; text-shadow: 0 0 15px rgba(0,0,0,0.25); }
        #game-msg { font-size: 1.1em; color: var(--text); text-align: left; letter-spacing: 2px; }

        #theme-toggle {
            margin: 10px auto 0;
            display: block;
            padding: 8px 14px;
            border-radius: 20px;
            border: 1px solid var(--btn-border);
            background: var(--btn-bg);
            color: var(--btn-text);
            cursor: pointer;
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="lobby-overlay">
        <div class="lobby-panel">
            <h1 style="color: gold; margin-bottom: 20px; font-size: 1.8em;">NEBULA POKER</h1>
            <div class="lobby-input-group">
                <label class="lobby-label">YOUR NAME</label>
                <input type="text" id="username-input" class="lobby-input" placeholder="e.g. StarLord">
            </div>
            <div class="lobby-input-group">
                <label class="lobby-label">ROOM ID</label>
                <input type="text" id="room-id-input" class="lobby-input" placeholder="Room 101">
            </div>
            <div class="lobby-input-group">
                <label class="lobby-label">INITIAL CHIPS (Min 1000, Multiples of 50)</label>
                <input type="number" id="init-chips-input" class="lobby-input" value="1000" step="50" min="1000">
            </div>
            <div class="lobby-input-group" id="rounds-group">
                <label class="lobby-label">TOTAL ROUNDS</label>
                <input type="number" id="total-rounds-input" class="lobby-input" value="5" min="1">
            </div>
            <button id="lobby-next-btn" class="lobby-btn">Continue to Select Seat</button>
        </div>
    </div>

    <div id="seat-overlay">
        <h2 style="color: gold; text-align: center; margin-top: 50px;">SEAT SELECTION</h2>
        <div class="seat-container">
            <div id="seat-grid" style="display: contents;"></div>
            <div class="start-game-area">
                <button id="start-game-btn" class="lobby-btn" style="width: 300px;">Start Game</button>
            </div>
        </div>
    </div>

    <div id="summary-modal">
        <h2 style="color: gold;">HAND OVER</h2>
        <p style="color: rgba(212, 175, 55, 0.6);">Final Chip Standings</p>
        <div class="summary-list" id="summary-list-content"></div>
        <button id="summary-confirm-btn" class="lobby-btn">Confirm Results & Back to Lobby</button>
    </div>

    <div id="container"></div>
    <div id="labels-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5;"></div>
    
    <div id="rules-modal">
        <span id="close-rules">&times;</span>
        <h2 style="text-align: center;">Hand Rankings</h2>
        <div style="font-size: 0.85em;">
            <div class="rule-item">
                <span class="rank-name">Royal Flush</span>
                <div class="card-icons">
                    <span class="card-black">A♠</span><span class="card-black">K♠</span><span class="card-black">Q♠</span><span class="card-black">J♠</span><span class="card-black">10♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Straight Flush</span>
                <div class="card-icons">
                    <span class="card-red">9♥</span><span class="card-red">8♥</span><span class="card-red">7♥</span><span class="card-red">6♥</span><span class="card-red">5♥</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Four of a Kind</span>
                <div class="card-icons">
                    <span class="card-black">A♠</span><span class="card-red">A♥</span><span class="card-black">A♣</span><span class="card-red">A♦</span><span class="card-black">K♣</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Full House</span>
                <div class="card-icons">
                    <span class="card-black">K♠</span><span class="card-red">K♥</span><span class="card-black">K♣</span><span class="card-red">Q♦</span><span class="card-black">Q♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Flush</span>
                <div class="card-icons">
                    <span class="card-black">A♣</span><span class="card-black">J♣</span><span class="card-black">8♣</span><span class="card-black">4♣</span><span class="card-black">2♣</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Straight</span>
                <div class="card-icons">
                    <span class="card-black">5♠</span><span class="card-red">4♥</span><span class="card-black">3♣</span><span class="card-red">2♦</span><span class="card-black">A♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Three of a Kind</span>
                <div class="card-icons">
                    <span class="card-black">Q♠</span><span class="card-red">Q♥</span><span class="card-black">Q♣</span><span class="card-red">8♦</span><span class="card-black">2♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">Two Pair</span>
                <div class="card-icons">
                    <span class="card-black">J♠</span><span class="card-red">J♥</span><span class="card-black">9♣</span><span class="card-red">9♦</span><span class="card-black">4♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">One Pair</span>
                <div class="card-icons">
                    <span class="card-black">10♠</span><span class="card-red">10♥</span><span class="card-black">A♣</span><span class="card-red">8♦</span><span class="card-black">3♠</span>
                </div>
            </div>
            <div class="rule-item">
                <span class="rank-name">High Card</span>
                <div class="card-icons">
                    <span class="card-black">A♠</span><span class="card-red">Q♥</span><span class="card-black">10♣</span><span class="card-red">7♦</span><span class="card-black">2♠</span>
                </div>
            </div>
        </div>
    </div>
    
    <div id="ui-overlay">
        <div class="panel" style="width: 260px; margin-left: 0;">
            <div id="game-msg">WAITING</div>
            <div style="color: #ffcc99; font-size: 1em; margin-top: 5px; text-align: center;">Pot: <b id="pot-amount" style="color: #00ff00;">0</b></div>
            <button id="rules-btn" style="margin: 10px auto 0; display: block;">Rules & Rankings</button>
            <button id="theme-toggle">Night Mode</button>
            <div style="margin-top: 10px;">
                <button id="bgm-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">BGM: Off</button>
                <button id="sfx-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">SFX: On</button>
                <button id="mic-toggle" class="touch-btn" style="width:100%; padding: 10px 12px; font-size: 0.9em;">Mic: Off</button>
                <div id="voice-status" style="font-size: 0.78em; opacity: 0.75; margin-top: 6px; text-align: left;">Voice: Not connected</div>
            </div>
            <div id="rules-modal-anchor"></div>
        </div>
    </div>

    <audio id="bgm" src="Love_Me.mp3" loop preload="auto"></audio>

    <div id="history-panel" class="panel">
        <h3 style="margin: 0 0 10px 0; font-size: 0.9em; color: rgba(212, 175, 55, 0.6);">ACTIVITY</h3>
        <div id="history-list" style="font-size: 0.8em; line-height: 1.6;"></div>
    </div>

    <div id="controls">
        <button id="btn-fold" class="touch-btn">Fold</button>
        <button id="btn-check" class="touch-btn">Check</button>
        <div class="adjust-panel">
            <button id="btn-minus" class="adjust-btn">-</button>
            <span id="raise-amount-display">50</span>
            <button id="btn-plus" class="adjust-btn">+</button>
        </div>
        <button id="btn-raise" class="touch-btn">Raise</button>
        <button id="btn-allin" class="touch-btn" style="color:#ff4444;">All-in</button>
        <button id="btn-rebuy" class="touch-btn" style="display:none;">Rebuy</button>
        <button id="btn-next" class="touch-btn">Confirm & Next Round</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- socket.io client (served by our Node backend when deployed) -->
    <script src="/socket.io/socket.io.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const CONFIG = {
            numPlayers: 10,
            cardWidth: 0.7, cardHeight: 1.0,
            theme: { 
                orange: 0xff8c1a, 
                gold: 0xffd700, 
                pink: 0xff99cc, 
                warmYellow: 0xffe0b3,
                purple: 0x8a2be2,
                blue: 0x0000ff
            },
            chipValue: 50
        };

        let scene, camera, renderer, controls;
        let cardsGroup, chipsGroup, tableGroup, environmentGroup, playerStacksGroup;
        let whiteSpot = null;
        let rimLight = null;
        let nebulaParticles = null;
        let starField = null;
        let tableParticles = null;
        let hudData = [];
        let currentRaiseInput = 50;
        
        const BUILD_TAG = `build-${new Date().toISOString()}`;
        const IS_MULTIPLAYER = (location.protocol !== 'file:') && (typeof window.io === 'function');
        const socket = IS_MULTIPLAYER ? window.io() : null;
        let mpWired = false;
        let pendingJoin = false;
        let joinedRoomOnce = false;
        let mySeatIdx = -1;
        let isHost = false;
        let lastRoomState = null;
        const pendingPrivateHands = new Map(); // seatIdx -> hand
        const privateHandRenderToken = new Map(); // seatIdx -> number (cancel in-flight renders)
        let lastActionSeatIdx = null;
        let rebuyPromptedForHand = null;
        let lastHandOverNum = null;
        let potChipFX = []; // meshes for bet-to-pot animation
        let matchOverReceived = false;
        let matchOverAcked = false;
        let opponentPlaceholderToken = 0;
        let lastOpponentPlaceholderHandNum = null;

        // --- SFX (WebAudio, no external assets required) ---
        const SFX = (() => {
            let ctx = null;
            let enabled = (localStorage.getItem('nebula_sfx') || 'on') === 'on';
            let lastDealAt = 0;
            let lastChipAt = 0;
            let lastTurnAt = 0;

            const ensureCtx = async () => {
                if (!enabled) return null;
                if (!ctx) {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return null;
                    ctx = new AC();
                }
                if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch (_) {}
                }
                return ctx;
            };

            const noiseBuffer = () => {
                const c = ctx;
                const buffer = c.createBuffer(1, c.sampleRate * 0.12, c.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
                return buffer;
            };

            const playDeal = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastDealAt < 55) return; // throttle
                lastDealAt = tnow;
                const c = await ensureCtx();
                if (!c) return;

                const t = c.currentTime;
                const n = c.createBufferSource();
                n.buffer = noiseBuffer();
                const bp = c.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(1800, t);
                bp.Q.setValueAtTime(1.2, t);
                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.12, t + 0.005);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
                n.connect(bp).connect(g).connect(c.destination);
                n.start(t);
                n.stop(t + 0.11);
            };

            const playChip = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastChipAt < 85) return; // throttle
                lastChipAt = tnow;
                const c = await ensureCtx();
                if (!c) return;

                const t = c.currentTime;
                // Coin/chip clink: short noise burst + resonant peaks (less "synthy")
                const n = c.createBufferSource();
                n.buffer = noiseBuffer();

                const hp = c.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.setValueAtTime(1800 + Math.random() * 400, t);
                hp.Q.setValueAtTime(0.7, t);

                const bp = c.createBiquadFilter();
                bp.type = 'bandpass';
                bp.frequency.setValueAtTime(3200 + Math.random() * 600, t);
                bp.Q.setValueAtTime(7.5, t);

                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.16, t + 0.004);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.13);

                // add a tiny resonant "ping" partial
                const o = c.createOscillator();
                o.type = 'sine';
                const og = c.createGain();
                og.gain.setValueAtTime(0.0001, t);
                og.gain.exponentialRampToValueAtTime(0.06, t + 0.004);
                og.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
                o.frequency.setValueAtTime(4200 + Math.random() * 900, t);

                n.connect(hp).connect(bp).connect(g).connect(c.destination);
                o.connect(og).connect(c.destination);

                n.start(t);
                n.stop(t + 0.14);
                o.start(t);
                o.stop(t + 0.11);
            };

            const playTurn = async () => {
                if (!enabled) return;
                const tnow = performance.now();
                if (tnow - lastTurnAt < 500) return;
                lastTurnAt = tnow;
                const c = await ensureCtx();
                if (!c) return;
                const t = c.currentTime;

                const o = c.createOscillator();
                o.type = 'sine';
                const g = c.createGain();
                g.gain.setValueAtTime(0.0001, t);
                g.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
                g.gain.exponentialRampToValueAtTime(0.0001, t + 0.22);
                o.frequency.setValueAtTime(880, t);
                o.frequency.setValueAtTime(1175, t + 0.10);
                o.connect(g).connect(c.destination);
                o.start(t);
                o.stop(t + 0.24);
            };

            const setEnabled = (on) => {
                enabled = !!on;
                localStorage.setItem('nebula_sfx', enabled ? 'on' : 'off');
            };

            // Unlock on first gesture
            const unlock = () => { ensureCtx(); };
            window.addEventListener('pointerdown', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });

            return {
                isEnabled: () => enabled,
                setEnabled,
                ensureCtx,
                deal: playDeal,
                chip: playChip,
                turn: playTurn
            };
        })();

        function dbg(msg) {
            // 只在调试阶段使用：把关键推进写到 ACTIVITY，方便你截图发我
            try { addToHistory(`[DBG] ${msg}`); } catch(_) {}
        }

        // ---- Voice (WebRTC audio) ----
        const voiceState = {
            connected: false,
            micOn: false,
            localStream: null,
            peers: new Map(), // peerSocketId -> { pc, audioEl }
            audioContainer: null
        };

        function setVoiceStatus(text) {
            const el = document.getElementById('voice-status');
            if (el) el.innerText = text;
        }

        function updateMicButton() {
            const btn = document.getElementById('mic-toggle');
            if (!btn) return;
            btn.innerText = `Mic: ${voiceState.micOn ? 'On' : 'Off'}`;
            btn.style.opacity = voiceState.connected ? '1' : '0.8';
        }

        async function ensureLocalAudioStream() {
            if (voiceState.localStream) return voiceState.localStream;
            if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia not supported');
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                },
                video: false
            });
            // Default: join voice but start muted until user enables mic
            const track = stream.getAudioTracks()[0];
            if (track) track.enabled = false;
            voiceState.localStream = stream;

            if (!voiceState.audioContainer) {
                const c = document.createElement('div');
                c.id = 'voice-audio-container';
                c.style.display = 'none';
                document.body.appendChild(c);
                voiceState.audioContainer = c;
            }
            return stream;
        }

        function closePeer(peerId) {
            const entry = voiceState.peers.get(peerId);
            if (!entry) return;
            try { entry.pc.ontrack = null; entry.pc.onicecandidate = null; } catch(_) {}
            try { entry.pc.close(); } catch(_) {}
            try { entry.audioEl?.remove?.(); } catch(_) {}
            voiceState.peers.delete(peerId);
        }

        function shouldInitiateWith(peerId) {
            // Deterministic initiator to avoid offer glare
            const myId = socket?.id || '';
            if (!myId || !peerId) return false;
            return String(myId) < String(peerId);
        }

        async function ensurePeerConnection(peerId) {
            if (!IS_MULTIPLAYER || !socket) return null;
            if (!peerId || peerId === socket.id) return null;
            if (!voiceState.localStream) return null;
            if (voiceState.peers.has(peerId)) return voiceState.peers.get(peerId).pc;

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
            });

            // add local audio
            for (const t of voiceState.localStream.getTracks()) {
                pc.addTrack(t, voiceState.localStream);
            }

            const audioEl = document.createElement('audio');
            audioEl.autoplay = true;
            audioEl.playsInline = true;
            audioEl.muted = false;
            voiceState.audioContainer?.appendChild(audioEl);

            pc.ontrack = (ev) => {
                const [stream] = ev.streams;
                if (!stream) return;
                audioEl.srcObject = stream;
                // Some browsers require a gesture; we still try.
                audioEl.play?.().catch(() => {});
            };

            pc.onicecandidate = (ev) => {
                if (!ev.candidate) return;
                socket.emit('voice_signal', { to: peerId, data: { type: 'ice', candidate: ev.candidate } });
            };

            voiceState.peers.set(peerId, { pc, audioEl });

            // initiator sends offer
            if (shouldInitiateWith(peerId)) {
                const offer = await pc.createOffer({ offerToReceiveAudio: true });
                await pc.setLocalDescription(offer);
                socket.emit('voice_signal', { to: peerId, data: { type: 'offer', sdp: pc.localDescription } });
            }

            return pc;
        }

        async function handleVoiceSignal(from, data) {
            try {
                if (!from || from === socket?.id) return;
                if (!data || typeof data.type !== 'string') return;
                const pc = await ensurePeerConnection(from);
                if (!pc) return;

                if (data.type === 'offer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                    const ans = await pc.createAnswer();
                    await pc.setLocalDescription(ans);
                    socket.emit('voice_signal', { to: from, data: { type: 'answer', sdp: pc.localDescription } });
                } else if (data.type === 'answer') {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
                } else if (data.type === 'ice') {
                    if (data.candidate) {
                        try { await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); } catch(_) {}
                    }
                }
            } catch (e) {
                console.warn('[voice] signal error', e);
            }
        }

        async function voiceJoinIfPossible() {
            if (!IS_MULTIPLAYER || !socket) return;
            if (voiceState.connected) return;
            if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) return; // must be seated
            try {
                await ensureLocalAudioStream();
                socket.emit('voice_join');
                voiceState.connected = true;
                setVoiceStatus('Voice: Connected (muted)');
                updateMicButton();
            } catch (e) {
                setVoiceStatus('Voice: Mic permission denied');
                console.warn('[voice] join failed', e);
            }
        }

        function voiceLeaveAndCleanup(stopTracks) {
            if (IS_MULTIPLAYER && socket && voiceState.connected) {
                try { socket.emit('voice_leave'); } catch(_) {}
            }
            for (const peerId of [...voiceState.peers.keys()]) closePeer(peerId);
            voiceState.connected = false;
            voiceState.micOn = false;
            if (stopTracks && voiceState.localStream) {
                try { voiceState.localStream.getTracks().forEach(t => t.stop()); } catch(_) {}
                voiceState.localStream = null;
            } else if (voiceState.localStream) {
                const tr = voiceState.localStream.getAudioTracks()[0];
                if (tr) tr.enabled = false;
            }
            setVoiceStatus('Voice: Not connected');
            updateMicButton();
        }
        
        const gameState = {
            players: [], pot: 0, dealerIdx: 0, deck: [],
            communityCards: [], round: 'WAITING', activeIdx: 0,
            currentMaxBet: 100, isGameOver: false,
            smallBlind: 50, bigBlind: 100,
            minRaise: 100,
            numActionThisRound: 0,
            currentRoundNum: 0,
            totalRounds: 5,
            initialChips: 1000,
            myPlayerIdx: -1,
            seatConfig: Array(10).fill(null), // null: Empty, 'player': YOU, 'ai': AI
            seatMeta: {}, // seatIdx -> { type, name } (multiplayer)
            isProcessing: false, // 动作锁，防止快速重复触发
            processingSince: 0,  // 记录动作锁开始时间，用于watchdog兜底
            mpInitialized: false,
            mpHandNum: 0
        };

        // 返回从 startSeatIdx 开始，向前数 offset 个“有效玩家座位”的 seatIdx（用于 SB/BB/UTG 等）
        // 有效：seatConfig 有人 + 对应 player 存在 + 未破产/仍有筹码
        function getActiveOffset(startSeatIdx, offset) {
            const getSeatPlayer = (seatIdx) => gameState.players.find(p => p.id === seatIdx);
            const isSeatEligible = (seatIdx) => {
                if(!gameState.seatConfig[seatIdx]) return false;
                const p = getSeatPlayer(seatIdx);
                if(!p) return false;
                return !p.isBankrupt && p.chips > 0;
            };

            let count = 0;
            let idx = startSeatIdx;
            let loops = 0;
            const maxLoops = CONFIG.numPlayers * 3;
            while(count < offset && loops < maxLoops) {
                idx = (idx + 1) % CONFIG.numPlayers;
                if(isSeatEligible(idx)) count++;
                loops++;
            }
            return idx;
        }

        // 全局错误捕获：如果某个 AI 动作抛异常导致逻辑中断，这里会把原因打到控制台 + ACTIVITY
        window.addEventListener('error', (e) => {
            try {
                console.error('[GLOBAL ERROR]', e?.error || e);
                addToHistory(`ERROR: ${e?.message || 'Unknown error'}`);
                gameState.isProcessing = false;
            } catch(_) {}
        });
        window.addEventListener('unhandledrejection', (e) => {
            try {
                console.error('[UNHANDLED REJECTION]', e?.reason || e);
                addToHistory(`ERROR: ${e?.reason?.message || e?.reason || 'Unhandled rejection'}`);
                gameState.isProcessing = false;
            } catch(_) {}
        });

        function init() {
            setupBase();
            setupLights();
            setupAtmosphere();
            createTable();
            // 不再直接调用 createPlayers，由选座流程控制
            setupEvents();
            // 页面右下角显示 build tag，确认你加载的是最新文件
            const buildEl = document.createElement('div');
            buildEl.id = 'build-tag';
            buildEl.style.cssText = 'position:fixed;right:10px;bottom:10px;z-index:9999;font:12px/1.2 monospace;color:rgba(255,215,0,0.7);pointer-events:none;';
            buildEl.textContent = BUILD_TAG;
            document.body.appendChild(buildEl);

            // 全局 watchdog：不依赖 checkTurn 被调用。只要锁住太久，自动解锁并推进一次。
            setInterval(() => {
                if (gameState.isGameOver) return;
                if (gameState.round === 'WAITING') return;
                if (gameState.isProcessing && (Date.now() - (gameState.processingSince || 0) > 3000)) {
                    console.warn('[WATCHDOG_INTERVAL] Force unlock + nextStep');
                    dbg('watchdog unlock');
                    gameState.isProcessing = false;
                    gameState.processingSince = 0;
                    try { nextStep(); } catch(e) { console.error('[WATCHDOG nextStep error]', e); }
                }
            }, 500);
            animate();
        }

        function wireMultiplayer() {
            if(!IS_MULTIPLAYER) return;
            if (mpWired) return;
            mpWired = true;

            // voice: handle reconnects cleanly
            socket.on('connect', () => {
                // on reconnect, socket.id changes; drop old peer state and rejoin
                try { voiceLeaveAndCleanup(false); } catch(_) {}
                voiceJoinIfPossible();
            });
            socket.on('disconnect', () => {
                try { voiceLeaveAndCleanup(false); } catch(_) {}
                setVoiceStatus('Voice: Disconnected');
            });

            socket.on('you_state', ({ seatIdx, isHost: hostFlag }) => {
                if (Number.isInteger(seatIdx) && seatIdx >= 0) {
                    mySeatIdx = seatIdx;
                    gameState.myPlayerIdx = seatIdx;
                    voiceJoinIfPossible();
                }
                if (hostFlag !== null && hostFlag !== undefined) {
                    isHost = !!hostFlag;
                }
            });

            socket.on('seat_taken', ({ seatIdx }) => {
                mySeatIdx = seatIdx;
                gameState.myPlayerIdx = seatIdx;
                voiceJoinIfPossible();
            });

            socket.on('room_state', (state) => {
                lastRoomState = state;
                joinedRoomOnce = true;
                pendingJoin = false;
                // 服务器广播时 isHost 可能为 null；这里用 hostSocketId vs 当前 socket.id 自行计算
                isHost = (state.isHost !== null && state.isHost !== undefined)
                    ? !!state.isHost
                    : (!!state.hostSocketId && !!socket?.id && state.hostSocketId === socket.id);

                // seat meta (names/types) from server
                gameState.seatMeta = {};
                (state.seats || []).forEach(s => {
                    if(!s) return;
                    gameState.seatMeta[s.seatIdx] = { type: s.type, name: s.name };
                });

                // 同步联机设置（initial chips / total hands）
                if (state.settings) {
                    if (Number.isFinite(state.settings.initialChips)) gameState.initialChips = state.settings.initialChips;
                    if (Number.isFinite(state.settings.totalHands)) gameState.totalRounds = state.settings.totalHands;
                }
                // 同步 seats 到本地 seatConfig：player/ai/null
                gameState.seatConfig = Array(CONFIG.numPlayers).fill(null);
                (state.seats || []).forEach(s => {
                    if(!s) return;
                    gameState.seatConfig[s.seatIdx] = (s.type === 'ai') ? 'ai' : 'player';
                });
                updateSeatOverlayFromServer(state);

                // 关键修复：只要服务器说 started=true，所有客户端都要进入牌桌（不只是 host）
                if (state.started) {
                    enterMultiplayerGame();
                }
            });

            socket.on('activity', (msg) => addToHistory(msg));
            socket.on('error_msg', ({msg}) => {
                alert(msg);
                // If we failed to join (e.g. room already started), return to lobby instead of getting stuck on seat screen.
                if (pendingJoin && !joinedRoomOnce) {
                    pendingJoin = false;
                    const lobby = document.getElementById('lobby-overlay');
                    const seat = document.getElementById('seat-overlay');
                    if (seat) seat.style.display = 'none';
                    if (lobby) lobby.style.display = 'flex';
                }
            });
            socket.on('room_closed', ({ roomId, reason }) => {
                // Room released after match over: return everyone to a clean lobby state.
                try { voiceLeaveAndCleanup(true); } catch(_) {}
                try { addToHistory(`Room ${roomId} closed (${reason}). Returning to lobby...`); } catch(_) {}
                setTimeout(() => location.reload(), 300);
            });
            socket.on('kicked', ({ seatIdx }) => {
                addToHistory(`You were removed from Seat ${Number(seatIdx) + 1} by host.`);
                if (mySeatIdx === seatIdx) {
                    mySeatIdx = -1;
                    gameState.myPlayerIdx = -1;
                    try { voiceLeaveAndCleanup(false); } catch(_) {}
                }
                // 让 UI 立刻回到可选座状态（server 会随后广播 room_state）
                document.getElementById('seat-overlay').style.display = 'block';
                document.getElementById('seat-overlay').style.opacity = '1';
            });

            // Rebuy flow (host approves)
            socket.on('rebuy_requested', ({ seatIdx, name, amount }) => {
                addToHistory(`${name || 'Player'} requests REBUY $${Number(amount || 0)} (Seat ${Number(seatIdx) + 1}).`);
                if (!isHost) return;
                const ok = confirm(`Rebuy request:\n\n${name || 'Player'} (Seat ${Number(seatIdx) + 1}) wants to rebuy $${Number(amount || 0)}.\n\nApprove?`);
                if (ok) {
                    try { socket.emit('rebuy_approve', { seatIdx, amount }); } catch(_) {}
                } else {
                    try { socket.emit('rebuy_deny', { seatIdx, amount }); } catch(_) {}
                }
            });
            socket.on('rebuy_denied', ({ msg }) => {
                alert(msg || 'Rebuy denied by host.');
            });

            // voice wiring
            socket.on('voice_peers', async ({ peers }) => {
                try {
                    if (!Array.isArray(peers)) return;
                    setVoiceStatus(`Voice: Connected (${peers.length} peer${peers.length === 1 ? '' : 's'})${voiceState.micOn ? '' : ' (muted)'}`);
                    for (const p of peers) {
                        if (!p?.socketId) continue;
                        await ensurePeerConnection(p.socketId);
                    }
                } catch (e) {
                    console.warn('[voice] peers error', e);
                }
            });
            socket.on('voice_peer_joined', async ({ peer }) => {
                try {
                    if (!peer?.socketId) return;
                    await ensurePeerConnection(peer.socketId);
                } catch (e) {
                    console.warn('[voice] peer joined error', e);
                }
            });
            socket.on('voice_peer_left', ({ socketId }) => {
                if (!socketId) return;
                closePeer(socketId);
            });
            socket.on('voice_signal', ({ from, data }) => {
                handleVoiceSignal(from, data);
            });

            socket.on('player_action', ({ seatIdx, text }) => {
                showPlayerActionBadge(seatIdx, text);
                // Multiplayer fold effect: disintegrate the folded player's cards
                if (String(text || '').toUpperCase().startsWith('FOLD')) {
                    const p = gameState.players.find(pp => pp.id === seatIdx);
                    if (p && !p._foldFxPlayed && (p.meshCards?.length || 0) > 0) {
                        p._foldFxPlayed = true;
                        createFoldParticles(p);
                    }
                }
                // Multiplayer chips "give" FX: when someone CALL/RAISE/ALL-IN, fly gold chips to pot
                animateBetToPot(seatIdx, text);
            });

            socket.on('hand_over', ({ handNum, totalHands, winners, desc, showdownHands }) => {
                // show a next-hand prompt
                const winNames = (winners || []).map(w => w.name).join(' & ');
                addToHistory(`--- HAND OVER ${handNum}/${totalHands}: ${winNames || 'N/A'} (${desc || ''}) ---`);

                // Pot -> winner chip push animation (multiplayer FX)
                try { animatePotToWinners(winners || []); } catch(_) {}

                // Reveal showdown hands (players who stayed to the end)
                try {
                    if (Array.isArray(showdownHands)) {
                        showdownHands.forEach(s => {
                            const seatIdx = s?.seatIdx;
                            const hand = Array.isArray(s?.hand) ? s.hand.slice(0, 2) : [];
                            if (!Number.isInteger(seatIdx) || hand.length < 2) return;
                            const p = gameState.players.find(pp => pp.id === seatIdx);
                            if (!p) return;
                            // Update stored hand
                            p.hand = hand.slice(0, 2);
                            // Reveal existing placeholder cards if present
                            if (Array.isArray(p.meshCards) && p.meshCards.length >= 2) {
                                revealCardOnMesh(p.meshCards[0], hand[0]);
                                revealCardOnMesh(p.meshCards[1], hand[1]);
                            }
                        });
                    }
                } catch (_) {}

                const btn = document.getElementById('btn-next');
                document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
                btn.style.display = 'block';
                btn.innerText = isHost ? 'Next Round' : 'Waiting for Host';
                btn.disabled = !isHost;
                lastHandOverNum = handNum;
            });

            socket.on('match_over', ({ totalHands, scheduledHands, playedHands, standings, hands }) => {
                matchOverReceived = true;

                // Show final results (all hands + final chip standings)
                const modal = document.getElementById('summary-modal');
                const title = modal?.querySelector?.('h2');
                if (title) title.innerText = 'MATCH OVER';

                const list = document.getElementById('summary-list-content');
                if (list) {
                    const safeStandings = Array.isArray(standings) ? standings : [];
                    const safeHands = Array.isArray(hands) ? hands : [];
                    list.innerHTML = "";

                    const sec1 = document.createElement('div');
                    sec1.style.cssText = 'text-align:left;margin-bottom:14px;color:rgba(212,175,55,0.8);font-weight:bold;';
                    sec1.innerText = 'Final Standings';
                    list.appendChild(sec1);

                    safeStandings.forEach((p, idx) => {
                        const div = document.createElement('div');
                        div.className = 'summary-item';
                        const buyIn = Number.isFinite(Number(p.buyInTotal)) ? Number(p.buyInTotal)
                                    : (Number.isFinite(Number(p.buyIn)) ? Number(p.buyIn)
                                    : (Number.isFinite(Number(p.totalBuyIn)) ? Number(p.totalBuyIn) : 0));
                        const net = Number.isFinite(Number(p.net)) ? Number(p.net) : (Number(p.chips || 0) - buyIn);
                        const netColor = net >= 0 ? '#00ff88' : '#ff6677';
                        const netSign = net >= 0 ? '+' : '-';
                        div.innerHTML = `
                            <span style="color:#fff;flex:1;">${idx + 1}. ${p.name || 'Player'} (ID:${p.seatIdx})</span>
                            <span style="min-width:120px; text-align:right; opacity:0.9;">本金 $${buyIn}</span>
                            <span style="min-width:120px; text-align:right;"><b>剩余 $${Number(p.chips || 0)}</b></span>
                            <span style="min-width:120px; text-align:right; color:${netColor}; font-weight:bold;">${net >= 0 ? '赚' : '亏'} $${Math.abs(net)}</span>
                        `;
                        list.appendChild(div);
                    });

                    const spacer = document.createElement('div');
                    spacer.style.height = '14px';
                    list.appendChild(spacer);

                    const sec2 = document.createElement('div');
                    sec2.style.cssText = 'text-align:left;margin-bottom:10px;color:rgba(212,175,55,0.8);font-weight:bold;';
                    const sched = Number.isFinite(Number(scheduledHands)) ? Number(scheduledHands) : Number(totalHands || safeHands.length);
                    const played = Number.isFinite(Number(playedHands)) ? Number(playedHands) : safeHands.length;
                    sec2.innerText = `Hand Results (${played}/${sched})`;
                    list.appendChild(sec2);

                    safeHands.sort((a,b) => (a.handNum||0)-(b.handNum||0)).forEach(h => {
                        const winners = Array.isArray(h.winners) ? h.winners : [];
                        const winNames = winners.map(w => w.name).join(' & ') || 'N/A';
                        const row = document.createElement('div');
                        row.style.cssText = 'text-align:left; font-size: 0.9em; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.06);';
                        row.innerHTML = `<span style="color:#fff;opacity:0.9;">Hand ${h.handNum || ''}:</span> <span style="color:gold;">${winNames}</span> <span style="opacity:0.75;">(${h.desc || ''})</span>`;
                        list.appendChild(row);
                    });
                }

                // Disable game controls and show summary
                document.querySelectorAll('#controls button').forEach(b => b.disabled = true);
                if (modal) modal.style.display = 'block';
                setVoiceStatus('Voice: Connected'); // keep voice; users can still talk during summary

                // Manual confirm: only when user clicks do we ACK + leave (disconnect counts as offline)
                const confirmBtn = document.getElementById('summary-confirm-btn');
                if (confirmBtn) {
                    confirmBtn.onclick = () => {
                        if (IS_MULTIPLAYER && socket && !matchOverAcked) {
                            matchOverAcked = true;
                            try { socket.emit('ack_match_over'); } catch(_) {}
                            try { voiceLeaveAndCleanup(true); } catch(_) {}
                            try { socket.disconnect(); } catch(_) {}
                        }
                        // Return to main/lobby
                        try { location.reload(); } catch(_) {}
                    };
                }
            });

            socket.on('private_hand', ({ seatIdx, hand }) => {
                // 只会发给自己；但可能比 createPlayers 更早到达，先缓存
                const safeHand = Array.isArray(hand) ? hand.slice(0, 2) : [];
                pendingPrivateHands.set(seatIdx, safeHand);
                applyPrivateHandIfReady(seatIdx);
            });

            socket.on('game_state', (s) => {
                // Your-turn beep: detect transition into "my turn" (avoid repeat beeps)
                const wasMyTurn = !!gameState._myTurn;
                // 服务器开启后，确保所有人都进入牌桌
                if (s.started) {
                    enterMultiplayerGame();
                }
                if (s.settings) {
                    if (Number.isFinite(s.settings.initialChips)) gameState.initialChips = s.settings.initialChips;
                    if (Number.isFinite(s.settings.totalHands)) gameState.totalRounds = s.settings.totalHands;
                }
                // 只做 UI/渲染同步（逻辑以服务端为准）
                gameState.round = s.round;
                gameState.pot = s.pot;
                gameState.currentMaxBet = s.currentMaxBet;
                if (Number.isFinite(s.minRaise)) {
                    gameState.minRaise = s.minRaise;
                    if (currentRaiseInput < gameState.minRaise) currentRaiseInput = gameState.minRaise;
                }
                document.getElementById('game-msg').innerText = `${s.round}: ${(s.activeSeatIdx !== null && s.activeSeatIdx !== undefined) ? (s.players.find(p=>p.seatIdx===s.activeSeatIdx)?.name || '...') : ''}`;
                // 小提示：如果你没成功入座，按钮永远不会亮（避免“被跳过”的困惑）
                if (IS_MULTIPLAYER && mySeatIdx === -1) {
                    document.getElementById('game-msg').innerText = `${s.round}: Spectator (pick a seat before start)`;
                }
                // 控制区显示逻辑（联机）：HAND_OVER 才显示 Next Round；否则显示常规按钮并根据 activeSeatIdx 开关
                const btnNext = document.getElementById('btn-next');
                const btnCheck = document.getElementById('btn-check');
                const btnRebuy = document.getElementById('btn-rebuy');
                if (s.round === 'HAND_OVER') {
                    document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
                    btnNext.style.display = 'block';
                    btnNext.innerText = isHost ? 'Next Round' : 'Waiting for Host';
                    btnNext.disabled = !isHost;
                    toggleButtons(false);
                } else {
                    btnNext.style.display = 'none';
                    document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'block');
                    if (s.activeSeatIdx !== null && s.activeSeatIdx !== undefined) {
                        toggleButtons(s.activeSeatIdx === mySeatIdx);
                    } else {
                        toggleButtons(false);
                    }
                }
                try {
                    const nowMyTurn = (s.activeSeatIdx === mySeatIdx) && (s.round !== 'HAND_OVER') && (s.round !== 'WAITING');
                    gameState._myTurn = nowMyTurn;
                    if (!wasMyTurn && nowMyTurn) {
                        SFX.turn();
                    }
                } catch (_) {}

                // PokerNow-like: show exact Check/Call amount
                try {
                    const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                    const maxBet = Number(s.currentMaxBet || 0);
                    const myBet = meS ? Number(meS.currentBet || 0) : 0;
                    const myChips = meS ? Number(meS.chips || 0) : 0;
                    const toCall = meS ? Math.max(0, maxBet - myBet) : 0;
                    const callPay = Math.max(0, Math.min(toCall, myChips));
                    // Buttons: first bettor sees "Bet"; others see unified "Call/Raise".
                    if (btnCheck) {
                        btnCheck.innerText = 'Check';
                        btnCheck.style.display = (toCall > 0) ? 'none' : 'block';
                    }
                    const btnRaise = document.getElementById('btn-raise');
                    if (btnRaise) {
                        if (toCall > 0) {
                            const extra = Number(currentRaiseInput || 0);
                            btnRaise.innerText = (extra <= 0)
                                ? `Call $${callPay}${(myChips > 0 && myChips < toCall) ? ' (All-in)' : ''}`
                                : `Raise +$${extra}`;
                        } else {
                            const betAmt = Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0) || 0);
                            btnRaise.innerText = `Bet $${betAmt}`;
                        }
                    }
                } catch (_) {}

                // Rebuy button: only for seated players who are busted, between hands
                try {
                    if (btnRebuy) {
                        const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                        const busted = !!meS && Number(meS.chips || 0) <= 0;
                        const betweenHands = (s.round === 'HAND_OVER' || s.round === 'WAITING');
                        btnRebuy.style.display = (IS_MULTIPLAYER && busted && betweenHands && !matchOverReceived) ? 'block' : 'none';
                        btnRebuy.disabled = !(IS_MULTIPLAYER && busted && betweenHands);
                    }
                } catch (_) {}

                // Auto prompt: if you are busted between hands, ask whether to rebuy and rejoin next hand
                try {
                    if (IS_MULTIPLAYER && !matchOverReceived) {
                        const meS = (s.players || []).find(pp => pp.seatIdx === mySeatIdx);
                        const busted = !!meS && Number(meS.chips || 0) <= 0;
                        const betweenHands = (s.round === 'HAND_OVER' || s.round === 'WAITING');
                        const handKey = `${s.handNum || 0}:${s.round || ''}`;
                        if (busted && betweenHands && rebuyPromptedForHand !== handKey) {
                            rebuyPromptedForHand = handKey;
                            setTimeout(() => {
                                const ok = confirm('You are out of chips.\n\nRebuy to re-enter next hand?');
                                if (!ok) return;
                                const def = Number.isFinite(Number(gameState.initialChips)) ? Number(gameState.initialChips) : 1000;
                                const raw = prompt('Rebuy amount (>=1000 and multiple of 50):', String(def));
                                if (raw === null) return;
                                const amt = Number(raw);
                                if (!Number.isFinite(amt) || amt < 1000 || (amt % 50) !== 0) {
                                    alert('Rebuy amount must be >=1000 and a multiple of 50.');
                                    return;
                                }
                                try { socket.emit('rebuy', { amount: amt }); } catch(_) {}
                                addToHistory(`Rebuy: $${amt} (applies next hand)`);
                            }, 50);
                        }
                    }
                } catch (_) {}
                // 同步玩家筹码/弃牌
                (s.players || []).forEach(sp => {
                    const p = gameState.players.find(pp => pp.id === sp.seatIdx);
                    if(!p) return;
                    p.chips = sp.chips;
                    p.currentBet = sp.currentBet;
                    p.isFolded = sp.isFolded;
                    p.isBankrupt = sp.isBankrupt;
                });
                updateUI();

                // SB/BB badges
                try {
                    const sb = s.sbSeatIdx;
                    const bb = s.bbSeatIdx;
                    gameState.players.forEach(pp => {
                        const el = document.getElementById(`blind-${pp.id}`);
                        if (!el) return;
                        if (Number.isInteger(sb) && pp.id === sb) {
                            el.innerText = 'SB';
                            el.style.display = 'inline-block';
                        } else if (Number.isInteger(bb) && pp.id === bb) {
                            el.innerText = 'BB';
                            el.style.display = 'inline-block';
                        } else {
                            el.style.display = 'none';
                        }
                    });
                } catch (_) {}

                // 新的一手：先清理旧桌面，再渲染本手的公共牌/手牌占位
                if (gameState.mpHandNum !== s.handNum) {
                    gameState.mpHandNum = s.handNum;
                    lastHandOverNum = null;
                    // 清空桌面牌与下注筹码
                    while(cardsGroup.children.length > 0) cardsGroup.remove(cardsGroup.children[0]);
                    while(chipsGroup.children.length > 0) chipsGroup.remove(chipsGroup.children[0]);
                    potChipFX = [];
                    gameState.communityCards = [];
                    // 清掉每位玩家手牌 mesh（自己的牌会通过 private_hand 重发）
                    gameState.players.forEach(p => {
                        (p.meshCards || []).forEach(m => cardsGroup.remove(m));
                        p.meshCards = [];
                        p.hand = [];
                        p.currentBet = 0;
                        p._foldFxPlayed = false;
                    });

                    // 给其他玩家发两张背面占位牌（仅在我已确定座位后）
                    if (mySeatIdx !== -1) dealOpponentPlaceholders(s.handNum);

                    // 如果我的私牌已经缓存到了，现在应用
                    if (mySeatIdx !== -1) applyPrivateHandIfReady(mySeatIdx);
                }

                // 同步公共牌：只补差量（最多 5 张）
                const target = Array.isArray(s.communityCards) ? s.communityCards.slice(0, 5) : [];
                while(gameState.communityCards.length < target.length) {
                    const card = target[gameState.communityCards.length];
                    gameState.communityCards.push(card);
                    // 直接在桌面渲染一张（不走本地逻辑）
                    const mesh = createCardMesh(card, true);
                    const finalX = (gameState.communityCards.length-3)*0.9;
                    mesh.position.set(finalX, 5, 0);
                    cardsGroup.add(mesh);
                    orientCardTowardViewer(mesh, mySeatIdx);
                    gsap.to(mesh.position, {y: 0.18, duration: 0.5, ease: "power2.out"});
                }
            });

            socket.on('turn', ({ activeSeatIdx }) => {
                // 轮到我则开按钮，否则关
                toggleButtons(activeSeatIdx === mySeatIdx);
            });
        }

        function enterMultiplayerGame() {
            // 只初始化一次
            if (gameState.mpInitialized) {
                // 隐藏选座层，避免挡住牌桌
                const seatOverlay = document.getElementById('seat-overlay');
                if (seatOverlay) seatOverlay.style.display = 'none';
                return;
            }
            // 进入牌桌：隐藏选座层 + 创建玩家
            const seatOverlay = document.getElementById('seat-overlay');
            if (seatOverlay) seatOverlay.style.display = 'none';

            // 如果还没创建过玩家，先创建
            createPlayers();
            gameState.mpInitialized = true;

            // 进入后如果我的私牌已缓存，立刻渲染
            if (mySeatIdx !== -1) applyPrivateHandIfReady(mySeatIdx);
        }

        function applyPrivateHandIfReady(seatIdx) {
            const hand = pendingPrivateHands.get(seatIdx);
            if (!hand) return;
            const me = gameState.players.find(p => p.id === seatIdx);
            if(!me) return;

            // cancel any in-flight render for this seat
            const token = (privateHandRenderToken.get(seatIdx) || 0) + 1;
            privateHandRenderToken.set(seatIdx, token);

            // 清掉背面占位牌
            (me.meshCards || []).forEach(m => cardsGroup.remove(m));
            me.meshCards = [];
            me.hand = [];

            // 顺序发两张正面牌（确保 hand.length 用于扇形偏移）
            const safeHand = Array.isArray(hand) ? hand.slice(0, 2) : [];
            (async () => {
                for (const card of safeHand) {
                    // if a newer render started, stop this one
                    if (privateHandRenderToken.get(seatIdx) !== token) return;
                    me.hand.push(card);
                    // eslint-disable-next-line no-await-in-loop
                    await dealCardAnim(card, me, true);
                    // slow down slightly for premium feel (multiplayer)
                    if (IS_MULTIPLAYER) await new Promise(r => setTimeout(r, 140));
                }
            })();
        }

        async function dealOpponentPlaceholders(handNum) {
            // cancel any in-flight placeholder dealing
            const token = (opponentPlaceholderToken || 0) + 1;
            opponentPlaceholderToken = token;

            // avoid re-dealing placeholders multiple times for the same hand
            if (Number.isFinite(Number(handNum)) && lastOpponentPlaceholderHandNum === handNum) return;
            lastOpponentPlaceholderHandNum = Number.isFinite(Number(handNum)) ? handNum : lastOpponentPlaceholderHandNum;

            gameState.players.forEach((p) => {
                if (p.id === mySeatIdx) return;
                // 确保每个对手只有两张背面占位牌
                p.hand = [];
                (p.meshCards || []).forEach(m => cardsGroup.remove(m));
                p.meshCards = [];
            });
            // 顺序发牌（避免“一瞬间全发完”的感觉）
            for (const p of gameState.players) {
                if (p.id === mySeatIdx) continue;
                // 输光/破产的玩家不发牌（符合“下一把不给他发牌”的观感）
                if (Number(p.chips || 0) <= 0 || p.isBankrupt) continue;
                for (let k = 0; k < 2; k++) {
                    if (opponentPlaceholderToken !== token) return;
                    const dummy = { s: 'spades', r: 'A', v: 12 }; // 每张都用独立对象
                    p.hand.push(dummy);
                    // eslint-disable-next-line no-await-in-loop
                    await dealCardAnim(dummy, p, false);
                    // if a newer placeholder render started, cleanup the last mesh we just added
                    if (opponentPlaceholderToken !== token) {
                        try {
                            const last = (p.meshCards || []).pop();
                            if (last) cardsGroup.remove(last);
                        } catch(_) {}
                        return;
                    }
                    // eslint-disable-next-line no-await-in-loop
                    if (IS_MULTIPLAYER) await new Promise(r => setTimeout(r, 120));
                }
            }
        }

        function showPlayerActionBadge(seatIdx, text) {
            // 只显示上一家动作：新动作来时清掉旧的
            if (lastActionSeatIdx !== null && lastActionSeatIdx !== undefined) {
                const old = document.getElementById(`action-${lastActionSeatIdx}`);
                if (old) old.style.display = 'none';
            }
            lastActionSeatIdx = seatIdx;
            const el = document.getElementById(`action-${seatIdx}`);
            if (!el) return;
            el.innerText = text;
            el.style.display = 'block';
        }

        function animateBetToPot(seatIdx, text) {
            if (!IS_MULTIPLAYER) return;
            const upper = String(text || '').toUpperCase();
            if (!(upper.startsWith('CALL') || upper.startsWith('RAISE') || upper.startsWith('ALL-IN'))) return;

            const p = gameState.players.find(pp => pp.id === seatIdx);
            if (!p || !p.pos) return;

            try { SFX.chip(); } catch (_) {}

            // parse amount (optional)
            const m = String(text || '').match(/(\d+)/);
            const amt = m ? Number(m[1]) : 50;
            const chipCount = Math.max(1, Math.min(6, Math.floor((Number.isFinite(amt) ? amt : 50) / 50)));

            for (let i = 0; i < chipCount; i++) {
                const chip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                    getChipMaterial().clone()
                );
                chip.material.transparent = true;
                chip.material.opacity = 0.7;
                chip.position.set(p.pos.x, 0.08, p.pos.z);
                // 让筹码“平躺”在桌面（和离线一致）：Cylinder 默认就是平躺（圆面朝上）
                chip.rotation.set(0, p.angle || 0, 0); // keep label oriented to that seat
                chipsGroup.add(chip);
                potChipFX.push(chip);

                const tx = (Math.random() - 0.5) * 0.8;
                const tz = (Math.random() - 0.5) * 0.8;
                gsap.to(chip.position, {
                    x: tx,
                    z: tz,
                    y: 0.05,
                    duration: 0.65 + Math.random() * 0.15,
                    ease: "power2.out"
                });
                gsap.to(chip.material, {
                    opacity: 0.55,
                    duration: 0.65,
                    ease: "power1.out"
                });
            }
        }

        function animatePotToWinners(winners) {
            if (!IS_MULTIPLAYER) return;
            if (!Array.isArray(winners) || winners.length === 0) return;
            if (!potChipFX || potChipFX.length === 0) return;

            try { SFX.chip(); } catch (_) {}

            const winnerSeats = winners.map(w => w.seatIdx).filter(s => Number.isInteger(s));
            if (winnerSeats.length === 0) return;

            // move existing pot FX chips to winners (split)
            potChipFX.forEach((chip, i) => {
                const seatIdx = winnerSeats[i % winnerSeats.length];
                const p = gameState.players.find(pp => pp.id === seatIdx);
                if (!p) return;
                const wx = p.pos.x + (Math.random() - 0.5) * 0.7;
                const wz = p.pos.z + (Math.random() - 0.5) * 0.7;
                gsap.to(chip.position, {
                    x: wx,
                    z: wz,
                    y: 0.05,
                    duration: 1.0,
                    ease: "power2.inOut"
                });
                gsap.to(chip.material, {
                    opacity: 0.0,
                    duration: 1.05,
                    ease: "power1.inOut",
                    onComplete: () => {
                        try { chipsGroup.remove(chip); } catch(_) {}
                    }
                });
            });

            // clear list after animation window
            setTimeout(() => { potChipFX = []; }, 1200);
        }

        function setupBase() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x080401);
            scene.fog = new THREE.FogExp2(0x080401, 0.02);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 11, 15);
            camera.lookAt(0, 0, 0);
            // alpha:true so light-mode can show the CSS casino background behind the 3D scene
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.setClearColor(0x000000, 1);
            document.getElementById('container').appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            cardsGroup = new THREE.Group();
            chipsGroup = new THREE.Group();
            tableGroup = new THREE.Group();
            environmentGroup = new THREE.Group();
            playerStacksGroup = new THREE.Group();
            scene.add(cardsGroup, chipsGroup, tableGroup, environmentGroup, playerStacksGroup);
        }

        function setupLights() {
            // 基础暗光
            scene.add(new THREE.AmbientLight(0xffffff, 0.05));
            
            // 强力垂直白色聚光灯 - 产生高级感反光
            whiteSpot = new THREE.SpotLight(0xffffff, 100);
            whiteSpot.position.set(0, 12, 0);
            whiteSpot.angle = Math.PI / 6;
            whiteSpot.penumbra = 0.65;
            whiteSpot.decay = 1.35;
            whiteSpot.distance = 60;
            // 更柔和、垂直落在桌面中心（避免“歪的/黑斑”观感）
            whiteSpot.target.position.set(0, 0, 0);
            scene.add(whiteSpot.target);
            scene.add(whiteSpot);
            
            // 辅助点光源增加中心高光
            rimLight = new THREE.PointLight(0xffffff, 10, 10);
            rimLight.position.set(0, 5, 0);
            scene.add(rimLight);

            // initial adapt for default table size
            updateTableLights(7.0);
        }

        function updateTableLights(tableRadius) {
            // Make spotlight cover the full table regardless of radius (3-10 players)
            if (!whiteSpot) return;
            const r = Math.max(3.5, Math.min(9.0, Number(tableRadius || 7.0)));

            // Choose a height that keeps the cone wide enough without blowing out the center
            const h = Math.max(9.5, r * 2.05);
            whiteSpot.position.set(0, h, 0);
            whiteSpot.target.position.set(0, 0, 0);

            // Cover slightly beyond table edge so rim stays lit
            const cover = r * 1.25;
            const ang = Math.atan2(cover, h); // half-angle needed
            whiteSpot.angle = Math.max(0.28, Math.min(1.05, ang));

            // Distance: far enough to include the full cone + a bit
            whiteSpot.distance = Math.max(30, h * 4.0);
            whiteSpot.penumbra = 0.7;

            // Intensity scaling: bigger tables need more light, but keep it stable
            const base = 75;
            const scale = (r / 7.0);
            whiteSpot.intensity = base * (0.85 + 0.35 * scale);

            // Gentle fill near center so cards/chips read well
            if (rimLight) {
                rimLight.position.set(0, Math.max(3.8, h * 0.42), 0);
                rimLight.distance = Math.max(10, r * 3.2);
                rimLight.intensity = 7.5 * (0.9 + 0.3 * scale);
            }
        }

        function setupAtmosphere() {
            // 夜间更梦幻：两层星海（超细密 + 亮点缀）
            const group = new THREE.Group();

            const colorPaleGold = new THREE.Color(0xd4af37).convertSRGBToLinear();
            const colorSoftWhite = new THREE.Color(0xfffdf0).convertSRGBToLinear();

            // Layer A: very fine dense stars
            {
                const count = 26000;
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            for(let i=0; i<count; i++) {
                    const r = 14 + Math.random() * 46;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i*3+2] = r * Math.cos(phi);

                    const c = colorPaleGold.clone().lerp(colorSoftWhite, Math.random() * 0.45);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.065,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.55,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                group.add(new THREE.Points(geo, mat));
            }

            // Layer B: brighter sparkle accents
            {
                const count = 4200;
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                for(let i=0; i<count; i++) {
                    const r = 12 + Math.random() * 42;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    pos[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i*3+2] = r * Math.cos(phi);

                    const c = colorSoftWhite.clone().lerp(colorPaleGold, Math.random() * 0.25);
                    colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({
                    size: 0.14,
                    sizeAttenuation: true,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.22,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                group.add(new THREE.Points(geo, mat));
            }

            starField = group;
            environmentGroup.add(starField);
        }

        function getDynamicTableRadius(numActive) {
            const n = Math.max(3, Math.min(10, Number(numActive || 10)));
            // 3人更紧凑，10人更宽松（线性插值）
            const t = (n - 3) / (10 - 3);
            return 5.6 + t * (7.0 - 5.6);
        }

        function rebuildTable(radius) {
            // clear old table geometry
            while (tableGroup.children.length > 0) tableGroup.remove(tableGroup.children[0]);
            tableParticles = null;
            createTable(radius);
            try { updateTableLights(radius); } catch (_) {}
        }

        function createTable(radiusOverride) {
            // 具有厚度的实体金属牌桌 + 绿色底面
            const radius = Number.isFinite(Number(radiusOverride)) ? Number(radiusOverride) : 7.0;
            const thickness = 0.8;
            
            // 1. 桌面主体 (金属边框/侧面)
            const tableGeo = new THREE.CylinderGeometry(radius, radius, thickness, 64);
            const tableMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111,
                metalness: 1.0,
                roughness: 0.1,
                envMapIntensity: 1.5
            });
            const tableMesh = new THREE.Mesh(tableGeo, tableMat);
            tableMesh.position.y = -thickness / 2;
            tableGroup.add(tableMesh);

            // 1.5 桌边“嵌入式灯带”：用贴合桌面的发光 Ring 来模拟“嵌在桌子里的灯槽”，避免与筹码穿模
            const grooveOuter = radius * 0.965;
            const grooveInner = radius * 0.92;
            const groove = new THREE.Mesh(
                new THREE.RingGeometry(grooveInner, grooveOuter, 128),
                new THREE.MeshStandardMaterial({
                    color: 0x101010,
                    emissive: 0xffe0a6,
                    emissiveIntensity: 1.25,
                    roughness: 0.65,
                    metalness: 0.05,
                    transparent: true,
                    opacity: 0.62,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: -2,
                    polygonOffsetUnits: -2
                })
            );
            groove.rotation.x = -Math.PI / 2;
            groove.position.y = 0.002; // slightly recessed
            tableGroup.add(groove);

            // dark lip above the groove to sell "embedded" look
            const lip = new THREE.Mesh(
                new THREE.RingGeometry(radius * 0.90, grooveInner, 128),
                new THREE.MeshStandardMaterial({
                    color: 0x070707,
                    roughness: 0.9,
                    metalness: 0.1,
                    side: THREE.DoubleSide,
                    polygonOffset: true,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: -1
                })
            );
            lip.rotation.x = -Math.PI / 2;
            lip.position.y = 0.006;
            tableGroup.add(lip);

            // 2. 桌面中心的绿色丝绒底
            const feltGeo = new THREE.CircleGeometry(radius * 0.95, 64);
            const feltMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a2a0a, // 深绿色
                roughness: 0.8,
                metalness: 0.2,
                emissive: 0x051505, // 微微发绿光
                emissiveIntensity: 0.5
            });
            const felt = new THREE.Mesh(feltGeo, feltMat);
            felt.rotation.x = -Math.PI/2;
            felt.position.y = 0.005; // 略高于金属桌面
            tableGroup.add(felt);

            // 3. 装饰粒子
            const particleCount = 8000;
            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount; i++) {
                const r = Math.sqrt(Math.random()) * radius;
                const angle = Math.random() * Math.PI * 2;
                pPos[i*3] = Math.cos(angle) * r;
                pPos[i*3+1] = 0.02;
                pPos[i*3+2] = Math.sin(angle) * r;
            }
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({ color: 0xd4af37, size: 0.015, transparent: true, opacity: 0.25 });
            tableParticles = new THREE.Points(pGeo, pMat);
            tableGroup.add(tableParticles);
        }

        function createPlayers() {
            const container = document.getElementById('labels-container');
            gameState.players = [];
            hudData = []; // 清空 HUD
            while(container.firstChild) container.removeChild(container.firstChild);
            while(playerStacksGroup.children.length > 0) playerStacksGroup.remove(playerStacksGroup.children[0]);

            // 1. 过滤出被占用的座位，保持原本的物理顺序
            const occupied = [];
            for (let i = 0; i < CONFIG.numPlayers; i++) {
                if (gameState.seatConfig[i]) {
                    const meta = gameState.seatMeta?.[i];
                    const type = gameState.seatConfig[i];
                    const name = meta?.name || (type === 'ai' ? `AI-${i}` : `Player-${i}`);
                    occupied.push({ seatIdx: i, type, name });
                }
            }

            const totalActive = occupied.length;
            if (totalActive === 0) return;

            // 根据人数动态调整桌子/围坐半径，保证少人时更紧凑、更易看清牌桌
            const tableRadius = getDynamicTableRadius(totalActive);
            const seatRadius = Math.max(4.4, tableRadius - 1.1);
            try { rebuildTable(tableRadius); } catch (_) {}

            // 2. 找到“我”在被占用座位中的顺序索引
            let myOrderIdx = occupied.findIndex(s => s.seatIdx === gameState.myPlayerIdx);
            if (myOrderIdx < 0) myOrderIdx = 0;

            // 3. 根据活跃人数均匀分配角度，并以“我”为中心
            occupied.forEach((seat, orderIdx) => {
                const relativeIdx = (orderIdx - myOrderIdx + totalActive) % totalActive;
                const visualAngle = (relativeIdx / totalActive) * Math.PI * 2;
                const pos = new THREE.Vector3(Math.sin(visualAngle) * seatRadius, 0.05, Math.cos(visualAngle) * seatRadius);
                
                const stackGroup = new THREE.Group();
                stackGroup.position.copy(pos);
                stackGroup.position.add(new THREE.Vector3(Math.sin(visualAngle)*0.85, 0, Math.cos(visualAngle)*0.85));
                playerStacksGroup.add(stackGroup);

                let pName = seat.name || (seat.type === 'ai' ? `AI-${seat.seatIdx}` : `Player-${seat.seatIdx}`);
                if (seat.type === 'player' && seat.seatIdx === gameState.myPlayerIdx) pName = "YOU";
                let pChips = gameState.initialChips;

                const playerObj = { 
                    id: seat.seatIdx, // 逻辑上的座位ID
                    name: pName, 
                    chips: pChips, currentBet: 0, pos: pos, 
                    angle: visualAngle, hand: [], isFolded: false, 
                    meshCards: [], stackGroup: stackGroup,
                    isBankrupt: false,
                    isAI: seat.type === 'ai'
                };
                gameState.players.push(playerObj);
                
                const hud = document.createElement('div');
                hud.className = 'player-hud';
                // 在 HUD 中显示玩家 ID 和名字
                hud.innerHTML = `
                    <div style="font-size: 10px; opacity: 0.6; color: gold;">ID: ${seat.seatIdx}</div>
                    <div style="color: white; font-weight: bold; display:flex; align-items:center; justify-content:center; gap:6px;">
                        <span>${pName}</span>
                        <span id="blind-${seat.seatIdx}" style="display:none; font-size:10px; font-weight:900; padding:2px 6px; border-radius:10px; border:1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.35); color:#fff; letter-spacing:0.5px;">BB</span>
                    </div>
                    <div id="chips-${seat.seatIdx}" class="chip-display">$${pChips}</div>
                    <div id="action-${seat.seatIdx}" style="display:none; margin-top:6px; text-align:center; font-size:11px; color:#d4af37; letter-spacing:1px;">ACTION</div>
                `;
                container.appendChild(hud);
                hudData.push({ el: hud, pos: pos.clone().add(new THREE.Vector3(0, 1.5, 0)), seatIdx: seat.seatIdx });
                
                updatePlayerStackMesh(playerObj);
            });
        }

        function updatePlayerStackMesh(player) {
            const group = player.stackGroup;
            // Avoid flicker: only rebuild stack meshes when chip count actually changed
            if (player._lastStackChips === player.chips) return;
            player._lastStackChips = player.chips;
            while(group.children.length > 0) group.remove(group.children[0]);
            
            let totalChipCount = Math.floor(player.chips / CONFIG.chipValue);
            if (player.chips > 0 && totalChipCount === 0) totalChipCount = 1;
            
            const maxPerStack = 10;
            const numStacks = Math.ceil(totalChipCount / maxPerStack);
            
            let remaining = totalChipCount;
            for(let s=0; s<numStacks; s++) {
                const countInStack = Math.min(remaining, maxPerStack);
                remaining -= countInStack;

                const stackOffset = (s - (numStacks-1)/2) * 0.45;
                const ox = Math.cos(player.angle) * stackOffset;
                const oz = -Math.sin(player.angle) * stackOffset;
                
                for(let j=0; j<countInStack; j++) {
                    const chipGroup = new THREE.Group();
                    // slight physical jitter to avoid z-fighting shimmer while keeping stacked look
                    const jx = (Math.random() - 0.5) * 0.012;
                    const jz = (Math.random() - 0.5) * 0.012;
                    chipGroup.position.set(ox + jx, j * 0.055, oz + jz);
                    // Orient chip label ("50") to face the seat direction
                    chipGroup.rotation.y = player.angle;
                    
                    // Bright solid chip with texture (PokerNow-like readability)
                    const chipBody = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                        getChipMaterial()
                    );
                    chipGroup.add(chipBody);
                    
                    group.add(chipGroup);
                }
            }
        }

        let _chipMatCached = null;
        function getChipMaterial() {
            if (_chipMatCached) return _chipMatCached;
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;

            // base (blue chip)
            const g = ctx.createRadialGradient(W/2, H/2, 12, W/2, H/2, W/2);
            g.addColorStop(0, '#f2f8ff');
            g.addColorStop(0.28, '#bfe2ff');
            g.addColorStop(0.62, '#1b78d6');
            g.addColorStop(1, '#083a77');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,W,H);

            // rings
            ctx.strokeStyle = 'rgba(3, 20, 45, 0.45)';
            ctx.lineWidth = 10;
            ctx.beginPath(); ctx.arc(W/2, H/2, 104, 0, Math.PI*2); ctx.stroke();
            ctx.lineWidth = 6;
            ctx.beginPath(); ctx.arc(W/2, H/2, 70, 0, Math.PI*2); ctx.stroke();

            // edge ticks (chip stripes)
            ctx.save();
            ctx.translate(W/2, H/2);
            for (let i = 0; i < 24; i++) {
                ctx.rotate((Math.PI*2)/24);
                ctx.fillStyle = (i % 2 === 0) ? 'rgba(255,255,255,0.78)' : 'rgba(10, 35, 85, 0.22)';
                ctx.fillRect(88, -8, 24, 16);
            }
            ctx.restore();

            // center plate for value text (keeps "50" readable)
            ctx.fillStyle = 'rgba(255,255,255,0.28)';
            ctx.beginPath();
            ctx.arc(W/2, H/2, 50, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.22)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(W/2, H/2, 50, 0, Math.PI*2);
            ctx.stroke();

            // value text
            ctx.fillStyle = 'rgba(0,0,0,0.92)';
            ctx.font = '900 78px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('50', W/2, H/2 + 3);

            // micro speckles for texture
            for (let i = 0; i < 1200; i++) {
                const x = Math.random()*W, y = Math.random()*H;
                const a = Math.random() < 0.04 ? 0.35 : 0.08;
                ctx.fillStyle = Math.random() < 0.52 ? `rgba(255,255,255,${a})` : `rgba(0,15,40,${a})`;
                ctx.fillRect(x, y, 1, 1);
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.anisotropy = 8;
            tex.needsUpdate = true;

            _chipMatCached = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                map: tex,
                roughness: 0.46,
                metalness: 0.03,
                emissive: 0x7ec3ff,
                emissiveIntensity: 0.045
            });
            return _chipMatCached;
        }

        async function startNewHand() {
            if(gameState.currentRoundNum >= gameState.totalRounds) {
                showFinalSummary();
                return;
            }
            // 检查剩余有钱的玩家
            const activeCount = gameState.players.filter(p => p.chips > 0).length;
            if (activeCount < 2) {
                alert("Game Over! Not enough players with chips.");
                showFinalSummary();
                return;
            }

            gameState.currentRoundNum++;
            
            // 物理级销毁旧物体
            while(cardsGroup.children.length > 0) cardsGroup.remove(cardsGroup.children[0]);
            while(chipsGroup.children.length > 0) chipsGroup.remove(chipsGroup.children[0]);
            
            gameState.deck = [];
            const rks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
            const sts = ['hearts', 'diamonds', 'clubs', 'spades'];
            for(let s of sts) for(let r of rks) gameState.deck.push({s, r, v: rks.indexOf(r)});
            for(let i=gameState.deck.length-1; i>0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [gameState.deck[i], gameState.deck[j]] = [gameState.deck[j], gameState.deck[i]];
            }
            gameState.round = 'PRE-FLOP'; gameState.pot = 0; gameState.communityCards = [];
            
            // 检查破产
            gameState.players.forEach(p => { 
                p.hand = []; 
                p.isFolded = p.chips <= 0; 
                if(p.chips <= 0) p.isBankrupt = true;
                p.currentBet = 0; 
                p.meshCards = []; 
            });

            gameState.isGameOver = false;
            gameState.currentMaxBet = gameState.bigBlind;
            gameState.numActionThisRound = 0;
            currentRaiseInput = gameState.minRaise;
            
            document.getElementById('btn-next').style.display = 'none';
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'block');
            
            updateUI();
            addToHistory(`--- HAND ${gameState.currentRoundNum} / ${gameState.totalRounds} ---`);
            
            // 强制下盲注
            const sbSeatIdx = getActiveOffset(gameState.dealerIdx, 1);
            const bbSeatIdx = getActiveOffset(gameState.dealerIdx, 2);
            placeBet(sbSeatIdx, gameState.smallBlind);
            placeBet(bbSeatIdx, gameState.bigBlind);
            
            const sbP = gameState.players.find(p => p.id === sbSeatIdx);
            const bbP = gameState.players.find(p => p.id === bbSeatIdx);
            if(sbP) addToHistory(`${sbP.name} posts SB $${gameState.smallBlind}`);
            if(bbP) addToHistory(`${bbP.name} posts BB $${gameState.bigBlind}`);

            for(let j=0; j<2; j++) {
                for(let i=0; i<CONFIG.numPlayers; i++) {
                    const idx = (gameState.dealerIdx + 1 + i) % CONFIG.numPlayers;
                    const p = gameState.players.find(p => p.id === idx);
                    if(!p || p.isBankrupt) continue;
                    const card = gameState.deck.pop();
                    p.hand.push(card);
                    await dealCardAnim(card, p, idx === gameState.myPlayerIdx);
                }
            }
            
            // 关键修复：正确设置 UTG 玩家的数组索引
            const utgSeatIdx = getActiveOffset(gameState.dealerIdx, 3);
            gameState.activeIdx = gameState.players.findIndex(p => p.id === utgSeatIdx);
            checkTurn();
        }

        function showFinalSummary() {
            const list = document.getElementById('summary-list-content');
            list.innerHTML = "";
            [...gameState.players].sort((a, b) => b.chips - a.chips).forEach(p => {
                const div = document.createElement('div');
                div.className = 'summary-item';
                div.innerHTML = `<span style="color:${p.id === gameState.myPlayerIdx ? 'gold' : '#fff'}">${p.name} ${p.isBankrupt ? '(Bankrupt)' : ''}</span> <b>$${p.chips}</b>`;
                list.appendChild(div);
            });
            document.getElementById('summary-modal').style.display = 'block';
        }

        async function dealCardAnim(card, player, faceUp) {
            try { SFX.deal(); } catch (_) {}
            const mesh = createCardMesh(card, faceUp);
            mesh.position.set(0, 3, 0);
            cardsGroup.add(mesh);
            player.meshCards.push(mesh);
            
            const fanOffset = (player.hand.length - 1.5) * 0.8; 
            const yOffset = 0.3 + player.hand.length * 0.05; 
            
            // 目标位置：稍微靠近桌子圆心一点点 (相对于 player.pos)
            const target = player.pos.clone().add(new THREE.Vector3(
                -Math.sin(player.angle) * 0.8 + Math.cos(player.angle) * fanOffset, 
                yOffset, 
                -Math.cos(player.angle) * 0.8 - Math.sin(player.angle) * fanOffset
            ));

            return new Promise(r => {
                gsap.to(mesh.position, { x: target.x, y: target.y, z: target.z, duration: 0.6, onComplete: r });
                // 统一旋转逻辑（修复：所有牌都朝“桌子边缘”掀起，不侧着掀）
                // 使用 YXZ，让“先Yaw到面向玩家，再Pitch掀起”在所有玩家上方向一致
                mesh.rotation.order = 'YXZ';
                // 让每一张牌都朝“该座位方向”掀起：用“牌 -> 筹码堆(或玩家位置)”的方向来确定 yaw
                const ref = (player.stackGroup && player.stackGroup.position) ? player.stackGroup.position : player.pos;
                const dx = ref.x - target.x;
                const dz = ref.z - target.z;
                const yawToSeat = Math.atan2(dx, dz);
                gsap.to(mesh.rotation, { 
                    y: yawToSeat,
                    // 正值：让靠座位/玩家一侧压低，靠桌子中心一侧抬高
                    x: 0.55,
                    z: 0,
                    duration: 0.6 
                });
            });
        }

        function createCardMesh(card, faceUp) {
            const group = new THREE.Group();
            // 卡牌主体 - 白底（PokerNow 风格）
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(CONFIG.cardWidth, 0.02, CONFIG.cardHeight), 
                new THREE.MeshStandardMaterial({ color: 0xf7f7f7, metalness: 0.05, roughness: 0.85 })
            );
            group.add(body);
            group.userData = { card: card };

            if(faceUp) {
                // 正面：白底 + 红黑花色（PokerNow-like）
                const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
                drawCardFaceCanvas(canvas, card);

                const label = new THREE.Mesh(
                    new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
                );
                label.rotation.x = -Math.PI/2; label.position.y = 0.011;
                group.add(label);
            } else {
                // 背面：金色粒子/金箔质感牌背
                const backCanvas = document.createElement('canvas'); backCanvas.width=256; backCanvas.height=384;
                drawCardBackCanvas(backCanvas);
                const back = new THREE.Mesh(
                    new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                    new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(backCanvas) })
                );
                back.rotation.x = Math.PI/2; back.position.y = 0.011;
                group.add(back);
            }
            return group;
        }

        function flipCard(mesh) {
            const card = mesh.userData.card;
            while(mesh.children.length > 1) mesh.remove(mesh.children[1]); // 保留body
            
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
            drawCardFaceCanvas(canvas, card);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
            );
            label.rotation.x = -Math.PI/2; label.position.y = 0.011;
            mesh.add(label);

            gsap.to(mesh.rotation, { x: 0, duration: 0.5 });
        }

        function revealCardOnMesh(mesh, card) {
            if (!mesh) return;
            mesh.userData.card = card;
            // remove old face/back
            while (mesh.children.length > 1) mesh.remove(mesh.children[1]);
            const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=384;
            drawCardFaceCanvas(canvas, card);
            const label = new THREE.Mesh(
                new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight),
                new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true })
            );
            label.rotation.x = -Math.PI/2; label.position.y = 0.011;
            mesh.add(label);
            // keep existing tilt; only add a tiny "reveal" nudge
            gsap.to(mesh.rotation, { x: mesh.rotation.x * 0.98, duration: 0.25 });
        }

        function orientCardTowardViewer(mesh, viewerSeatIdx) {
            if (!mesh) return;
            let ref = null;
            const viewer = gameState.players?.find(p => p.id === viewerSeatIdx);
            if (viewer && viewer.stackGroup?.position) ref = viewer.stackGroup.position;
            else if (viewer && viewer.pos) ref = viewer.pos;
            else if (camera?.position) ref = camera.position;
            if (!ref) return;

            const dx = ref.x - mesh.position.x;
            const dz = ref.z - mesh.position.z;
            const yaw = Math.atan2(dx, dz);
            mesh.rotation.order = 'YXZ';
            mesh.rotation.y = yaw;
            mesh.rotation.x = 0.28; // tilt toward viewer for readability
            mesh.rotation.z = 0;
        }

        function drawCardFaceCanvas(canvas, card) {
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            const suitChar = ({hearts:'♥',diamonds:'♦',clubs:'♣',spades:'♠'}[card.s]) || '?';
            const isRed = (card.s === 'hearts' || card.s === 'diamonds');
            const ink = isRed ? '#c21807' : '#111111';

            // background
            ctx.clearRect(0,0,W,H);
            ctx.fillStyle = '#fdfdfd';
            ctx.fillRect(0,0,W,H);

            // border (slight rounded rectangle)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 6;
            roundRect(ctx, 10, 10, W-20, H-20, 18);
            ctx.stroke();

            // corners
            ctx.fillStyle = ink;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.font = 'bold 54px Arial, sans-serif';
            ctx.fillText(String(card.r), 22, 18);
            ctx.font = 'bold 52px Arial, sans-serif';
            ctx.fillText(suitChar, 24, 76);

            // bottom-right (rotated)
            ctx.save();
            ctx.translate(W, H);
            ctx.rotate(Math.PI);
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = ink;
            ctx.font = 'bold 54px Arial, sans-serif';
            ctx.fillText(String(card.r), 22, 18);
            ctx.font = 'bold 52px Arial, sans-serif';
            ctx.fillText(suitChar, 24, 76);
            ctx.restore();

            // center suit
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = ink;
            ctx.font = 'bold 170px Arial, sans-serif';
            ctx.fillText(suitChar, W/2, H/2 + 10);
        }

        function drawCardBackCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;
            // Gold-foil base gradient
            const g = ctx.createLinearGradient(0, 0, W, H);
            g.addColorStop(0, '#6b4b12');
            g.addColorStop(0.35, '#ffd27a');
            g.addColorStop(0.65, '#b8831f');
            g.addColorStop(1, '#3a2506');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,W,H);
            ctx.strokeStyle = 'rgba(20, 12, 3, 0.85)';
            ctx.lineWidth = 6;
            roundRect(ctx, 10, 10, W-20, H-20, 18);
            ctx.stroke();

            // subtle diagonal micro-lines (foil brushing)
            ctx.globalAlpha = 0.22;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.55)';
            ctx.lineWidth = 1;
            for (let i = -H; i < W; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i + H, H);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // gold particle "sparkles"
            const rng = (a, b) => a + Math.random() * (b - a);
            for (let i = 0; i < 1800; i++) {
                const x = Math.random() * W;
                const y = Math.random() * H;
                const r = rng(0.4, 1.35);
                const bright = Math.random();
                const a = bright > 0.985 ? rng(0.65, 0.95) : rng(0.05, 0.18);
                ctx.fillStyle = bright > 0.985 ? `rgba(255, 245, 210, ${a})` : `rgba(255, 212, 120, ${a})`;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fill();
            }

            // center emblem (very subtle)
            ctx.save();
            ctx.translate(W / 2, H / 2);
            ctx.globalAlpha = 0.22;
            ctx.fillStyle = 'rgba(25, 16, 4, 0.9)';
            ctx.beginPath();
            ctx.arc(0, 0, 92, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = 'rgba(255, 230, 150, 0.9)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 92, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            const rr = Math.min(r, w/2, h/2);
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.lineTo(x + w - rr, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
            ctx.lineTo(x + w, y + h - rr);
            ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
            ctx.lineTo(x + rr, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
            ctx.lineTo(x, y + rr);
            ctx.quadraticCurveTo(x, y, x + rr, y);
            ctx.closePath();
        }

        function createFoldParticles(player) {
            player.meshCards.forEach(mesh => {
                const pos = mesh.position.clone();
                const rot = mesh.rotation.clone();
                const pColor = 0xd4af37;
                
                // 1. 创建密集的原位粒子群
                const count = 200;
                const geo = new THREE.BufferGeometry();
                const posArr = new Float32Array(count * 3);
                
                for(let i=0; i<count; i++) {
                    // 在卡牌矩形区域内随机分布
                    const ux = (Math.random()-0.5) * CONFIG.cardWidth;
                    const uz = (Math.random()-0.5) * CONFIG.cardHeight;
                    
                    // 应用卡牌的旋转
                    const p = new THREE.Vector3(ux, 0, uz).applyEuler(rot);
                    posArr[i*3] = pos.x + p.x;
                    posArr[i*3+1] = pos.y + p.y;
                    posArr[i*3+2] = pos.z + p.z;
                }
                geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
                
                const pMaterial = new THREE.PointsMaterial({ 
                    color: pColor, 
                    size: 0.03, 
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending 
                });
                const points = new THREE.Points(geo, pMaterial);
                environmentGroup.add(points);
                
                // 移除原实体
                cardsGroup.remove(mesh);
                
                // 2. 慢慢变淡的消散动画
                gsap.to(pMaterial, { 
                    opacity: 0, 
                    duration: 2.0, 
                    ease: "power1.inOut",
                    onComplete: () => environmentGroup.remove(points) 
                });
                // 粒子微弱的向上漂移感
                gsap.to(points.position, { y: "+=0.3", duration: 2.0, ease: "none" });
            });
            player.meshCards = [];
        }

        function placeBet(seatIdx, amt) {
            const p = gameState.players.find(p => p.id === seatIdx);
            if (!p) return;
            const realAmt = Math.min(amt, p.chips);
            p.chips -= realAmt;
            p.currentBet += realAmt;
            gameState.pot += realAmt;
            try { SFX.chip(); } catch (_) {}
            
            if(p.currentBet > gameState.currentMaxBet) {
                gameState.currentMaxBet = p.currentBet;
                // 只要有人加注，除了加注者外，其他人都必须重新表态
                gameState.numActionThisRound = 0; 
            }
            
            // 简单的筹码实体，用于下注动画
            const chip = new THREE.Mesh(
                new THREE.CylinderGeometry(0.21, 0.21, 0.05, 24),
                getChipMaterial().clone()
            );
            chip.material.transparent = true;
            chip.material.opacity = 0.85;
            chip.position.copy(p.pos);
            chip.position.y = 0.1;
            chipsGroup.add(chip);
            
            gsap.to(chip.position, { 
                x: (Math.random() - 0.5) * 2, 
                y: 0.05, 
                z: (Math.random() - 0.5) * 2, 
                duration: 0.6,
                ease: "power2.out"
            });
            updateUI();
        }

        function checkTurn() {
            if(gameState.isGameOver) return;
            // watchdog：如果锁住超过3秒，说明某次AI动作异常/丢失回调，强制解锁继续
            if(gameState.isProcessing) {
                if(Date.now() - (gameState.processingSince || 0) > 3000) {
                    console.warn('[WATCHDOG] Force unlock isProcessing');
                    dbg('watchdog unlock (checkTurn)');
                    gameState.isProcessing = false;
                } else {
                    return;
                }
            }
            
            const p = gameState.players[gameState.activeIdx];
            if (!p) { 
                console.warn("No player at index", gameState.activeIdx);
                dbg(`no player at idx=${gameState.activeIdx}`);
                setTimeout(() => nextStep(), 50); 
                return; 
            }

            // 如果当前玩家已弃牌或没钱了，直接跳过到下一个人
            if(p.isFolded || p.chips <= 0) { 
                dbg(`skip ${p.name} (folded=${p.isFolded}, chips=${p.chips})`);
                setTimeout(() => nextStep(), 50); 
                return; 
            }

            dbg(`turn ${p.name} idx=${gameState.activeIdx}`);
            document.getElementById('game-msg').innerText = `${gameState.round}: ${p.name}'s Turn (Idx:${gameState.activeIdx})`;
            if(p.id === gameState.myPlayerIdx) {
                toggleButtons(true);
            } else {
                toggleButtons(false);
                gameState.isProcessing = true; // AI动作加锁
                gameState.processingSince = Date.now();
                setTimeout(() => {
                    try {
                        // AI 决策
                    const callAmt = gameState.currentMaxBet - p.currentBet;
                    const rand = Math.random();
                    if(rand > 0.85 && callAmt > 0) {
                            p.isFolded = true; 
                            addToHistory(`${p.name} Folds.`); 
                            createFoldParticles(p);
                        } else if (rand > 0.7 && p.chips > (callAmt + gameState.minRaise)) {
                            // AI 加注
                        const raiseAmt = gameState.minRaise;
                            placeBet(p.id, callAmt + raiseAmt);
                        addToHistory(`${p.name} Raises to ${p.currentBet}.`);
                    } else {
                            // AI 跟注或过牌
                        if (callAmt > 0) {
                                placeBet(p.id, Math.min(callAmt, p.chips));
                                if (p.chips === 0) addToHistory(`${p.name} is ALL-IN!`);
                                else addToHistory(`${p.name} Calls.`);
                        } else {
                            addToHistory(`${p.name} Checks.`);
                        }
                    }
                    } catch (err) {
                        console.error('[AI ACTION ERROR]', err);
                        addToHistory(`ERROR: AI action failed (${p.name})`);
                    } finally {
                        gameState.isProcessing = false;
                        gameState.processingSince = 0;
                        // 无论如何都要继续推进，否则就会卡死在“某某的回合”
                        try { nextStep(); } catch(e2) { console.error('[NEXTSTEP ERROR]', e2); }
                    }
                }, 1000);
            }
        }

        function nextStep() {
            if (gameState.isGameOver) return;

            const activePlayers = gameState.players.filter(p => !p.isFolded);
            if (activePlayers.length <= 1) {
                dbg(`nextStep -> winner (activePlayers=${activePlayers.length})`);
                determineWinner();
                return;
            }

            // 1. 本轮动作计数
            gameState.numActionThisRound++;

            // 2. 判定一轮是否结束
            const allMatched = gameState.players.every(p => 
                p.isFolded || p.chips === 0 || p.currentBet === gameState.currentMaxBet
            );
            
            // 判定 Pre-flop 大盲位最后加注权利
            const bbSeatIdx = getActiveOffset(gameState.dealerIdx, 2);
            const bbPlayer = gameState.players.find(p => p.id === bbSeatIdx);
            const isBBTurn = gameState.players[gameState.activeIdx] === bbPlayer;
            const isPreFlopUnraised = (gameState.round === 'PRE-FLOP' && gameState.currentMaxBet === gameState.bigBlind);

            if (allMatched && gameState.numActionThisRound >= activePlayers.length) {
                // 特殊：Pre-flop 且还没人加注时，大盲位(BB)拥有最后说话权（仅此一次）
                if (isPreFlopUnraised && isBBTurn && gameState.numActionThisRound === activePlayers.length) {
                    dbg('preflop BB option');
                    checkTurn();
                    return;
                }
                dbg(`advanceRound (round=${gameState.round})`);
                    advanceRound();
                return;
            }

            // 3. 寻找下一个需要说话的人
            let found = false;
            let checkIdx = gameState.activeIdx;
            for(let i=0; i<gameState.players.length; i++) {
                checkIdx = (checkIdx + 1) % gameState.players.length;
                const nextP = gameState.players[checkIdx];
                if (!nextP.isFolded && nextP.chips > 0) {
                    gameState.activeIdx = checkIdx;
                    found = true;
                    dbg(`next -> ${nextP.name} idx=${checkIdx}`);
                    break;
                }
            }

            if (!found) {
                dbg('no next actor -> advanceRound');
                advanceRound();
            } else {
                checkTurn();
            }
        }

        async function advanceRound() {
            gameState.players.forEach(p => p.currentBet = 0);
            gameState.currentMaxBet = 0;
            gameState.numActionThisRound = 0;
            
            if(gameState.round === 'PRE-FLOP') { gameState.round = 'FLOP'; await dealCommunity(3); }
            else if(gameState.round === 'FLOP') { gameState.round = 'TURN'; await dealCommunity(1); }
            else if(gameState.round === 'TURN') { gameState.round = 'RIVER'; await dealCommunity(1); }
            else { 
                gameState.round = 'SHOWDOWN';
                determineWinner();
                return;
            }
            // Round starts with the player after dealer
            const startSeatIdx = getActiveOffset(gameState.dealerIdx, 1);
            let startArrIdx = gameState.players.findIndex(p => p.id === startSeatIdx);
            
            if (startArrIdx === -1) startArrIdx = 0; // 安全回退
            gameState.activeIdx = startArrIdx;

            // 如果起始玩家已经弃牌或没钱了，寻找下一个
            let loops = 0;
            while((gameState.players[gameState.activeIdx].isFolded || gameState.players[gameState.activeIdx].chips <= 0) && loops < gameState.players.length) {
                gameState.activeIdx = (gameState.activeIdx + 1) % gameState.players.length;
                loops++;
            }
            checkTurn();
        }

        async function dealCommunity(n) {
            for(let i=0; i<n; i++) {
                const card = gameState.deck.pop();
                gameState.communityCards.push(card);
                const mesh = createCardMesh(card, true);
                mesh.position.set(0, 5, 0);
                mesh.rotation.order = 'YXZ';
                mesh.rotation.set(0, 0, 0);
                cardsGroup.add(mesh);
                // 社区牌：朝当前玩家（YOU）方向旋转 + 轻微倾斜，方便读牌
                const finalX = (gameState.communityCards.length-3)*0.9;
                gsap.to(mesh.position, { x: finalX, y: 0.18, z: 0, duration: 0.7, ease: "power2.out" });
                try {
                    const viewer = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                    const ref = (viewer && viewer.stackGroup?.position) ? viewer.stackGroup.position : (viewer?.pos || camera?.position);
                    const dx = ref.x - finalX;
                    const dz = ref.z - 0;
                    const yaw = Math.atan2(dx, dz);
                    gsap.to(mesh.rotation, { x: 0.28, y: yaw, z: 0, duration: 0.7, ease: "power2.out" });
                } catch (_) {
                    gsap.to(mesh.rotation, { x: 0.28, y: 0, z: 0, duration: 0.7, ease: "power2.out" });
                }
                await new Promise(r => setTimeout(r, 200));
            }
        }

        // --- 专业德州扑克判定引擎 ---
        function getBestHand(sevenCards) {
            // 安全兜底：如果因为弃牌提前结束，可能会在翻牌前/转牌前就结算，此时牌数 < 5
            if (!sevenCards || sevenCards.length < 5) {
                return { rank: 0, value: [], desc: "No Showdown (Fold)" };
            }
            const combinations = (arr, k) => {
                const results = [];
                const combine = (start, combo) => {
                    if (combo.length === k) { results.push([...combo]); return; }
                    for (let i = start; i < arr.length; i++) {
                        combo.push(arr[i]);
                        combine(i + 1, combo);
                        combo.pop();
                    }
                };
                combine(0, []);
                return results;
            };

            const combos = combinations(sevenCards, 5);
            let best = null;

            combos.forEach(combo => {
                const evalResult = evaluate5(combo);
                if (!best || compareHands(evalResult, best) > 0) {
                    best = evalResult;
                }
            });
            return best;
        }

        function evaluate5(cards) {
            const sorted = [...cards].sort((a, b) => b.v - a.v);
            const ranks = sorted.map(c => c.v);
            const suits = sorted.map(c => c.s);
            
            const isFlush = suits.every(s => s === suits[0]);
            
            // 顺子判定 (包含 A-2-3-4-5 特殊情况)
            let isStraight = false;
            let straightMax = 0;
            const uniqueRanks = [...new Set(ranks)];
            if (uniqueRanks.length === 5) {
                if (ranks[0] - ranks[4] === 4) {
                    isStraight = true;
                    straightMax = ranks[0];
                } else if (ranks[0] === 14 && ranks[1] === 5 && ranks[4] === 2) {
                    isStraight = true;
                    straightMax = 5; // A-2-3-4-5 顺子，最大点数为 5
                }
            }

            // 频率统计
            const counts = {};
            ranks.forEach(r => counts[r] = (counts[r] || 0) + 1);
            const freq = Object.values(counts).sort((a, b) => b - a);
            const rankByFreq = Object.keys(counts).map(Number).sort((a, b) => {
                if (counts[b] !== counts[a]) return counts[b] - counts[a];
                return b - a;
            });

            // 判定逻辑
            if (isFlush && isStraight) {
                if (straightMax === 14) return { rank: 10, value: [14], desc: "Royal Flush" };
                return { rank: 9, value: [straightMax], desc: "Straight Flush" };
            }
            if (freq[0] === 4) return { rank: 8, value: [rankByFreq[0], rankByFreq[1]], desc: "Four of a Kind" };
            if (freq[0] === 3 && freq[1] === 2) return { rank: 7, value: [rankByFreq[0], rankByFreq[1]], desc: "Full House" };
            if (isFlush) return { rank: 6, value: ranks, desc: "Flush" };
            if (isStraight) return { rank: 5, value: [straightMax], desc: "Straight" };
            if (freq[0] === 3) return { rank: 4, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2]], desc: "Three of a Kind" };
            if (freq[0] === 2 && freq[1] === 2) return { rank: 3, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2]], desc: "Two Pair" };
            if (freq[0] === 2) return { rank: 2, value: [rankByFreq[0], rankByFreq[1], rankByFreq[2], rankByFreq[3]], desc: "One Pair" };
            return { rank: 1, value: ranks, desc: "High Card" };
        }

        function compareHands(h1, h2) {
            // 安全兜底：避免 null/undefined 导致崩溃
            if (!h1 && !h2) return 0;
            if (!h1) return -1;
            if (!h2) return 1;
            if (h1.rank !== h2.rank) return h1.rank - h2.rank;
            for (let i = 0; i < h1.value.length; i++) {
                if (h1.value[i] !== h2.value[i]) return h1.value[i] - h2.value[i];
            }
            return 0;
        }

        function determineWinner() {
            gameState.isGameOver = true;
            const activePlayers = gameState.players.filter(p => !p.isFolded);

            // 1) 弃牌提前结束：只剩 1 人，直接胜出，不做 Showdown 评估（避免 <5 张牌时组合评估出错）
            if (activePlayers.length === 1) {
                const p = activePlayers[0];
                addToHistory(`Game Over. ${p.name} wins (all others folded)!`);

                // 将所有筹码移动到赢家位置，且贴近桌面
                chipsGroup.children.forEach(chip => {
                    gsap.to(chip.position, { 
                        x: p.pos.x + (Math.random()-0.5)*0.5, 
                        z: p.pos.z + (Math.random()-0.5)*0.5, 
                        y: 0.05, 
                        duration: 1.2,
                        ease: "power2.inOut"
                    });
                });

                const winAmount = gameState.pot;
                setTimeout(() => {
                    p.chips += winAmount;
                    gameState.pot = 0;
                    updateUI();
                    showNextRoundButton();
                }, 1200);
                return;
            }
            // 极端兜底：如果没人了（理论上不应发生）
            if (activePlayers.length === 0) {
                addToHistory(`Game Over. (No active players)`);
                gameState.pot = 0;
                updateUI();
                showNextRoundButton();
                return;
            }
            
            // 全体亮牌并评估
            const evaluations = activePlayers.map(p => {
                p.meshCards.forEach(mesh => flipCard(mesh));
                return { player: p, result: getBestHand([...p.hand, ...gameState.communityCards]) };
            });

            // 寻找最强牌型
            evaluations.sort((a, b) => compareHands(b.result, a.result));
            const bestResult = evaluations[0]?.result;
            const winners = bestResult ? evaluations.filter(e => compareHands(e.result, bestResult) === 0) : [evaluations[0]];

            const winnerNames = winners.map(w => w.player.name).join(" & ");
            addToHistory(`Game Over. ${winnerNames} wins with ${bestResult?.desc || 'Unknown'}!`);
            
            // 分池逻辑
            const winAmount = Math.floor(gameState.pot / winners.length);
            
            winners.forEach((w, idx) => {
                const p = w.player;
                // 将所有筹码移动到赢家位置，且贴近桌面
                chipsGroup.children.forEach(chip => {
                    gsap.to(chip.position, { 
                        x: p.pos.x + (Math.random()-0.5)*0.5, 
                        z: p.pos.z + (Math.random()-0.5)*0.5, 
                        y: 0.05, 
                    duration: 1.2, 
                        ease: "power2.inOut"
                    });
                });

                // 延迟更新UI，等动画结束
                setTimeout(() => {
                    if(idx === 0) { // 只在第一个赢家时清空并更新一次UI（简单处理）
                        p.chips += winAmount;
                        gameState.pot = 0;
                        updateUI();
                        showNextRoundButton();
                    } else {
                        p.chips += winAmount;
                        updateUI();
                    }
                }, 1200);
            });
        }

        function showNextRoundButton() {
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.style.display = 'none');
            document.getElementById('btn-next').style.display = 'block';
        }

        function updateUI() {
            document.getElementById('pot-amount').innerText = gameState.pot;
            gameState.players.forEach((p) => {
                const el = document.getElementById(`chips-${p.id}`);
                if(el) el.innerText = `$${p.chips}`;
                updatePlayerStackMesh(p);
            });
            document.getElementById('raise-amount-display').innerText = currentRaiseInput;

            // Offline: keep Check button label consistent with online (shows needed amount)
            try {
                const btnCheck = document.getElementById('btn-check');
                const btnRaise = document.getElementById('btn-raise');
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                const toCall = me ? Math.max(0, Number(gameState.currentMaxBet || 0) - Number(me.currentBet || 0)) : 0;
                const callPay = me ? Math.max(0, Math.min(toCall, Number(me.chips || 0))) : 0;
                if (btnCheck && !IS_MULTIPLAYER) {
                    btnCheck.innerText = 'Check';
                    btnCheck.style.display = (toCall > 0) ? 'none' : 'block';
                }
                if (btnRaise && !IS_MULTIPLAYER) {
                    if (toCall > 0) {
                        const extra = Number(currentRaiseInput || 0);
                        btnRaise.innerText = (extra <= 0)
                            ? `Call $${callPay}${(me && Number(me.chips || 0) > 0 && Number(me.chips || 0) < toCall) ? ' (All-in)' : ''}`
                            : `Raise +$${extra}`;
                    } else {
                        const betAmt = Math.max(Number(gameState.minRaise || 50), Number(currentRaiseInput || 0) || 0);
                        btnRaise.innerText = `Bet $${betAmt}`;
                    }
                }
            } catch (_) {}
        }

        function addToHistory(msg) {
            const list = document.getElementById('history-list');
            const div = document.createElement('div');
            div.innerHTML = `<span style="color:#d4af37;opacity:0.5">></span> ${msg}`;
            list.prepend(div);
        }

        function toggleButtons(on) {
            document.querySelectorAll('#controls button:not(#btn-next)').forEach(b => b.disabled = !on);
        }

        function setupEvents() {
            window.onresize = () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };

            // BGM UI (user gesture required for autoplay policies)
            try {
                const bgm = document.getElementById('bgm');
                const bgmBtn = document.getElementById('bgm-toggle');
                // Default ON (用户可手动关闭). Browsers may block audible autoplay, so we:
                // 1) try normal play; 2) fallback to muted autoplay; 3) unmute on first user gesture.
                const saved = localStorage.getItem('nebula_bgm') || 'on';
                const setLabel = (on) => { if (bgmBtn) bgmBtn.innerText = on ? 'BGM: On' : 'BGM: Off'; };
                setLabel(saved === 'on');
                if (bgm) {
                    bgm.volume = 0.35;
                    bgm.muted = false;
                }
                const tryAutoPlay = async () => {
                    if (!bgm) return;
                    if (!(localStorage.getItem('nebula_bgm') === 'on' || !localStorage.getItem('nebula_bgm'))) return;
                    try {
                        bgm.muted = false;
                        await bgm.play();
                        return;
                    } catch (_) {
                        // Audible autoplay likely blocked. Try muted autoplay.
                        try {
                            bgm.muted = true;
                            await bgm.play();
                            return;
                        } catch (e2) {
                            console.warn('[bgm] autoplay failed', e2);
                        }
                    }
                };
                // Always: on first user gesture, ensure audio is playing (no need to toggle Off->On).
                const ensurePlayingOnGesture = async () => {
                    try {
                        if (!bgm) return;
                        if (!(localStorage.getItem('nebula_bgm') === 'on' || !localStorage.getItem('nebula_bgm'))) return;
                        if (bgm.paused) {
                            bgm.muted = false;
                            await bgm.play();
                        } else if (bgm.muted) {
                            bgm.muted = false;
                        }
                    } catch (_) {}
                };
                window.addEventListener('pointerdown', ensurePlayingOnGesture, { once: true });
                window.addEventListener('keydown', ensurePlayingOnGesture, { once: true });
                if (bgmBtn) {
                    bgmBtn.onclick = async () => {
                        if (!bgm) return;
                        const wantOn = !(localStorage.getItem('nebula_bgm') === 'on');
                        localStorage.setItem('nebula_bgm', wantOn ? 'on' : 'off');
                        setLabel(wantOn);
                        try {
                            if (wantOn) {
                                bgm.muted = false;
                                await bgm.play();
                            } else {
                                bgm.pause();
                                bgm.muted = false;
                            }
                        } catch (e) {
                            // Most common: autoplay blocked or codec unsupported
                            console.warn('[bgm] play failed', e);
                            alert('BGM failed to play. If autoplay is blocked, tap once and try again.');
                            localStorage.setItem('nebula_bgm', 'off');
                            setLabel(false);
                        }
                    };
                }
                // attempt autoplay on load (default ON)
                if (saved === 'on') {
                    setTimeout(() => { tryAutoPlay(); }, 0);
                }
            } catch (_) {}

            // SFX toggle
            try {
                const sfxBtn = document.getElementById('sfx-toggle');
                if (sfxBtn) {
                    const apply = () => { sfxBtn.innerText = SFX.isEnabled() ? 'SFX: On' : 'SFX: Off'; };
                    apply();
                    sfxBtn.onclick = async () => {
                        const next = !SFX.isEnabled();
                        SFX.setEnabled(next);
                        apply();
                        if (next) {
                            try { await SFX.ensureCtx(); } catch (_) {}
                            // small confirmation blip
                            try { SFX.turn(); } catch (_) {}
                        }
                    };
                }
            } catch (_) {}

            // Voice UI
            updateMicButton();
            if (!IS_MULTIPLAYER) {
                setVoiceStatus('Voice: Online only');
                const micBtn = document.getElementById('mic-toggle');
                if (micBtn) micBtn.disabled = true;
            } else {
                const micBtn = document.getElementById('mic-toggle');
                if (micBtn) {
                    micBtn.onclick = async () => {
                        // Must be seated to join voice (server enforces this)
                        if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) {
                            alert('Take a seat before joining voice.');
                            return;
                        }
                        await voiceJoinIfPossible();
                        if (!voiceState.localStream) return;
                        const track = voiceState.localStream.getAudioTracks()[0];
                        const nextOn = !voiceState.micOn;
                        voiceState.micOn = nextOn;
                        if (track) track.enabled = nextOn;
                        setVoiceStatus(voiceState.connected ? `Voice: Connected${nextOn ? '' : ' (muted)'}` : 'Voice: Not connected');
                        updateMicButton();
                    };
                }
            }
            
            // Lobby Interaction
            document.getElementById('lobby-next-btn').onclick = () => {
                const user = document.getElementById('username-input').value;
                const room = document.getElementById('room-id-input').value;
                const initChips = parseInt(document.getElementById('init-chips-input').value);
                const totalRounds = parseInt(document.getElementById('total-rounds-input').value);

                if(!user || !room) { alert("Please enter Username and Room ID"); return; }
                if(initChips < 1000 || initChips % 50 !== 0) { alert("Initial Chips must be >= 1000 and multiple of 50"); return; }

                gameState.initialChips = initChips;
                gameState.totalRounds = totalRounds;

                if (IS_MULTIPLAYER) {
                    wireMultiplayer();
                    pendingJoin = true;
                    joinedRoomOnce = false;
                    socket.emit('join_room', { roomId: room, name: user });
                    document.getElementById('lobby-overlay').style.display = 'none';
                    showSeatSelection(); // UI仍显示，但数据来自服务器
                } else {
                    document.getElementById('lobby-overlay').style.display = 'none';
                    showSeatSelection();
                }
            };

            function showSeatSelection() {
                const seatOverlay = document.getElementById('seat-overlay');
                const seatGrid = document.getElementById('seat-grid');
                seatGrid.innerHTML = "";
                seatOverlay.style.display = 'block';

                for(let i=0; i<CONFIG.numPlayers; i++) {
                    const box = document.createElement('div');
                    box.className = 'seat-box';
                    box.id = `seat-box-${i}`;
                    box.innerHTML = `
                        <div style="position: relative; font-weight: bold; margin-bottom: 10px;">
                            Seat ${i+1}
                            <span id="seat-host-${i}" style="display:none; position:absolute; right:0; top:0; font-size:12px; color:gold; opacity:0.95;">🔑 HOST</span>
                        </div>
                        <div id="seat-status-${i}" style="font-size: 0.8em; margin-bottom: 15px; color: #aaa;">Empty</div>
                        <div class="seat-actions">
                            <button class="seat-action-btn" id="join-btn-${i}">Take Seat</button>
                            <button class="seat-action-btn" id="ai-btn-${i}">Add AI</button>
                            <button class="seat-action-btn" id="kick-btn-${i}" style="display:none;">Remove</button>
                        </div>
                    `;
                    seatGrid.appendChild(box);

                    // 选座逻辑
                    document.getElementById(`join-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (IS_MULTIPLAYER) {
                            socket.emit('take_seat', { seatIdx: i });
                            mySeatIdx = i;
                            gameState.myPlayerIdx = i;
                        } else {
                            // 取消之前的玩家选座
                            if(gameState.myPlayerIdx !== -1) {
                                gameState.seatConfig[gameState.myPlayerIdx] = null;
                            }
                            gameState.myPlayerIdx = i;
                            gameState.seatConfig[i] = 'player';
                            updateSeatUI();
                        }
                    };

                    document.getElementById(`ai-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (IS_MULTIPLAYER) {
                            // 仅 host 生效，服务端会拒绝非 host
                            socket.emit('toggle_ai', { seatIdx: i });
                        } else {
                            if(gameState.seatConfig[i] === 'player') return; // 不能覆盖玩家
                            gameState.seatConfig[i] = (gameState.seatConfig[i] === 'ai') ? null : 'ai';
                            updateSeatUI();
                        }
                    };

                    // host remove player (multiplayer only)
                    document.getElementById(`kick-btn-${i}`).onclick = (e) => {
                        e.stopPropagation();
                        if (!IS_MULTIPLAYER) return;
                        socket.emit('kick_seat', { seatIdx: i });
                    };
                }

                function updateSeatUI() {
                    for(let i=0; i<CONFIG.numPlayers; i++) {
                        const statusEl = document.getElementById(`seat-status-${i}`);
                        const joinBtn = document.getElementById(`join-btn-${i}`);
                        const aiBtn = document.getElementById(`ai-btn-${i}`);
                        const box = document.getElementById(`seat-box-${i}`);

                        if(gameState.seatConfig[i] === 'player') {
                            statusEl.innerText = "YOU";
                            statusEl.style.color = "gold";
                            joinBtn.classList.add('active');
                            aiBtn.style.display = "none";
                        } else if(gameState.seatConfig[i] === 'ai') {
                            statusEl.innerText = "AI BOT";
                            statusEl.style.color = "#00ff00";
                            joinBtn.style.display = "none";
                            aiBtn.classList.add('active');
                            aiBtn.innerText = "Remove AI";
                        } else {
                            statusEl.innerText = "Empty";
                            statusEl.style.color = "#aaa";
                            joinBtn.style.display = "block";
                            joinBtn.classList.remove('active');
                            aiBtn.style.display = "block";
                            aiBtn.classList.remove('active');
                            aiBtn.innerText = "Add AI";
                        }
                    }
                }
                updateSeatUI();
            }

            document.getElementById('start-game-btn').onclick = () => {
                if(gameState.myPlayerIdx === -1) {
                    alert("You must select a seat first!");
                    return;
                }
                const occupiedCount = gameState.seatConfig.filter(s => s !== null).length;
                if(occupiedCount < 3) {
                    alert("At least 3 players (including AI) are needed to start!");
                    return;
                }

                gsap.to('#seat-overlay', { opacity: 0, duration: 0.5, onComplete: () => {
                    document.getElementById('seat-overlay').style.display = 'none';
                    createPlayers();
                    if (IS_MULTIPLAYER) {
                        if (!isHost) { alert("Waiting for host to start..."); return; }
                        socket.emit('start_game', { totalHands: gameState.totalRounds, initialChips: gameState.initialChips });
                    } else {
                        startNewHand();
                    }
                }});
            };

            // Rules Modal Events
            // Re-anchor rules panel under the Rules button (inside the same UI panel)
            const rulesBtn = document.getElementById('rules-btn');
            const rulesModal = document.getElementById('rules-modal');
            const rulesAnchor = document.getElementById('rules-modal-anchor');
            if (rulesAnchor && rulesModal) rulesAnchor.appendChild(rulesModal);

            rulesBtn.onclick = () => {
                rulesModal.style.display = (rulesModal.style.display === 'block') ? 'none' : 'block';
            };
            document.getElementById('close-rules').onclick = () => { rulesModal.style.display = 'none'; };
            // 点击其它区域关闭（但在面板内部点击不关）
            window.addEventListener('click', (event) => {
                if (!rulesModal || !rulesBtn) return;
                const target = event.target;
                if (rulesModal.style.display !== 'block') return;
                if (rulesModal.contains(target) || rulesBtn.contains(target)) return;
                rulesModal.style.display = 'none';
            });

            // Theme toggle (Night / Light)
            const themeBtn = document.getElementById('theme-toggle');
            const applyTheme = (mode) => {
                document.documentElement.setAttribute('data-theme', mode);
                localStorage.setItem('nebula_theme', mode);
                themeBtn.innerText = (mode === 'light') ? 'Night Mode' : 'Light Mode';

                // also adjust 3D background/fog a bit
                if (scene) {
                    if (mode === 'light') {
                        // warm daylight, soft orange glow
                        // make 3D clear transparent so CSS casino background is visible
                        scene.background = null;
                        scene.fog = new THREE.FogExp2(0xfff0db, 0.016);
                        if (renderer) renderer.setClearColor(0x000000, 0);
                        if (starField) starField.visible = false;
                    } else {
                        scene.background = new THREE.Color(0x080401);
                        scene.fog = new THREE.FogExp2(0x080401, 0.02);
                        if (renderer) renderer.setClearColor(0x000000, 1);
                        if (starField) starField.visible = true;
                    }
                }
            };
            const savedTheme = localStorage.getItem('nebula_theme') || 'night';
            applyTheme(savedTheme);
            themeBtn.onclick = () => {
                const current = document.documentElement.getAttribute('data-theme') || 'night';
                applyTheme(current === 'light' ? 'night' : 'light');
            };
            
            document.getElementById('btn-plus').onclick = () => { currentRaiseInput += gameState.minRaise; updateUI(); };
            document.getElementById('btn-minus').onclick = () => {
                // allow 0 so "Raise" button can become "Call" when facing a bet
                if (currentRaiseInput > 0) currentRaiseInput = Math.max(0, currentRaiseInput - gameState.minRaise);
                updateUI();
            };
            
            document.getElementById('btn-fold').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    socket.emit('action', { type: 'fold' });
                } else {
                    me.isFolded = true;
                    createFoldParticles(me);
                addToHistory("You Folded.");
                nextStep();
                }
            };
            document.getElementById('btn-check').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    // Only meaningful when toCall==0; if facing a bet, "Call" is handled by the Bet/Raise button.
                    const callAmt = gameState.currentMaxBet - me.currentBet;
                    if (callAmt > 0) { toggleButtons(true); return; }
                    socket.emit('action', { type: 'call' }); // server decides check
                } else {
                    const callAmt = gameState.currentMaxBet - me.currentBet;
                if (callAmt > 0) {
                        placeBet(me.id, callAmt);
                    addToHistory(`You Called $${callAmt}.`);
                } else {
                    addToHistory("You Checked.");
                }
                nextStep();
                }
            };
            document.getElementById('btn-raise').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    // Unified BET/RAISE/CALL:
                    // - if facing a bet and extra==0 => CALL
                    // - if facing a bet and extra>0 => RAISE (by extra)
                    // - if no bet yet => BET (by extra; must be >= minRaise)
                    const callAmt = Math.max(0, Number(gameState.currentMaxBet || 0) - Number(me.currentBet || 0));
                    const extra = Number(currentRaiseInput || 0);
                    if (callAmt > 0 && extra <= 0) {
                        socket.emit('action', { type: 'call' });
                    } else {
                        const min = Number(gameState.minRaise || 50);
                        const raiseBy = Math.max(min, extra);
                        socket.emit('action', { type: 'raise', raiseBy });
                    }
                } else {
                    const callAmt = gameState.currentMaxBet - me.currentBet;
                    const extra = Number(currentRaiseInput || 0);
                    if (callAmt > 0 && extra <= 0) {
                        placeBet(me.id, Math.min(callAmt, me.chips));
                        addToHistory(`You Called $${Math.min(callAmt, me.currentBet)}.`);
                        nextStep();
                        return;
                    }
                    const min = Number(gameState.minRaise || 50);
                    const raiseBy = Math.max(min, extra);
                    const totalRaise = callAmt + raiseBy;
                    placeBet(me.id, totalRaise);
                    addToHistory(callAmt > 0 ? `You Raised $${raiseBy} (Total $${me.currentBet}).` : `You Bet $${raiseBy}.`);
                    nextStep();
                }
            };
            document.getElementById('btn-allin').onclick = () => {
                toggleButtons(false);
                const me = gameState.players.find(p => p.id === gameState.myPlayerIdx);
                if(!me) return;
                if (IS_MULTIPLAYER) {
                    socket.emit('action', { type: 'allin' });
                } else {
                    const allInAmt = me.chips;
                    placeBet(me.id, allInAmt);
                addToHistory("YOU ALL-IN!!!");
                nextStep();
                }
            };
            document.getElementById('btn-rebuy').onclick = () => {
                if (!IS_MULTIPLAYER) return;
                if (!(Number.isInteger(mySeatIdx) && mySeatIdx >= 0)) return;
                const def = Number.isFinite(Number(gameState.initialChips)) ? Number(gameState.initialChips) : 1000;
                const raw = prompt('Rebuy amount (>=1000 and multiple of 50):', String(def));
                if (raw === null) return;
                const amt = Number(raw);
                if (!Number.isFinite(amt) || amt < 1000 || (amt % 50) !== 0) {
                    alert('Rebuy amount must be >=1000 and a multiple of 50.');
                    return;
                }
                try { socket.emit('rebuy', { amount: amt }); } catch(_) {}
                addToHistory(`Rebuy: $${amt} (applies next hand)`);
            };
            document.getElementById('btn-next').onclick = () => {
                if (IS_MULTIPLAYER) {
                    socket.emit('next_hand');
                } else {
                gameState.dealerIdx = (gameState.dealerIdx + 1) % CONFIG.numPlayers;
                startNewHand();
                }
            };
        }

        function updateSeatOverlayFromServer(state) {
            // 同步“Start Game”按钮是否可点
            const startBtn = document.getElementById('start-game-btn');
            if (!startBtn) return;
            startBtn.innerText = isHost ? 'Start Game' : 'Waiting for Host';
            startBtn.disabled = !isHost;

            // 同步每个座位的显示（Empty / YOU / AI BOT / PlayerName）
            for (let i = 0; i < CONFIG.numPlayers; i++) {
                const statusEl = document.getElementById(`seat-status-${i}`);
                const joinBtn = document.getElementById(`join-btn-${i}`);
                const aiBtn = document.getElementById(`ai-btn-${i}`);
                const hostEl = document.getElementById(`seat-host-${i}`);
                const kickBtn = document.getElementById(`kick-btn-${i}`);
                if (!statusEl || !joinBtn || !aiBtn) continue;

                if (hostEl) {
                    hostEl.style.display = (state.hostSeatIdx === i) ? 'inline' : 'none';
                }

                const s = state.seats?.[i] || null;
                if (!s) {
                    statusEl.innerText = "Empty";
                    statusEl.style.color = "#aaa";
                    joinBtn.style.display = "block";
                    joinBtn.classList.remove('active');
                    aiBtn.style.display = isHost ? "block" : "none";
                    aiBtn.classList.remove('active');
                    aiBtn.innerText = "Add AI";
                    if (kickBtn) kickBtn.style.display = "none";
                    continue;
                }

                if (s.type === 'ai') {
                    statusEl.innerText = s.name || "AI BOT";
                    statusEl.style.color = "#00ff00";
                    joinBtn.style.display = "none";
                    aiBtn.style.display = isHost ? "block" : "none";
                    aiBtn.classList.add('active');
                    aiBtn.innerText = "Remove AI";
                    if (kickBtn) kickBtn.style.display = "none";
                    continue;
                }

                // player
                const isMe = (mySeatIdx === i);
                statusEl.innerText = isMe ? "YOU" : (s.name || "PLAYER");
                // 统一为白色
                statusEl.style.color = "#fff";
                joinBtn.style.display = isMe ? "block" : "none";
                joinBtn.classList.toggle('active', isMe);
                aiBtn.style.display = "none";

                // Host-only kick button for players (not for self)
                if (kickBtn) {
                    if (isHost && !isMe) {
                        kickBtn.style.display = "block";
                    } else {
                        kickBtn.style.display = "none";
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if(starField) {
                starField.rotation.y += 0.0005;
                starField.rotation.x += 0.0002;
            }
            if(tableParticles) {
                tableParticles.rotation.y += 0.001;
            }

            hudData.forEach(hud => {
                const v = hud.pos.clone().project(camera);
                hud.el.style.left = `${(v.x * 0.5 + 0.5) * window.innerWidth}px`;
                hud.el.style.top = `${(-(v.y * 0.5 - 0.5)) * window.innerHeight}px`;
                hud.el.style.display = v.z < 1 ? 'block' : 'none';
            });
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>
